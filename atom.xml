<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>解忧杂货铺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jwkang99.github.io/"/>
  <updated>2021-06-20T15:11:13.310Z</updated>
  <id>https://jwkang99.github.io/</id>
  
  <author>
    <name>康宁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字节笔试0613</title>
    <link href="https://jwkang99.github.io/posts/c3e2d5b.html"/>
    <id>https://jwkang99.github.io/posts/c3e2d5b.html</id>
    <published>2021-06-13T11:02:48.000Z</published>
    <updated>2021-06-20T15:11:13.310Z</updated>
    
    <content type="html"><![CDATA[<h5 id="3道编程题"><a href="#3道编程题" class="headerlink" title="3道编程题"></a>3道编程题</h5><ol><li>二叉树最大权值和</li></ol><p>给定一颗具有n节点的完全二叉树， 需要从这棵树中选择一部分节点，求其 最大权值和。</p><p>规则：如果选择了一个节点的任意子节点，则不可以选择这个节点。求这部分节点的数字和最大值。</p><ol><li>感染人群</li></ol><p>求给定N个人被感染和人与人之间的接触关系下，可以覆盖所有被感染人群，且人数最少的最优 路径。</p><ol><li>座位安排</li></ol><p>给定人数情况下，求座位数；</p><p>规则：不能有两个人挨着坐，每个人都按照观察最长连续空座位，然后选中间那个位子坐（如果有多个满足需求则取左边个）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;3道编程题&quot;&gt;&lt;a href=&quot;#3道编程题&quot; class=&quot;headerlink&quot; title=&quot;3道编程题&quot;&gt;&lt;/a&gt;3道编程题&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;二叉树最大权值和&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定一颗具有n节点的完全二叉树， 需要从这棵树中选择一部分
      
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://jwkang99.github.io/categories/uncategorized/"/>
    
    
      <category term="字节跳动" scheme="https://jwkang99.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="https://jwkang99.github.io/posts/b38f68fb.html"/>
    <id>https://jwkang99.github.io/posts/b38f68fb.html</id>
    <published>2021-05-17T02:02:48.000Z</published>
    <updated>2021-06-20T15:17:57.567Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/posts/b38f68fb/gc.png" data-fancybox="group" data-caption="hotspot虚拟机的垃圾收集器" class="fancybox"><img alt="hotspot虚拟机的垃圾收集器" style="zoom:70%;" title="hotspot虚拟机的垃圾收集器" data-src="/posts/b38f68fb/gc.png" class="lazyload"></a></p><p>上图展示了垃圾收集器中可以可以进行的组合。</p><p>以上垃圾收集器的所有关注点包括两个：<strong>吞吐量</strong>（CPU运行用户代码的时间比例）和<strong>停顿时间</strong>。</p><p><strong>短停顿时间</strong>：适合与用户交互的程序，良好的响应速度提升用户体验。</p><p><strong>高吞吐量适合</strong>：可以高效率利用CPU时间，尽快完成运算任务，适合在后台运算而不需要太多交互的任务。</p><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h3><p>单线程收集器，<strong>特点</strong></p><ol><li>只会使用一个CPU或者一个线程去收集垃圾，</li><li><strong>串行</strong>，在它进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>（Stop The World），直到它收集结束。</li><li>但是用户对这个暂停时间不可见。</li><li>Serial和Serial Old分别用在新生代（复制算法）和老年代（标记整理算法）。</li><li>Serial收集器仍是虚拟机运行在<strong>Client模式下</strong>的默认新生代收集器。</li></ol><p><a href="/posts/b38f68fb/serial.png" data-fancybox="group" data-caption="Serial/Serial Old收集过程" class="fancybox"><img alt="Serial/Serial Old收集过程" title="Serial/Serial Old收集过程" data-src="/posts/b38f68fb/serial.png" class="lazyload"></a></p><p><strong>优点</strong>：</p><ol><li>简单高效（和其他收集器的单线程相比）。</li><li>用户桌面应用场景中，可用内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li><li>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</li></ol><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h3><p>ParNew收集器是Serial的多线程版本，<strong>特点</strong>：</p><ol><li>除了使用<strong>多条线程收集垃圾</strong>，其余的和Serial收集器完全一致，同样暂停其他所有线程（Stop The World）</li><li>因为目前只有ParNew能与CMS配合工作，故ParNew是许多运行在<strong>Server模式</strong>虚拟机的首选</li><li>ParNew在单CPU<strong>绝对不会</strong>有比Serial更好的效果，因为有线程交替执行</li><li>当然多CPU下，可以有效利用资源，效果更好</li><li>-XX:+UseConcMarkSweepGC默认新生代使用ParNew收集器，或者用+/-UseParNewGC强制指定或禁止它。</li></ol><p><a href="/posts/b38f68fb/parnew.png" data-fancybox="group" data-caption="ParNew/Serial Old收集过程" class="fancybox"><img alt="ParNew/Serial Old收集过程" title="ParNew/Serial Old收集过程" data-src="/posts/b38f68fb/parnew.png" class="lazyload"></a></p><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个<strong>新生代收集器</strong>（复制算法），并行的多线程收集器。</p><p>Parallel Scavenge收集器的关注点在于<strong>达到一个指定的吞吐量（CPU运行用户代码占比）</strong>。</p><p>提供两个参数：</p><ol><li>-XX：MaxGCPauseMillis：最大垃圾收集停顿时间，尽可能保证垃圾回收不超过该时间</li><li>-XX：GCTimeRatio：大于0小于100的整数，直接设置吞吐量大小，垃圾收集时间永远为单位1，例如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5% （即1/(1+19)）</li><li>-XX：+UseAdaptiveSizePolicy：开关参数，当这个参数被激活之后，不需要人工指定新生代的大小等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，称为自适应的调节策略。</li></ol><h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h3><p>Serial Old是Serial的老年代版本</p><ol><li>单线程，适用于在Client模式的虚拟机</li><li>在Server模式下可与Parallel Scavenge收集器搭配使用，或者作为CMS的后备方案</li></ol><h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用标记整理算法。</p><p>在注重吞吐量以及CPU资源敏感的场合中，可以优先考虑Parallel Scavenge+Parallel Old的组合。</p><p><a href="/posts/b38f68fb/parallel.png" data-fancybox="group" data-caption="parallel收集过程" class="fancybox"><img alt="parallel收集过程" title="parallel收集过程" data-src="/posts/b38f68fb/parallel.png" class="lazyload"></a></p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是老年代收集器，关注点：<strong>获取最短回收停顿时间</strong>，采用标记清除算法，<strong>特点</strong>：并发收集，低停顿。分为四个步骤</p><ol><li>初始标记：标记GC Roots能直接关联的对象，<strong>暂停用户线程</strong>，速度很快</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，且用户线程可以与垃圾收集线程一起并发运行</li><li>重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，采用用增量更新算法，<strong>停顿时间较短</strong></li><li>并发清除：回收标记对象，与用户进程并发运行</li></ol><p><a href="/posts/b38f68fb/CMS.png" data-fancybox="group" data-caption="cms收集过程" class="fancybox"><img alt="cms收集过程" title="cms收集过程" data-src="/posts/b38f68fb/CMS.png" class="lazyload"></a></p><p>缺点：</p><ol><li>对CPU资源<strong>非常敏感</strong>（并发程序共同点），虽然不会导致用户线程停顿，但是占用了CPU资源，会是应用程序变慢。</li><li>无法处理<strong>浮动垃圾</strong>，并发清除阶段用户还在运行，会产生新的垃圾（称为浮动垃圾），这些垃圾出现在标记之后，只能等下一次GC。</li><li>需要<strong>预留空间</strong>，要为运行的用户线程预留可用空间，故不能等老年底被填满了再GC。可通过参数-XX：CMSInitiatingOccupancyFraction设置CMS触发百分比。若在CMS的GC过程中，预留空间不足以用户运行，则会出现Concurrent Mode Failure失败， 执行启动后备<strong>预案</strong>：冻结用户线程的，启动Serial Old收集器重新收集老年代。</li><li>采用标记清除算法， 会有<strong>碎片产生</strong>，若无连续足够空间，不得不提前触发GC。CMS提供参数个-XX：+UseCMS-CompactAtFullCollection，打开之后用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，但是<strong>必须停顿用户线程</strong>。还有另外一个参数-XX：CMSFullGCsBeforeCompaction，用于指定执行多少次无整理压缩的GC之后，整理一次空间。</li></ol><h3 id="7-Garbage-First收集器"><a href="#7-Garbage-First收集器" class="headerlink" title="7. Garbage First收集器"></a>7. Garbage First收集器</h3><p>G1收集器主要面向服务端应用。</p><p>之前的几个垃圾收集器只关注新生代（Minor GC）或老年代（Major GC）中之一的垃圾收集。</p><p>G1收集器跳出限制，面向java堆内任何区域组成<strong>回收集</strong>（Collection Set），衡量标准不再是它属于哪个分代，而是<strong>哪块内存中存放的垃圾数量最多</strong>，<strong>回收收益最大</strong>，这就是G1收集器的Mixed GC模式。</p><p>G1收集器基于Region实现上述目标：把java堆分为连续大小相等的<strong>多个Region区域</strong>，每个Region根据需要都可以是Survivor、Eden、或者老年代，针对扮演角色不同的Region区域采取<strong>不同的策略</strong>。</p><p>分为四个步骤：</p><ol><li>初始标记：标记GC Roots能直接关联的对象，并且指定每个Region中可以用于给并发执行的用户线程分配对象的空间区域，需要暂停用户线程，但是速度很快。</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，且用户线程可以与垃圾收集线程一起并发运行。</li><li>最终标记：采用原始快照方法更新并发过程中被修改的标记</li><li>筛选回收：找出回收价值最大的Region，将其数据复制到空的Region上，必须暂停用户线程，清空Region区域</li></ol><p><a href="/posts/b38f68fb/g1.png" data-fancybox="group" data-caption="g1收集过程" class="fancybox"><img alt="g1收集过程" title="g1收集过程" data-src="/posts/b38f68fb/g1.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/posts/b38f68fb/gc.png&quot; data-fancybox=&quot;group&quot; data-caption=&quot;hotspot虚拟机的垃圾收集器&quot; class=&quot;fancybox&quot;&gt;&lt;img alt=&quot;hotspot虚拟机的垃圾收集器&quot; style
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM判断对象是否可回收</title>
    <link href="https://jwkang99.github.io/posts/d51b6e9c.html"/>
    <id>https://jwkang99.github.io/posts/d51b6e9c.html</id>
    <published>2021-05-16T02:02:48.000Z</published>
    <updated>2021-06-11T14:11:36.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h2><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1 引用计数法"></a>1 引用计数法</h3><p>给每个对象添加一个<strong>引用计数器</strong>，每当一个地方引用它，计数器加1，失效就减1。任何时刻计数器为0的对象就是不可能在被使用的对象，说明该对象已死。</p><p>引用计数法实现简单，效率高。但是很难解决对象互相循环引用的问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object A = <span class="keyword">new</span> Object();</span><br><span class="line">Object B = <span class="keyword">new</span> Object();</span><br><span class="line">A.prop1 = B;</span><br><span class="line">B.prop1 = A;</span><br><span class="line">A=<span class="keyword">null</span>;</span><br><span class="line">B=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></div><p>上述例子若采用引用计数法，即使A,B对象占用的内存区域用不到了，A,B对象永远无法回收，因为计数器为1。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2 可达性分析算法"></a>2 可达性分析算法</h3><p>主流的商用程序语言主要使用的是<strong>可达性分析算法</strong>。</p><p>可达性分析算法是从一系列称为<strong>GC Roots</strong>的对象做为起点，开始搜索，走过的路径称为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链时，则该对象不可用，可以回收。</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>GC Roots主要在全局性的引用（常量和静态变量）和执行上下文（栈帧的本变量表）中。分为两类，一类是<strong>生命周期很长</strong>的对象比如说类的静态变量，另一类是<strong>一定是有用的对象</strong>比如说栈帧的局部变量，这里代表了程序正在执行的地方，这里应用的对象一定是不能被回收的。Java可以作为GC Roots的对象包括下边几种：</p><p>① 虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。<br>② 方法区中<strong>类静态属性</strong>引用的对象，譬如Java类的<strong>引用类型</strong>静态变量。<br>③ 方法区中<strong>常量</strong>引用的对象，譬如<strong>字符串常量池</strong>（String Table）里的引用<br>④ 本地方法栈中JNI（即一般说的Native方法）引用的对象。<br>⑤ Java虚拟机内部的引用，如基本类型数据对应的Class对象，一些常驻的异常对象，类加载器等。<br>⑥ 所有被同步锁（synchronized关键字）持有的对象。</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“<strong>临时性</strong>”地加入，共同构成完整GC Roots集合。举例：。。。</p><h3 id="3-引用类型"><a href="#3-引用类型" class="headerlink" title="3 引用类型"></a>3 引用类型</h3><p>上述两种方法都和引用有关，在JDK 1.2版之前，Java里面的引用是很传统的定义，只有“被引用”或者“未被引用”两种状态。</p><p>我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象，在很多系统的<strong>缓存功能</strong>都符合这样的应用场景。</p><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>（Strongly Reference）、<strong>软引用</strong>（Soft Reference）、<strong>弱引用</strong>（Weak Reference）和<strong>虚引用</strong>（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li><strong>强引用</strong>：最传统的引用的定义，是指直接引用赋值，类似<code>Object obj = new Object()</code>，只要强引用存在，GC就<strong>永远不会回收</strong>被引用的对象。</li><li><strong>软引用</strong>：描述一些还<strong>有用但非必需</strong>的对象。对于软引用关联的对象，<strong>在内存足够的时候，软引用对象不会被回收</strong>，在系统要发生内存溢出异常之前，将会把这些对象放入回收范围内进行第二次回收。如果这次回收hi没有足够内存，抛出OOM异常。</li><li><strong>弱引用</strong>：也用来描述<strong>非必需</strong>的对象，但强度比软引用更弱，弱引用的对象只能<strong>存活到下一次GC发生之前</strong>，垃圾收集器工作时，无论内存是否足够，只被弱引用的对象都要被回收。</li><li><strong>虚引用</strong>：<strong>最弱</strong>的引用关系，一个对象是否有虚引用，完全不会影响其生存时间，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用的目的就是<strong>能在这个对象被回收时收到一个系统通知</strong>。</li></ul><h3 id="4-对象是否真的死亡"><a href="#4-对象是否真的死亡" class="headerlink" title="4 对象是否真的死亡"></a>4 对象是否真的死亡</h3><p>即使在可达性分析算法中不可达的对象，也<strong>不是非死不可</strong>，要真正宣告一个对象死亡，<strong>至少经过两次标记</strong>。</p><p>标记过程：如果没有从GC Roots到对象的引用链，就进行<strong>第一次标记</strong>，如果该对象<strong>覆盖</strong>了finalize()方法并且finalize()<strong>没被虚拟机执行</strong>过（满足这俩条件则有必要执行该对象的finalize方法），将该对象放在F-Queue队列中。稍后虚拟机<strong>启动一个线程</strong>触发队列中对象的finalize方法，随后GC将对F-Queue中的对象进行<strong>第二次标记</strong>，如果某对象在finalize方法里拯救了自己（即重新添加了引用），则不会标记该对象，并将其移除即将回收集合；否则，就要真的被回收了。</p><p><strong>注</strong>：finalize方法只能自动调用一次，也就是只能自救一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;判断对象是否可回收&quot;&gt;&lt;a href=&quot;#判断对象是否可回收&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否可回收&quot;&gt;&lt;/a&gt;判断对象是否可回收&lt;/h2&gt;&lt;h3 id=&quot;1-引用计数法&quot;&gt;&lt;a href=&quot;#1-引用计数法&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="https://jwkang99.github.io/posts/566ec62f.html"/>
    <id>https://jwkang99.github.io/posts/566ec62f.html</id>
    <published>2021-05-16T02:02:48.000Z</published>
    <updated>2021-06-20T15:16:05.569Z</updated>
    
    <content type="html"><![CDATA[<p>java运行时内存包括程序计数器、本地方法栈、虚拟机栈、java堆和方法区。</p><p><strong>程序计数器、本地方法栈、虚拟机栈</strong>是<strong>线程</strong>私有的，这三个区域随线程生灭，栈中的栈帧随方法进入退出而进行着出栈入栈的操作，每一个栈帧分配多少内存基本上是再类结构确定下来时就已知，因此这几个区域的内存分配和回收具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就回收了。</p><p><strong>Java堆和方法区</strong>不一样，是所有线程共享的区域，一个接口的多个实现类所需内存可能不一样，一个方法的多个分支需要的内存可能不一样只有程序在运行时才能知道会创建哪些对象，这部分内存分配和回收都是动态的，垃圾回收关注的也是这部分内存。</p><p>① <a href="./d51b6e9c.html">判断对象是否可回收</a></p><p>② 垃圾回收算法</p><p>③ <a href="./b38f68fb.html">垃圾收集器</a></p><p>④ 内存分配和回收策略</p><p><strong>方法区垃圾回收</strong>单独拿出来说：</p><p>方法区（HotSpot虚拟机中的永久代）的垃圾回收在JVM没做要求，因为在永久代中回收效率太低。</p><p>永久代主要回收两部分：废弃<strong>常量</strong>和无用的<strong>类</strong>。</p><p><strong>废弃常量回收</strong>和java堆中的回收类似，如果没有任何String类型对象引用常量池中的字符串<code>abc</code>，有必要的话会清理这个字符串常量。</p><p><strong>无用类</strong>回收需满足三个条件，但并不一定会被回收，有参数进行控制</p><p>① 该类所有实例都被回收<br>② 加载该类的ClassLoader已经被回收<br>③ 该类的Class对象没被引用，没有地方通过反射访问该类的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java运行时内存包括程序计数器、本地方法栈、虚拟机栈、java堆和方法区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序计数器、本地方法栈、虚拟机栈&lt;/strong&gt;是&lt;strong&gt;线程&lt;/strong&gt;私有的，这三个区域随线程生灭，栈中的栈帧随方法进入退出而进行着出栈入栈的操作
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收算法</title>
    <link href="https://jwkang99.github.io/posts/82902146.html"/>
    <id>https://jwkang99.github.io/posts/82902146.html</id>
    <published>2021-05-16T02:02:48.000Z</published>
    <updated>2021-06-20T15:17:49.899Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1 标记-清除算法"></a>1 标记-清除算法</h3><p>标记出需要回收的对象，完成标记后统一回收。效率不高，容易出产生碎片，会导致触发多次GC。</p><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2 复制算法"></a>2 复制算法</h3><p>把内存容量分为相同的两部分，每次只使用其中的一半，触发GC时将存活的对象放在另外一半上，再把另一半完全清理了，<strong>不会产生碎片</strong>，代价是<strong>缩小了可用内存</strong>。</p><p>因为<strong>新生代</strong>98%的对象朝生夕死，所以不需要1:1划分，而是分成一块较大的Eden区和两块大小相等的Survivor区，比例为8:1:1，只使用Eden和一块Survivor区采用复制算法，这样只有10%的内存被浪费了。当然也不能保证每次GC中存活的对象都不超过10%，所以就需要老年代的内存做<strong>分配担保</strong>，也就是老年代给新生代擦屁股。</p><p>复制算法在对象存活率较高时就需要进行<strong>较多复制操作</strong>，<strong>效率就会变低</strong>。而且复制算法需要额外内存进行担保，所以老年代不用复制算法。</p><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3 标记-整理算法"></a>3 标记-整理算法</h3><p>标记之后将存活的对象移到一端，然后直接清除掉边界之外的内存。</p><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4 分代收集算法"></a>4 分代收集算法</h3><p>根据存活周期不同，分代收集。<strong>新生代</strong>复制算法，<strong>老年代</strong>没有额外空间担保标记-清除或者标记-整理算法。</p><h3 id="5-HotSpot的上述算法实现"><a href="#5-HotSpot的上述算法实现" class="headerlink" title="5 HotSpot的上述算法实现"></a>5 HotSpot的上述算法实现</h3><h4 id="GC-Roots枚举"><a href="#GC-Roots枚举" class="headerlink" title="GC Roots枚举"></a>GC Roots枚举</h4><p>GC Roots主要在全局性的引用（常量和静态变量）和执行上下文（栈帧的本变量表）中，<strong>逐个检查必然会消耗很多时间</strong>。</p><p>可达性分析时必须在一个<strong>确保一致性的快照</strong>中进行，获取快照将导致<strong>用户线程暂停</strong>（Stop The World）。</p><p>HotSpot使用<strong>准确式GC</strong>，系统停顿之后不需要一个不漏的检查所有全局性引用和执行上下文，通过<strong>OopMap（还不太理解？）</strong>的数据结构直接得知哪些地方存着对象引用。在类加载完之后，就把对象内什么偏移量上是什么类型的数据计算出来。在JIT编译过程中，也会在特定位置记录栈和寄存器中哪些位置是引用。</p><p>因此GC在扫描时就可以快速准确的完成GC Roots枚举。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在看看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-标记-清除算法&quot;&gt;&lt;a href=&quot;#1-标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;1 标记-清除算法&quot;&gt;&lt;/a&gt;1 标记-清除算法&lt;/h3&gt;&lt;p&gt;标记出需要回收的对象，完成标记后统一回收。效率不高，容易出产生碎片，会导致触发多次G
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="https://jwkang99.github.io/posts/6d27f500.html"/>
    <id>https://jwkang99.github.io/posts/6d27f500.html</id>
    <published>2021-05-13T07:02:48.000Z</published>
    <updated>2021-06-04T13:38:07.348Z</updated>
    
    <content type="html"><![CDATA[<p>类加载机制：虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机可以直接使用的java类型。</p><p>类从被加载都虚拟机内存中开始，到写在出内存为止，整个生命周期包括：<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>、<strong>使用</strong>和<strong>卸载</strong>7个阶段。其中验证、准备、解析3个部分统称为<strong>连接</strong>。</p><p><a href="/posts/6d27f500/life.jpg" data-fancybox="group" data-caption="类的生命周期" class="fancybox"><img alt="类的生命周期" zoom="70%" title="类的生命周期" data-src="/posts/6d27f500/life.jpg" class="lazyload"></a></p><p>其中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的（开始的顺序确定，但是进行和完成可能是交叉进行的）。由于java的运行时绑定（动态绑定），<strong>解析</strong>可能会在某种情况下在<strong>初始化之后</strong>才开始。</p><p><strong>类加载的时机</strong></p><p><strong>有且仅有</strong>5种情况，必须立即对类进行<strong>初始化</strong>（加载、验证、准备当然也必须在这之前完成）</p><p>① 遇到new、getstatic、putstatic、或者invokestatic这4调字节码指令时，如果类没有进行初始化，则需要先触发初始化。这4条指令要么新建一个该类的<strong>实例</strong>，或者与<strong>静态操作</strong>相关，不难理解必需先初始化该类。不过被<strong>final修饰的静态字段</strong>除外，因为其已经自编译时被放入<strong>常量池</strong>。</p><p>② 在使用<code>java.lang.reflect</code>对类进行<strong>反射调用</strong>时，须先初始化。</p><p>③ 初始化一个类时，其父类还未初始化，须先初始化<strong>父类</strong>。（<strong>注</strong>：接口在此处不同真正用到时才会初始化父接口）</p><p>④ 虚拟机启动时，先初始化用户指定的执行<strong>主类</strong>。</p><p>⑤ 一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果中，<strong>方法句柄</strong>对应的类，须先初始化。（似乎是JDK1.7之后才有的）</p><p>以上5种统称为对类的<strong>主动引用</strong>，被动引用不会触发初始化。<br>被动例子：</p><ol><li><strong>子类使用父类的静态字段</strong>，跟子类没关系，故子类不会初始化。</li><li><strong>定义一个该类的数组</strong>Object[] arr，不会初始化该类，因为没有用到类，可以使用的只有a.length和a.clone()。</li><li><strong>final修饰的静态字段</strong>在编译阶段会存入<strong>调用类</strong>（注：不是该字段的所属类）的常量池，不会触发初始化。</li></ol><h3 id="一、加载"><a href="#一、加载" class="headerlink" title="一、加载"></a>一、加载</h3><p><strong>加载</strong>是<strong>类加载过程</strong>的一个阶段，该阶段虚拟机完成3件事：<br>① 通过类的全限定名<strong>获取类的二进制字节流</strong>。（<strong>where</strong>：从ZIP、JAR、网络、运行时计算中等等获取，<strong>how</strong>：系统提供的加载器或自定义加载器，<a href>这里</a>介绍类加载器）<br>② 将字节流所代表的静态存储结构<strong>转化</strong>为方法区的运行时数据结构。<br>③ 在内存中生成一个代表该类的java.lang.Class对象（虽是对象，但是存在方法区中），作为方法区该类的访问入口。<br>注：数组类由jvm直接创建，但数组类中的元素仍要靠加载器。</p><h3 id="二、验证"><a href="#二、验证" class="headerlink" title="二、验证"></a>二、验证</h3><p>连接阶段第一步，目的是确保class文件的字节流中所包含的信息符合虚拟机要求，并且不会危害虚拟机安全。</p><p>纯粹的java代码无法做到访问越界的数组元素、将一个对象转型为未实现类型、跳转到不存在的代码行等不安群行为，因为如果这些行为存在，编译器将拒绝将源码编译成class文件。<strong>但是</strong>，class文件不一定从源码编译过来，也可以直接编写class文件，所以验证还是很有<strong>必要</strong>的。（会抛出java.lang.VerifyError及其子类异常），可以通过<strong>-Xverify:none</strong>来关闭大部分类验证措施。</p><p>验证阶段完成<strong>4个阶段</strong>的检查动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h4 id="1-文件格式验证"><a href="#1-文件格式验证" class="headerlink" title="1.文件格式验证"></a>1.文件格式验证</h4><p>验证字节流是否符合Class文件<strong>格式</strong>的规范，主要目的是<strong>保证输入的字节流能正确的解析</strong>，并存储于<strong>方法区</strong>，<strong>格式上符合</strong>描述一个java类型的<strong>要求</strong>。</p><p>该阶段验证点包括但<strong>不限于</strong>以下几点：<br>①是否以<strong>魔数</strong>0xCAFEBABE开头。<br>②主、次<strong>版本号</strong>是否在当前虚拟机处理范围内。<br>③<strong>常量池</strong>中是否有不被支持的类型（检查常量tag标志）。<br>④ 指向<strong>常量的索引</strong>是否指向不存在的常量或者不符合类型常量。</p><h4 id="2-元数据验证"><a href="#2-元数据验证" class="headerlink" title="2.元数据验证"></a>2.元数据验证</h4><p>对类的元数据信息进行<strong>语义校验</strong>，保证描述的<strong>信息符合</strong>java类型的<strong>要求</strong>。</p><p>该阶段验证包括但<strong>不限于</strong>：<br>① 是否有<strong>父类</strong>（除Object都有父类）<br>② 其父类是否<strong>继承</strong>了不允许继承的类（final类）<br>③ 若该类不是抽象类，是否<strong>实现了父类或者接口中要求的所有方法</strong><br>④ 类中的字段、方法是否<strong>与父类冲突</strong>（final字段、或错误重载）</p><h4 id="3-字节码分析"><a href="#3-字节码分析" class="headerlink" title="3. 字节码分析"></a>3. 字节码分析</h4><p>通过数据流和控制流分析，确定<strong>程序语义</strong>合法、符合逻辑。在元数据信息验证完成后，该阶段会对<strong>类的方法体</strong>进行验证，保证类的方法在运行时不会危害虚拟机。</p><h4 id="4-符号引用验证"><a href="#4-符号引用验证" class="headerlink" title="4. 符号引用验证"></a>4. 符号引用验证</h4><p>这步验证发生在虚拟机<strong>将符号引用转化为直接引用</strong>的时候（该转化发生在<strong>解析阶段</strong>）。</p><p>符号引用验证可以看作是对<strong>类自身以外的信息</strong>进行匹配性校验（常量池中的各种符号引用），目的为确保解析动作的正常执行。</p><p>符号引用就是用一组符号里描述所引用的目标，只要能准确的定位到所引用的目标，任何形式字面量都可以。<br>理解：在编译的时候每个java类都被编译成了class文件，在编译的时候虚拟机并不知道所引用类的地址，就用符号表示，而这个发生在解析阶段的这个转化过程就是将这个<strong>符号表示转化成真正的地址</strong>。</p><p>通常需要校验下列内容<strong>但不限于</strong>：<br>① 符号引用中通过字符串描述的<strong>全限定名</strong>是否能找到对应的类<br>② 在指定类中是否存在符合方法的<strong>字段描述</strong>，以及简单名称所描述的方法和字段<br>③ 符号引用中的类、字段、方法的<strong>访问性</strong>（pirvate、protected、public、default）是否可以被当前类访问</p><h3 id="三、准备"><a href="#三、准备" class="headerlink" title="三、准备"></a>三、准备</h3><p>为<strong>类变量</strong>在<strong>方法区</strong>中分配内存并设置<strong>类变量</strong>的初始值（通常为数据类型的0值，而不是程序员指定的值），<strong>注</strong>：这里进行内存分配的变量仅包括类变量（static），而不是实例变量（实例变量随实例分配在java堆中）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span></span><br></pre></td></tr></table></figure></div><p><strong>通常情况下</strong>在准备阶段后value的初始值为0，不是123。给value赋值的putstatic指令编译后存放于<clinit()>中，在初始化阶段才会执行。</clinit()></p><p>也有例外，如果类字段的字段属性表中存在<strong>ConstantValue</strong>属性（即加上<strong>final</strong>关键字），在准备阶段就会被赋予表中的值作为初始值。</p><h3 id="四、解析"><a href="#四、解析" class="headerlink" title="四、解析"></a>四、解析</h3><p>解析阶段是将常量池内的<strong>符号引用替换为直接引用</strong>的过程。</p><p>符号引用：正如在验证阶段所说的那样，符号引用可以是<strong>任何形式的字面量</strong>，且引用的目标<strong>不一定已经加载到内存</strong>。字面量形式有明确定义，所以在各种虚拟机中符号引用必须<strong>一致</strong>。<br>直接引用：直接指向目标的指针、相对偏移量、或者能间接定位目标的句柄，且目标已经<strong>存在于内存</strong>中。同一符号引用在不同虚拟机中转化得到的直接引用<strong>一般不同</strong>。</p><p>为避免解析动作重复执行，虚拟机会对第一次解析的结果进行缓存（invokedynamic指令除外），第一次成功或异常，后续的都会收到同样的结果。</p><p>解析阶段中，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行解析。后3种需要动态语言支持，这里先概述前4种。</p><h4 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1.类或接口的解析"></a>1.类或接口的解析</h4><p>当前类D对类或接口C的符号引用为N，需要转换成直接引用，需要三个步骤：</p><p>① 若C<strong>不是数组类型</strong>，虚拟机会把代表N的<strong>全限定名</strong>传递给D的类加载器去加载类C。在加载过程中，元数据和字节码验证的要求，有可能会触发其他<strong>相关类的加载</strong>动作，例如加载这个类的父类或者实现接口。</p><p>② 若C是一个<strong>数组类型</strong>，并且数组元素类型为<strong>对象</strong>，也就是N的描述符为[java/lang/Integer]的形式，那将会按照①加载数组元素的类型，即去加载类java.lang.Integer，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</p><p>③ 若前两步没有异常，那么C在虚拟机中已经成为了一个有效的类或者接口了，但在解析完成之前需要进行符号引用验证，确认D是否具备对C的访问权限。若没权限，则抛出java.lang.IllegalAccessError异常。</p><h4 id="2-字段解析"><a href="#2-字段解析" class="headerlink" title="2.字段解析"></a>2.字段解析</h4><p>对于一个字段符号引用，首先会对字段所属的类或者接口的符号引用进行解析，解析成功后将这个字段所属的类或者接口用C表示。</p><h4 id="3-类方法解析"><a href="#3-类方法解析" class="headerlink" title="3. 类方法解析"></a>3. 类方法解析</h4><h4 id="4-接口方法解析"><a href="#4-接口方法解析" class="headerlink" title="4.接口方法解析"></a>4.接口方法解析</h4><h3 id="五、初始化"><a href="#五、初始化" class="headerlink" title="五、初始化"></a>五、初始化</h3><p>在初始化阶段才真正开始执行类中定义的java程序代码（或字节码）。</p><p>初始化阶段执行类构造器<strong><clinit()></clinit()></strong>方法的过程，<strong><clinit()></clinit()></strong>执行过程中的行为特点和细节如下：</p><p>① <strong><clinit()></clinit()></strong>是由编译器自动收集类中的所有变量的<strong>赋值动作</strong>和<strong>静态语句</strong>块中的语句合并而成。<strong>注</strong>：静态语句块只能访问在之前定义的变量，定在之后的变量只能赋值不能访问。</p><p>② <strong><clinit()></clinit()></strong>方法与类的构造函数不同，不需要显式的调用父类构造器，虚拟机会保证在子类的<strong><clinit()></clinit()></strong>之前，父类的<strong><clinit()></clinit()></strong>已经执行完成，因此虚拟机中第一个被执行的<strong><clinit()></clinit()></strong>方法是Object类。</p><p>③ 由于父类的<strong><clinit()></clinit()></strong>先执行，所以父类的静态语句优先于子类的变量复制操作。</p><p>④ <strong><clinit()></clinit()></strong>不必须，若没有变量的<strong>赋值动作</strong>和<strong>静态语句</strong>块，则不会生成<strong><clinit()></clinit()></strong>方法。</p><p>⑤ 接口中没有静态语句块，但仍然你可以有变量初始化的赋值操作，但不同的是执行接口的<strong><clinit()></clinit()></strong>方法前不需要限制性父接口的<strong><clinit()></clinit()></strong>方法，只有用到父接口中的变量是才会执行。</p><p>⑥ <strong><clinit()></clinit()></strong>会加锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类加载机制：虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机可以直接使用的java类型。&lt;/p&gt;
&lt;p&gt;类从被加载都虚拟机内存中开始，到写在出内存为止，整个生命周期包括：&lt;strong&gt;加载&lt;/strong&gt;、&lt;str
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>前缀和</title>
    <link href="https://jwkang99.github.io/posts/8628805.html"/>
    <id>https://jwkang99.github.io/posts/8628805.html</id>
    <published>2020-07-22T12:51:53.000Z</published>
    <updated>2020-07-22T13:55:42.153Z</updated>
    
    <content type="html"><![CDATA[<p>​        在计算某数据结构的中间部分的连续和的问题中，可以使用前缀和进行求解，例如<code>1-i</code>的前缀和与<code>1-j</code>的前缀和可以找出连续部分<code>i-j</code>的和，该方法同样使用与在树或者图结构中解决相应问题。</p><h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h4><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><p>示例 1 :</p><p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于此处让计算的子数组个数，所以在此存储每种前缀和的个数</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; prefixSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    prefixSum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        res += prefixSum.getOrDefault(sum-k,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(sum,prefixSum.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437.路径总和 III"></a>437.路径总和 III</h4><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></p><p><strong>分析</strong>：本题样可以使用前缀和进行计算。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储本路径上前缀和信息</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; prefixSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        prefixSum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        pathSumHelper(root,sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSumHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> curSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curSum += root.val;</span><br><span class="line">        count += prefixSum.getOrDefault(curSum-sum,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(curSum,prefixSum.getOrDefault(curSum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        pathSumHelper(root.left,sum,curSum);</span><br><span class="line">        pathSumHelper(root.right,sum,curSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curCount = prefixSum.getOrDefault(curSum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(curCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            prefixSum.put(curSum,curCount-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        curSum -= root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        在计算某数据结构的中间部分的连续和的问题中，可以使用前缀和进行求解，例如&lt;code&gt;1-i&lt;/code&gt;的前缀和与&lt;code&gt;1-j&lt;/code&gt;的前缀和可以找出连续部分&lt;code&gt;i-j&lt;/code&gt;的和，该方法同样使用与在树或者图结构中解决相应问题。&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://jwkang99.github.io/posts/111e02e0.html"/>
    <id>https://jwkang99.github.io/posts/111e02e0.html</id>
    <published>2020-07-22T03:20:15.000Z</published>
    <updated>2020-07-22T13:41:40.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><h4 id="防止指令重排"><a href="#防止指令重排" class="headerlink" title="防止指令重排"></a>防止指令重排</h4><p>在并发环境下，单例模式的实现方式最多的是使用Double Check的方式，代码如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile保证instance可见性，禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton_6 instance;</span><br><span class="line">    <span class="comment">//私有构造函数，禁止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//doube check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton_6<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton_6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在上述代码中，new Singleton_6()实例的构造对象可以分为三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ul><p>但是由于操作系统为了提高性能可以对指令进行重排序，所以这三个步骤的顺序可能会被打乱。</p><ul><li>分配内存空间</li><li>将内存空间的地址赋值给对应的引用</li><li>初始化对象</li></ul><p>如果是上述的流程，在多线程环境下，就有可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p><h4 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h4><p>可见性问题主要是指一个线程修改了共享变量值，但还没有写回到内存中，其他线程却看不到这个变化。如下图所示：</p><p><a href="/posts/111e02e0/volitale.png" data-fancybox="group" data-caption="image-20200301213039998" class="fancybox"><img alt="image-20200301213039998" title="image-20200301213039998" data-src="/posts/111e02e0/volitale.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 0;  &#x2F;&#x2F;初始状态a &#x3D; b &#x3D; 0，结果允许x &#x3D; y &#x3D; 0出现</span><br><span class="line">b &#x3D; 0;</span><br><span class="line">a &#x3D; 1;  &#x2F;&#x2F;线程A</span><br><span class="line">x &#x3D; b;  &#x2F;&#x2F;线程A</span><br><span class="line">b &#x3D; 2;  &#x2F;&#x2F;线程B</span><br><span class="line">y &#x3D; a;  &#x2F;&#x2F;线程B</span><br></pre></td></tr></table></figure></div><p>这里线程 A 和线程 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，<code>volatile</code>变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取<code>volatile</code>类型的变量时总会返回最新写入的值。</p><h4 id="保证原子性"><a href="#保证原子性" class="headerlink" title="保证原子性"></a>保证原子性</h4><p>volatile关键字所保证的原子性是单次读写的原子性。<code>i++</code>是可以分为读写读三个步骤，<code>volatile</code>不能保证<code>i++</code>是原子操作，要保证<code>i++</code>是原子操作，可以使用原子类或者<code>Synchronized</code>。</p><p>同时，因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</p><h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h3><h4 id="可见性实现"><a href="#可见性实现" class="headerlink" title="可见性实现"></a>可见性实现</h4><blockquote><p>volatile变量的内存可见性是基于内存屏障（Memory Barrier）实现的</p></blockquote><p>内存屏障是一个CPU指令。<br>在程序运行时，为了提高性能，编译器和处理器会对指令进行重排序，JMM为了保证在不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和CPU：不管什么指令都不能和这题奥Memory Barrier指令重排序。</p><p>如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sh</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  0x0000000002951563: and    <span class="variable">$0xffffffffffffff87</span>,%rdi</span><br><span class="line">  0x0000000002951567: je     0x00000000029515f8</span><br><span class="line">  0x000000000295156d: <span class="built_in">test</span>   <span class="variable">$0x7</span>,%rdi</span><br><span class="line">  0x0000000002951574: jne    0x00000000029515bd</span><br><span class="line">  0x0000000002951576: <span class="built_in">test</span>   <span class="variable">$0x300</span>,%rdi</span><br><span class="line">  0x000000000295157d: jne    0x000000000295159c</span><br><span class="line">  0x000000000295157f: and    <span class="variable">$0x37f</span>,%rax</span><br><span class="line">  0x0000000002951586: mov    %rax,%rdi</span><br><span class="line">  0x0000000002951589: or     %r15,%rdi</span><br><span class="line">  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br><span class="line">  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  </span><br><span class="line">  0x0000000002951591: jne    0x0000000002951a15</span><br><span class="line">  0x0000000002951597: jmpq   0x00000000029515f8</span><br><span class="line">  0x000000000295159c: mov    0x8(%rdx),%edi</span><br><span class="line">  0x000000000295159f: shl    <span class="variable">$0x3</span>,%rdi</span><br><span class="line">  0x00000000029515a3: mov    0xa8(%rdi),%rdi</span><br><span class="line">  0x00000000029515aa: or     %r15,%rdi</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p><p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>volatile 的 happens-before 关系</strong></p><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><p><strong>volatile 禁止重排序</strong></p><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM 会针对编译器制定 volatile 重排序规则表。</p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/111e02e0/java-thread-x-key-volatile-2.png" class="lazyload"></a></p><p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><p><a href="/posts/111e02e0/mb.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/111e02e0/mb.png" class="lazyload"></a></p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-3.png" data-fancybox="group" data-caption="volitale" class="fancybox"><img alt="volitale" style="zoom:67%;" title="volitale" data-src="/posts/111e02e0/java-thread-x-key-volatile-3.png" class="lazyload"></a></p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-4.png" data-fancybox="group" data-caption="volitale" class="fancybox"><img alt="volitale" style="zoom:67%;" title="volitale" data-src="/posts/111e02e0/java-thread-x-key-volatile-4.png" class="lazyload"></a></p><h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h3><ul><li>对变量的写操作不依赖于当前值。<ul><li>例如i++操作依赖于i本身</li></ul></li><li>该变量没有包含在具有其他变量的不变式中。<ul><li>由于不能保证原子性，vilatile变量不能保证不变式的成立。</li></ul></li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><p>参考<a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html" target="_blank" rel="noopener">pdai博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;h3 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合框架</title>
    <link href="https://jwkang99.github.io/posts/1e4a4153.html"/>
    <id>https://jwkang99.github.io/posts/1e4a4153.html</id>
    <published>2020-07-22T02:31:23.000Z</published>
    <updated>2021-04-19T06:28:42.031Z</updated>
    
    <content type="html"><![CDATA[<p><strong>下图为java集合框架的中各种类的关系图</strong></p><p><a href="/posts/1e4a4153/java_collections_overview.png" data-fancybox="group" data-caption="Java容器类关系概览" class="fancybox"><img alt="Java容器类关系概览" title="Java容器类关系概览" data-src="/posts/1e4a4153/java_collections_overview.png" class="lazyload"></a></p><p>Java容器中只能放对象，对于基本类型（int、long、float、double等），需要将其包装成对象类型后（Integer、Long、Float、Double等）才能放到容器里。</p><blockquote><p>总的来说，java容器可以分为两类，第一类存储对象的集合，直接或间接实现Collection接口。第二类存储着键值对，依赖于Map接口或者Dictionary抽象类（此类已过时）。</p></blockquote><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h3><p><strong>接口及抽象类概述</strong></p><p>AbstractSet抽象类<strong>继承</strong>AbstractCollection抽象类，<strong>实现</strong>Set接口。此类没有重写AbstractCollection中的任何实现，仅仅添加Set接口中的equals和hashCode的实现。</p><h4 id="①-HashSet"><a href="#①-HashSet" class="headerlink" title="① HashSet"></a>① HashSet</h4><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p><h4 id="②-LinkedHashSet"><a href="#②-LinkedHashSet" class="headerlink" title="② LinkedHashSet"></a>② LinkedHashSet</h4><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p><h4 id="③-TreeSet"><a href="#③-TreeSet" class="headerlink" title="③ TreeSet"></a>③ TreeSet</h4><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p><h3 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h3><p><strong>接口及抽象类概述</strong></p><p>Collection接口继承自Iterable接口。<br>List接口继承自Collection接口。<br>AbstractCollection抽象类实现了Collection接口（实现isEmpty等较通用的方法）。<br>AbstractList抽象类 继承自 AbstractCollection抽象类，实现List接口。<br>AbstractSequentialList抽象类 继承 自AbstractList抽象类，是List接口的简化版实现</p><h4 id="①-ArrayList"><a href="#①-ArrayList" class="headerlink" title="① ArrayList"></a>① ArrayList</h4><p>ArrayList<strong>继承</strong>AbstractList抽象类，<strong>实现</strong>List、RandomAccess、Cloneable、Serializable接口。ArrayList基于动态数组实现，支持随机访问。<a href="./ece885.html#一、ArrayList">源码分析</a></p><h4 id="②-Vector"><a href="#②-Vector" class="headerlink" title="② Vector"></a>② Vector</h4><p>Vector<strong>继承</strong>AbstractList抽象类，<strong>实现</strong>List、RandomAccess、Cloneable、Serializable接口。和 ArrayList 类似，但它是线程安全的（对容器操作的方法上都加了synchronized修饰）。<a href="./ece885.html#二、Vector">源码分析</a></p><h4 id="③-LinkedList"><a href="#③-LinkedList" class="headerlink" title="③ LinkedList"></a>③ LinkedList</h4><p>LinkedList<strong>继承</strong> AbstractSequentialList抽象类，<strong>实现</strong>List、Deque、Cloneable、Serializable接口。基于双向链表实现（既有prev也有next），只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。<a href="./ece885.html#四、LinkedList">源码分析</a></p><h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3.Queue"></a>3.Queue</h3><h4 id="①-LinkedList"><a href="#①-LinkedList" class="headerlink" title="① LinkedList"></a>① LinkedList</h4><p>可以用它来实现双向队列。</p><h4 id="②-PriorityQueue"><a href="#②-PriorityQueue" class="headerlink" title="② PriorityQueue"></a>② PriorityQueue</h4><p>基于堆结构实现，可以用它来实现优先队列。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="1-中间层抽象类和接口"><a href="#1-中间层抽象类和接口" class="headerlink" title="1.中间层抽象类和接口"></a>1.中间层抽象类和接口</h3><h4 id="①-AbstractMap抽象类"><a href="#①-AbstractMap抽象类" class="headerlink" title="① AbstractMap抽象类"></a>① AbstractMap抽象类</h4><p>在接口与实现类之间构建了一层抽象，其目的是为了复用一些比较通用的函数以及方便扩展，</p><p>AbstractMap 是<strong>继承</strong>于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码（例如返回Map.size方法，不必在每个实现类中去具体化）。</p><p>HashMap、TreeMap和WeakedHashMap均继承了AbstractMap。</p><h4 id="②-SortedMap接口"><a href="#②-SortedMap接口" class="headerlink" title="② SortedMap接口"></a>② SortedMap接口</h4><p>SortedMap是<strong>继承</strong>于Map的接口。SortedMap中的内容是<strong>排序的键值对</strong>，排序的方法是通过比较器(Comparator)，保持键值对有序的实现类，例如TreeMap，实现了该接口。</p><h4 id="③-NavigableMap接口"><a href="#③-NavigableMap接口" class="headerlink" title="③ NavigableMap接口"></a>③ NavigableMap接口</h4><p>NavigableMap<strong>继承</strong>SortedMap接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”、“获取键值在某范围的子Map”（higher和ceiling等前缀的方法）。</p><h3 id="2-实现类"><a href="#2-实现类" class="headerlink" title="2.实现类"></a>2.实现类</h3><h4 id="①-HashMap"><a href="#①-HashMap" class="headerlink" title="① HashMap"></a>① HashMap</h4><p>HashMap<strong>继承</strong>AbstractMap抽象类，<strong>实现</strong>Map接口。基于哈希表实现。</p><h4 id="②-HashTable"><a href="#②-HashTable" class="headerlink" title="② HashTable"></a>② HashTable</h4><p>HashTable<strong>继承</strong>自Dictionary抽象类，<strong>实现</strong>Map接口。<br>和 HashMap 类似，但它是线程安全的（在所有方法都是加了synchronized关键字），这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p><h4 id="③-LinkedHashMap"><a href="#③-LinkedHashMap" class="headerlink" title="③ LinkedHashMap"></a>③ LinkedHashMap</h4><p>LinkedHashMap<strong>继承</strong>HashMap，<strong>实现</strong>Map接口。在原HashMap的基础上，改造每个Node（加了before和after），使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p><h4 id="④-TreeMap"><a href="#④-TreeMap" class="headerlink" title="④ TreeMap"></a>④ TreeMap</h4><p>TreeMap<strong>继承</strong>AbstractMap抽象类，<strong>实现</strong>NavigableMap接口。TreeMap存储的是有序键值对。基于红黑树实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;下图为java集合框架的中各种类的关系图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/posts/1e4a4153/java_collections_overview.png&quot; data-fancybox=&quot;group&quot; data-caption=&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="容器" scheme="https://jwkang99.github.io/categories/java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>312.戳气球</title>
    <link href="https://jwkang99.github.io/posts/88135758.html"/>
    <id>https://jwkang99.github.io/posts/88135758.html</id>
    <published>2020-07-19T02:00:00.000Z</published>
    <updated>2020-07-22T13:56:08.931Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组&nbsp;<code>nums</code>&nbsp;中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code> ，就可以获得&nbsp;<code>nums[left] * nums[i] * nums[right]</code>&nbsp;个硬币。&nbsp;这里的&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;代表和&nbsp;<code>i</code>&nbsp;相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球&nbsp;<code>left</code>&nbsp;和气球&nbsp;<code>right</code>&nbsp;就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>说明:</strong></p><ul>    <li>你可以假设&nbsp;<code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>    <li>0 &le; <code>n</code> &le; 500, 0 &le; <code>nums[i]</code> &le; 100</li></ul><p><strong>示例:</strong></p><pre><strong>输入:</strong>[3,1,5,8]<strong>输出:</strong> 167 <strong>解释: </strong>nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []&nbsp;    coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><h5 id="方法一：区间动态规划"><a href="#方法一：区间动态规划" class="headerlink" title="方法一：区间动态规划"></a>方法一：区间动态规划</h5><p>​        之前做过一下区间动态规划得题目，例如回文串可以使用<code>dp[i][j]</code>表示区间<code>[i,j]</code>内得子串是否为回文串。类似得想法可以应用到本题中。</p><p>​        用二维数组<code>dp[i][j]</code>表示戳破区间<code>[i,j]</code>内的气球所得到的最大分数。但是要计算<code>dp[i][j]</code>依赖于区间内戳破气球的顺序，所以在区间内逐一戳破气球去最大值。</p><p>​        为了方便计算，减少不必要的判断，将原数组进行扩展，在两端加上值为<code>1</code>的元素，相当于有效数组的下标从<code>1</code>开始。二维数组<code>dp[i][j]</code>表示戳破下标在<code>[i,j]</code>内的气球所得到的硬币数。</p><p>​        <code>dp[i][j]</code>的计算可以根据区间<code>[i,j]</code>内的取值<code>k</code>为三部分：</p><ul><li>戳破<code>[i,k-1]</code>气球所得到的硬币数<code>dp[i][k-1]</code></li><li>戳破<code>k</code>气球所得到的硬币数</li><li>戳破<code>[k+1,j]</code>气球所得到的硬币数<code>dp[k+1][j]</code></li></ul><p>​       关键在于戳破<code>k</code>的时机，如果最先或者在中间戳破<code>k</code>则<code>dp[i][k-1]</code>和<code>dp[k+1][j]</code>则需重新计算，<code>dp</code>数组的有效性就出现了问题，因为之前计算的<code>dp[i][k-1]</code>是在左边的<code>k</code>仍存在的情况下得到的。因为这两者的值受<code>nums[k]</code>的影响，故而把戳破<code>k</code>的时机放在最后，仅重新计算戳破k得到的硬币即可。可得状态转移方程如下：</p><script type="math/tex; mode=display">dp[i][j] = dp[i][k-1] + dp[k+1][j] + coin(k)\\coin(k) = nums[i-1] * nums[k] * numx[j+1]</script><p>​        其中，<code>coin(k)</code>为重新计算戳破k得到的硬币数，即两边相邻部分都先被戳破的情况下，<code>coin(k)</code>依赖于<code>i-1</code>和<code>j+1</code>。注意：此处不能使用<code>dp[k][k]</code>，因为<code>dp[k][k]</code>表示的是完整数组的情况下戳破k得到的硬币数。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//区间动态规划</span></span><br><span class="line">    <span class="keyword">if</span> ( nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">    helper[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    helper[len+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//扩展原数组，在两端加1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        helper[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i][j] 表示在戳破[i,j]所有气球能获得得最多硬币数  </span></span><br><span class="line">    <span class="comment">//初始化为len+2*len+2方便下边计算，保证不会越界，减少判断</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>][len+<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//此处需要从尾部开始计算，因为状态dp[i][j]与左边和下边的状态有关</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;=len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                <span class="comment">//此处表示最后把区间内的k戳破所得到得硬币</span></span><br><span class="line">                <span class="keyword">int</span> kCoin = dp[i][k-<span class="number">1</span>] + dp[k+<span class="number">1</span>][j] + helper[i-<span class="number">1</span>]*helper[k]*helper[j+<span class="number">1</span>];</span><br><span class="line">                dp[i][j] = Math.max(kCoin,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法二：回溯记忆化搜索"><a href="#方法二：回溯记忆化搜索" class="headerlink" title="方法二：回溯记忆化搜索"></a>方法二：回溯记忆化搜索</h5><p>​        基本思路和上边的动态规划基本一致，只不过采用回溯的方式，当时会有大量的重复计算，所以需要将之前计算的结果存储下来。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] helper;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//区间动态规划</span></span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        helper = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">         dp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>][len+<span class="number">2</span>];</span><br><span class="line">        helper[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        helper[len+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            helper[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(<span class="number">1</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[left][right]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="comment">//此处表示最后把区间内的k戳破所得到得硬币</span></span><br><span class="line">            <span class="keyword">int</span> kCoin = search(left,k-<span class="number">1</span>)+ search(k+<span class="number">1</span>,right) + helper[left-<span class="number">1</span>]*helper[k]*helper[right+<span class="number">1</span>];</span><br><span class="line">            dp[left][right] = Math.max(kCoin,dp[left][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个气球，编号为&lt;code&gt;0&lt;/code&gt; 到 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>785.判断二分图</title>
    <link href="https://jwkang99.github.io/posts/dc82b054.html"/>
    <id>https://jwkang99.github.io/posts/dc82b054.html</id>
    <published>2020-07-16T02:02:48.000Z</published>
    <updated>2020-07-19T04:57:01.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点<code>i</code>相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边：&nbsp;<code>graph[i]</code>&nbsp;中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p><p>示例 1:</p><blockquote><p>输入:[[1,3], [0,2], [1,3], [0,2]]<br>输出:true<br>解释:<br>无向图如下:<br>0——1<br>|    |<br>|    |<br>3——2<br>我们可以将节点分成两组: {0, 2} 和 {1, 3}。</p></blockquote><p>示例 2</p><blockquote><p>输入:[[1,2,3], [0,2], [0,1,3], [0,2]]<br>输出:false<br>解释:<br>无向图如下:<br>0——1<br>| \  |<br>|  \ |<br>3——2<br>我们不能将节点分割成两个独立的子集。</p></blockquote><p><strong>注意:</strong></p><ul>   <li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li>   <li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li>   <li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li>   <li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li></ul><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><p>​    显而易见该题需要搜索整个数组，进行判断是否存在两个相邻的节点属于同一类别。可以使用各种搜索算法给每个节点赋予标记表示其所属类别，也可以使用并查集进行解决。</p><h5 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h5><p>​    用一个<code>state</code>数组，对每个节点进行标记，其中</p><ul><li>-1表示该节点还未被访问</li><li>0表示该节点归为0类</li><li>1表示该节点归为1类</li></ul><p><strong>算法步骤：</strong></p><p>​    从任意一个未访问的节点开始，采用深度优先遍历，对每次遍历到的节点进行分类：</p><ul><li>若该节点未被访问，则根据该节点的源节点的标记更新标记。若上一节点标记为0，则当前节点标记为1，否则为0。</li><li>若该节点被访问过，即<code>state[cur]!=-1</code><ul><li>若<code>state[cur]</code>与上一节点的标记一致，则说明该图不符合二部图规则。</li><li>若不一致继续递归即可。</li></ul></li></ul><p>事件复杂度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isTrue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(state,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(state[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//每次在此处进入dfs，必定为一个新的连通子图</span></span><br><span class="line">                <span class="comment">//与上一此在此处调用dfs的节点之间不存在边</span></span><br><span class="line">                <span class="comment">//所以可以放心的把前一节点的分类标记置为0</span></span><br><span class="line">                dfsHelper(graph,state,i,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isTrue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dfs函数用于判断当前节cur属于哪一类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 表示节点状态的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preFlag 前一节点的状态，必为0或1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] state,<span class="keyword">int</span> cur,<span class="keyword">int</span> preFlag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果已经存在两个相邻节点属于同一类，则停止递归</span></span><br><span class="line">        <span class="keyword">if</span>(!isTrue)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若该节点没有被访问</span></span><br><span class="line">        <span class="keyword">if</span>(state[cur] == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//则根据前一节点的状态值更新当前状态</span></span><br><span class="line">            <span class="comment">//若上一节点标记为0，则当前节点标记为1</span></span><br><span class="line">            <span class="comment">//若上一节点标记为1，则当前节点标记为0</span></span><br><span class="line">            state[cur] = <span class="number">1</span> - preFlag;</span><br><span class="line">            <span class="comment">//与cur节点相连的点集合</span></span><br><span class="line">            <span class="keyword">int</span>[] nears = graph[cur];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nears.length;i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = graph[cur][i];</span><br><span class="line">                <span class="comment">//逐一访问与cur节点相邻的节点，并初始化state值</span></span><br><span class="line">                dfsHelper(graph, state, next, <span class="number">1</span> - preFlag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state[cur] == preFlag)&#123;</span><br><span class="line">            <span class="comment">//若该节点已经被访问过，即已赋予状态值</span></span><br><span class="line">            <span class="comment">//且与前一相邻节点状态一致则违反二部图规则</span></span><br><span class="line">            isTrue = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法二：BFS"><a href="#方法二：BFS" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h5><p>​    用一个<code>state</code>数组，对每个节点进行标记，其中</p><ul><li>-1表示该节点还未被访问</li><li>0表示该节点归为0类</li><li>1表示该节点归为1类</li></ul><p><strong>算法步骤：</strong></p><ul><li>对每一个连通域的起始节点赋予分类标记<code>0</code>，然后入队</li><li>出队节点<code>cur</code>，对于广度优先遍历到该节点的每一相邻节点<ul><li>如果未被访问过，则标记该节点为<code>1-state[cur]</code>，然后入队该节点</li><li>若访问过，则对比是否跟<code>cur</code>是同一类，若是则返回<code>false</code>，否则继续循环</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    Arrays.fill(state,-<span class="number">1</span>);</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[i] == -<span class="number">1</span>)&#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">            state[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> curFlag = state[cur];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[cur]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(state[next] == curFlag)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(state[next] == -<span class="number">1</span>)&#123;</span><br><span class="line">                        state[next] = <span class="number">1</span> - curFlag;</span><br><span class="line">                        queue.offer(next);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法二：并查集"><a href="#方法二：并查集" class="headerlink" title="方法二：并查集"></a>方法二：并查集</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        UnionSet unionSet = <span class="keyword">new</span> UnionSet(graph.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] neighbors = graph[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(unionSet.inOneSet(i,neighbor))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                unionSet.union(neighbors[<span class="number">0</span>],neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] roots;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            roots = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                roots[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(roots[p] == p)&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若p不是根，更新root[p]的值</span></span><br><span class="line">            roots[p] = findRoot(roots[p]);</span><br><span class="line">            <span class="keyword">return</span> roots[p];</span><br><span class="line">            <span class="comment">//也可每次查找都一级一级往上找根</span></span><br><span class="line">            <span class="keyword">return</span> findRoot(roots[p]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inOneSet</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findRoot(p) == findRoot(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">            roots[findRoot(q)] = roots[findRoot(p)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：&lt;/h4&gt;&lt;p&gt;给定一个无向图&lt;code&gt;graph&lt;/code&gt;，当这个图为二分图时返回&lt;cod
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>315.计算右侧小于当前元素的个数</title>
    <link href="https://jwkang99.github.io/posts/cabc759b.html"/>
    <id>https://jwkang99.github.io/posts/cabc759b.html</id>
    <published>2020-07-10T16:00:00.000Z</published>
    <updated>2020-07-19T04:57:57.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315.计算右侧小于当前元素的个数"></a>315.计算右侧小于当前元素的个数</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个整数数组 <em>nums</em>，按要求返回一个新数组&nbsp;<em>counts</em>。数组 <em>counts</em> 有该性质： <code>counts[i]</code> 的值是&nbsp; <code>nums[i]</code> 右侧小于&nbsp;<code>nums[i]</code> 的元素的数量。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> [5,2,6,1]<strong>输出:</strong> [2,1,1,0] <strong>解释:</strong>5 的右侧有 <strong>2 </strong>个更小的元素 (2 和 1).2 的右侧仅有 <strong>1 </strong>个更小的元素 (1).6 的右侧有 <strong>1 </strong>个更小的元素 (1).1 的右侧有 <strong>0 </strong>个更小的元素.</pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><h5 id="方法一：归并排序-索引数组"><a href="#方法一：归并排序-索引数组" class="headerlink" title="方法一：归并排序+索引数组"></a>方法一：归并排序+索引数组</h5><p>该题和计算逆序数个方法类似，利用归并排序可以快速统计出两段有序数组中的逆序数。由于题目中要求我们要具体计算到元素级别。“归并排序” 完成以后，原始数组的位置就已经变化了，因此可以使用索引数组定位元素是关键。<strong>“原始数组” 不变，用于比较两个元素的大小，真正位置变换的是 “索引数组”</strong>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] counts;</span><br><span class="line">    <span class="comment">//存储下标</span></span><br><span class="line">    <span class="keyword">int</span>[] indices;</span><br><span class="line">    <span class="comment">//归并排序辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] temp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        counts = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        indices = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">///存储数组下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            indices[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        merge(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : counts)&#123;</span><br><span class="line">            res.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并降序排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        merge(nums,left,mid);</span><br><span class="line">        merge(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        mergeSort(nums,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            temp[i] = indices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left , j = mid + <span class="number">1</span>, k = left;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[temp[i]] &gt; nums[temp[j]])&#123;</span><br><span class="line">                <span class="comment">//[9,6,5 | 4,1,0]</span></span><br><span class="line">                <span class="comment">// i       j</span></span><br><span class="line">                <span class="comment">//i和j构成逆序，则j之后也为逆序，直接相加</span></span><br><span class="line">                counts[temp[i]] += (right - j + <span class="number">1</span>);</span><br><span class="line">                indices[k++] = temp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                indices[k++] = temp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            indices[k++] = temp[i++];;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">            indices[k++] = temp[j++];;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法二：树状数组"><a href="#方法二：树状数组" class="headerlink" title="方法二：树状数组"></a>方法二：树状数组</h5><p>需要学习一下再来补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;315-计算右侧小于当前元素的个数&quot;&gt;&lt;a href=&quot;#315-计算右侧小于当前元素的个数&quot; class=&quot;headerlink&quot; title=&quot;315.计算右侧小于当前元素的个数&quot;&gt;&lt;/a&gt;315.计算右侧小于当前元素的个数&lt;/h2&gt;&lt;h4 id=&quot;题目描述：
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://jwkang99.github.io/posts/52ba89f4.html"/>
    <id>https://jwkang99.github.io/posts/52ba89f4.html</id>
    <published>2020-07-10T09:10:36.725Z</published>
    <updated>2020-03-06T13:29:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>﻿#  1. IOC（控制反转，Inversion of Control）</p><p>IOC：把创建对象的权力交给框架，是框架的重要特征，包括依赖注入和依赖查找。可降低类之间的耦合度。如果自己写代码，可以简单地通过工厂创建对象，若为单例可以将在初始化工厂时将对象放入容器中，再根据类名取单例对象。<br>之前一个类内部需要创建另外一个类的对象时，自己在类内部通过new或者反射的方式创建一个对象，直通通过工厂或者框架创建，我理解的这就是控制反转吧。</p><h1 id="2-使用Spring的ioc解决程序耦合问题"><a href="#2-使用Spring的ioc解决程序耦合问题" class="headerlink" title="2. 使用Spring的ioc解决程序耦合问题"></a>2. 使用Spring的ioc解决程序耦合问题</h1><p>把对象的创建交给spring管理<br>获取spring的IOC核心容器，并根据id获取对象<br>例：通过ApplicationContext获取核心容器。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XmlName为配置文件的名称，如Bean.xml</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(XmlName);</span><br><span class="line"><span class="comment">//BeanName为xml文件中配置的类的名称</span></span><br><span class="line">Object ocj = ac.getBean(BeanName);</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="Service" class="com.service.impl.ServiceImpl"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><h2 id="2-1-ApplicationContext的三个常用实现类"><a href="#2-1-ApplicationContext的三个常用实现类" class="headerlink" title="2.1 ApplicationContext的三个常用实现类"></a>2.1 ApplicationContext的三个常用实现类</h2><ol><li>ClassPathXmlApplicationContext:<br>加载类路径下的配置文件，要求配置文件必须在类路径下。</li><li>FileSystemApplicationContext:<br>加载磁盘任意路径下的配置文件(必须有访问权限)</li><li>AnnotationConfigApplicationContext:<br>用于读取注解创建文件<h2 id="2-2-创建核心容器的两个接口的不同"><a href="#2-2-创建核心容器的两个接口的不同" class="headerlink" title="2.2 创建核心容器的两个接口的不同"></a>2.2 创建核心容器的两个接口的不同</h2>创建容器有两个接口：ApplicationContext和BeanFactory，其中BeanFactory是ApplicationContext的子接口。</li></ol><p>ApplicationContext：<br>适用于<strong>单例对象</strong>。ApplicationContext在创建核心容器时，创建对象采取的策略是立即加载的方式，即只要读取完配置文件，马上通过反射的方式创建配置文件中的对象，并加入到核心容器中。因其是底层接口，更多的采用此接口定义容器对象。<br>在上例代码中，可以在ServiceImpl的默认构造函数中输出一句话，在读取配置文件的那一行打断点，即可发现在配置文件读取完毕后，配置文件中相应的对象都已经加载完毕。</p><p>BeanFactory:<br>适用于<strong>多例对象</strong>。BeanFactory在创建核心容器时，创建对象采取的策略是延时加载的方式，运行到根据id查找对象时，即如下代码，才真正的创建对象并把对象方入容器。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object ocj = ac.getBean(BeanName);</span><br></pre></td></tr></table></figure></div><h2 id="2-3-Spring对Bean的管理细节"><a href="#2-3-Spring对Bean的管理细节" class="headerlink" title="2.3 Spring对Bean的管理细节"></a>2.3 Spring对Bean的管理细节</h2><p>(1).创建Bean的三种方式<br>①  使用默认构造函数创建：在spring配置文件中使用bean标签，配以id和class(全限定类名)属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象。若没有默认构造函数则对象无法创建。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数创建对象xml文件示例</span></span><br><span class="line">&lt;bean id="Service" class="com.service.impl.ServiceImpl"&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id="Dao" class="com.dao.impl.DaoImpl"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div></p><p>② 使用普通工厂类中的方法创建对象，即使用某个类(工厂类)中的方法创建对象，并存入spring容器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个普通工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>factory-bean用于指定创建该对象的工厂类id，factory-method用于指定创建该bean对象的方法。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--xml配置文件中的实现如下--&gt;</span><br><span class="line">&lt;bean id="instanceFactory" class="com.factory.InstanceFactory"&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id="Service" factory-bean="instanceFactory" factory-method="getService"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div></p><p>③使用静态工厂中的静态方法创建对象(使用某个类中的静态方法创建对象并存入spring)<br>静态工厂类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>配置文件：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="Service" class="com.factory.StaticFactory" factory-method="getService"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><br>(2).bean的作用范围调整<br>spring创建的对象默认就是单例的，通过bean中的scope属性调整<br><strong>scope</strong>：</p><ol><li>singleton单例</li><li>prototype多例</li><li>request：作用于web应用的请求范围</li><li>session：作用于web应用的会话范围</li><li>global-session：作用于集群环境的会话范围(全局会话范围)，当不是集群环境是，它就是session</li></ol><p>(3).bean对象的生命周期<br>单例对象<br>    出生：当容器创建时对象出生，即之前的ApplicationContext<br>    活着：只要容器还在，对象一致活着<br>    死亡：容器销毁，对象消亡<br>多例对象<br>出生：当使用对象时spring框架为我们创建，即之前说的BeanFactory<br>    活着：对象只要在使用过程中就一致活着<br>    死亡：当对象长时间不用，且没有别的对象引用时，有java的GC回收<br>    可在标签中指定初始方法init-method和销毁方法destroy观察</p><p>(4).spring中的依赖注入<br>依赖注入：Dependency Injection<br>IOC作用：降低程序间的耦合(依赖关系)<br>依赖关系的管理：以后都交给了Spring来维护，在当前类需要用到其他类的对象时，由spring为我们提供，我们只需要在配置文件中说明<br>依赖关系的维护就称之为依赖注入</p><p>依赖注入<br>能注入的数据，有三类<br>①    基本数据类型和String<br>②    其他bean类型(在配置文件中或者注解配置过的bean)<br>③    复杂类型/集合类型</p><p>注入的方式，有三种<br>①    使用构造函数提供<br>在bean标签内部使用constructor-arg标签，标签中的属性<br><em>type</em>：用于指定要注入的数据类型，该数据类型也是构造函数中某个或某些参数的类型<br><em>index</em>：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，从0开始<br><em>name</em>：用于指定给构造函数中指定名称的参数赋值  ，常用<br>以上三个用于指定构造函数中哪个参数赋值<br><em>value</em>：用于提供基本类型和String类型数据<br>ref：用于提供其他bean类型，如下指的就是在spring的ioc核心容器中出现过的bean对象date</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"Service"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.ServiceImpl"</span>&gt;</span><br><span class="line">    &lt;constructor-arg name="name" value="kang"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name="age" value="19"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>注：对应类中必须有对应的有相同参数的构造方法</p><p>构造函数注入方式分析：<br>    <em>优势</em>：在获取bean对象时，注入数据时必须的操作，否则对象无法创建成功，如果某些类只想提供某些参数创建对象时比其他方式更简单。<br>    <em>弊端</em>：改变了bean对象的实例化方式，即使用不到这些数据也必须提供<br>②    使用set方法提供 更常用<br>在bean标签内部使用property标签，标签中的属性有：<br>name:用于指定注入时所调用的set方法名称<br>value:用于提供基本类型和String类型数据<br>ref:用于提供其他bean类型，指的就是在spring的ioc核心容器中出现过的bean对象<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"Service"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.ServiceImpl"</span>&gt;</span><br><span class="line"><span class="comment">//对应实体类中必须有相应属性的set方法</span></span><br><span class="line">   &lt;property name="name" value="kang"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="age" value="19"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div></p><p>set方法<br>优势：创建对象没有明确限制，可以直接使用默认构造函数<br>弊端：如果有某个成员必须有值，无法保证一定注入，有可能没有set方法，则获取对象是有可能set方法没有执行</p><p><strong>当类中有集合类型的属性时</strong>，set方法注入时结构相同标签可以互换<br>总体上分为两种标签<br>map类标签：map和property<br>array类标签：array、list和set</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"accountService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.AccountServiceImpl"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myStr"</span> &gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myList"</span> &gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myMap"</span> &gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"1"</span>&gt;</span><br><span class="line">                &lt;value&gt;aa&lt;/value&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">            &lt;entry key="2" value="bb"&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myProps"</span>&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key="3"&gt;cc&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>③    使用注解提供<br>注：如果是经常变化的数据，并不使用于注入的方式，因为单例只有一个对象，属性永远不能变。</p><h2 id="3-基于注解的IOC配置"><a href="#3-基于注解的IOC配置" class="headerlink" title="3 基于注解的IOC配置"></a>3 基于注解的IOC配置</h2><p>以下为用xml配置文件实现的创建bean对象的基本方式<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"Service"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.ServiceImpl"</span> scope=<span class="string">"singleton"</span> init-method=<span class="string">""</span> destroy-method=<span class="string">""</span>&gt;</span><br><span class="line"><span class="comment">//对应实体类中必须有相应属性的set方法</span></span><br><span class="line">   &lt;property name="name" value="kang"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="age" value="19"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><br>spring中作用于bean对象的各个注解对应于上边xml中各个部分实现的功能大体一致。要想通过使用注解的方式创建对象，就要修改xml配置文件中的相关配置。告知spring在创建容器时要扫描context名称空间和约束，而不是去扫描配置文件中的bean标签。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"GBK"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在bean的约束中，而在一个名称为context名称空间和约束中--&gt;</span><br><span class="line">     &lt;!--会扫描所有位于com包下的类和接口上的注解--&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></div><br>用注解的方式创建bean对象中的相关注解大概有这么几类</p><ol><li>用于创建对象的：作用就和在xml配置文件中的bean标签一样<br> @Component(value=name)<br> 作用：放在加载类定义的前一行，用于把当前类对象存入spring容器中。<br> 属性：value用于指定bean的id。可省略，默认值时当前类名，且首字母改小写。<br> 以下三个注解的作用和属性与@Component基本一致<br> 这三个注解分别时spring框架为我们提供明确的三层使用的注解，是我们的三层对象更加清晰。<br> @Controller：一般用于表现层<br> @Service：一般用于业务层<br> @Repository：一般用于持久层</li></ol><p>下面代码将类型为DaoImpl 的对象放入到Spring的ioc核心容器中，其中key为注解中的值Dao，value为DaoImpl类型的对象，下边两个类都可以看做时IDao类型<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl1</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl2</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div></p><ol><li><p>用于注入数据的：作用就和在xml配置文件中的bean标签中写一个property标签时一样的<br> @Autowired<br> 作用：自动按照类型注入。只要容器(key,value)中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。如果ioc容器中没有和要注入变量类型一致的对象时，则报错。如果ioc容器中有多个类型匹配时，首先按照类型(value)找出匹配的对象，然后再按照变量名称(key)查找一致的对象<br> 位置：可在方法上，也可在变量上。<br> 细节：在使用注解注入时，set方法就不是必要的了。</p><p> 如下面代码，在ioc核心容器执行了getBean(“Service”)时，当执行有关dao属性的方法时，就会自动的从容器中寻找IDao类型的对象，若容器中只有一个直接注入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"Service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><p>@Qualifier<br>    作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用，但是在给方法参数注入时可以。<br>    属性：value，用于指定bean的注入的id<br>    注：不能独立使用，只能和@Autowired配合使用<br>    下例中中，ioc容器中有两个IDao类型的对象，用Qualifier注解指定属性自动注入的Bean的id<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"Service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"Dao1"</span>)</span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl1</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl2</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div><br>@Resource<br>作用：直接按照bean的id(key)注入<br>属性：name，用于指定bean的id</p><p><strong>注意：</strong>@Autowired、@Qulifier和@Resource三个注解只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现。</p><p>@Value<br>作用：用于注入基本类型和String类型的数据<br>属性：用于指定数据的值。可以使用spring中的SpEL（Spring中的el表达式）<br>           SpEL写法：${表达式}</p><ol><li><p>用于改变作用范围的：作用和在bean标签中的scope属性是一样的<br> @Scope<br> 作用：用于指定bean的作用范围<br> 属性：value，指定取值范围。常用取值：singleton和prototype，默认为singleton</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上边默认的情况下，为单例，as和as2指向的同一个对象</span></span><br><span class="line">IService as = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">IService as2 = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">System.out.println(as==as2);  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//若改为以下代码</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Service"</span>)</span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"Dao1"</span>)</span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line">&#125;</span><br><span class="line">IService as = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">IService as2 = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">System.out.println(as==as2);  <span class="comment">//false,但as和as2中的dao仍为一个对象</span></span><br></pre></td></tr></table></figure></div></li><li><p>和生命周期相关：和bean标签中init-method和destroy-method一样<br> @ProDestroy<br> 作用：用于指定销毁方法，单例对象随容器关闭销毁，容器不负责多例对象，由GC回收<br> @PostConstruct<br> 作用：用于指定初始化方法</p></li><li><p>在使用注解创建和注入自定义的类时比较方便，由于所导入的jar包无法在其类头部加上@Service的注解，并且需要指定创建ioc容器时需要扫描的包，故只能在xml文件中定义bean标签将其放入ioc容器中。为了进一步实现没有xml的基于注解的ioc配置，引入一个新的注解<br> @Configuration<br> 作用：指定当前类是一个配置类</p><p> @ComponentScan(value=packageName)<br> 作用：用于通过注解指定spring在创建容器时要扫描的包<br> 属性：value和basePackages的作用一样<br> 注意：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。<br> 使用此注解作用相当于xml中context:component-scan标签</p><p> @Bean<br> 作用：用于吧当前方法的返回值作为bean对象存入spring的ioc容器中<br> 属性：用于指定bean的id，默认值为当前方法的名称<br> 注意：当用注解配置方法时，如果方法有参数，spring框架回去容器中查找有没有可用的bean对象，查找方式和Autowired一样。</p><p> @Import<br> 作用：用于导入其他的配置类<br> 属性：value用于指定其他配置类的字节码<br> 注意：当我们使用Import注解之后，有Import注解的为父配置类，而导入的都是子配置类</p><p> @PropertySource<br> 作用：用于指定properties文件的位置<br> 属性：value用于指定文件的名称和路径<br> 关键字：classpath表示类路径下</p></li></ol><p>思考：Spring为什么要整合junit，怎么整合。</p><h1 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3.AOP"></a>3.AOP</h1><blockquote><p>AOP(Aspect Oriented Programming)：面向切面编程<br>通过预编译的方式和运行期静态代理实现程序功能的统一维护的一种技术.AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>                     —摘自百度百科                            </p></blockquote><p>简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用倒台代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。<br>优势：减少重复代码，提高开发效率，维护方便<br>Spring中的AOP通过配置的方式实现动态代理。</p><h2 id="3-1-AOP相关术语："><a href="#3-1-AOP相关术语：" class="headerlink" title="3.1 AOP相关术语："></a>3.1 AOP相关术语：</h2><p><strong>Joinpoint</strong>：连接点，是指那些被拦截到的点。在Spring中，这些点只支持方法。<br><strong>Pointcut</strong>：切入点，只的是我们要对那些Joinpoint进行拦截的定义。所有的切入点都是连接点，只有被增强的连接点才是切入点。<br><strong>Advice</strong>：通知/增强，是指拦截到Joinpoint之后所要做的事情。通知的类型有：前置通知，后置通知，异常通知，最终通知和环绕通知。<br><strong>Introducetion</strong>：引介，是一种特殊的通知，在不修改类代码的前提下，Introducetion可以在运行期间为类动态地添加一些方法或者属性。<br><strong>Target</strong>：代理的目标对象。<br><strong>Weaving</strong>：织入，是把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。<br><strong>Proxy</strong>：代理对象，一个被AOP织入增强后，就产生的一个结果代理类。<br><strong>Aspect</strong>：切面，是切入点和通知（引介）的结合。</p><h2 id="3-2-学习Spring中AOP要明确的事"><a href="#3-2-学习Spring中AOP要明确的事" class="headerlink" title="3.2 学习Spring中AOP要明确的事"></a>3.2 学习Spring中AOP要明确的事</h2><p>a. 开发阶段（我们做的）<br>编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。<br>把公用代码抽取出来，制作成通知。（开发阶段最后在做）：AOP编程人员来做。<br>在排至文件中，声明切入点与通知之间的关系，通知哪些方法不需要增强，哪些通知什么时候执行等，即切面：AOP编程人员来做。<br>b. 运行阶段（Spring框架完成的）<br>Spring框架监控切入点方法的执行，一旦监控到切入点发方被循行，使用代理机制，动态创建目标对象的带俩对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><h2 id="3-3-spring中AOP配置步骤"><a href="#3-3-spring中AOP配置步骤" class="headerlink" title="3.3 spring中AOP配置步骤"></a>3.3 spring中AOP配置步骤</h2><h3 id="3-3-1-基于xml的AOP配置"><a href="#3-3-1-基于xml的AOP配置" class="headerlink" title="3.3.1 基于xml的AOP配置"></a>3.3.1 基于xml的AOP配置</h3><ol><li>把通知Bean也交给spring管理配置</li><li>使用aop:config标签表明开始AOP的配置—&gt;</li><li>使用aop:aspect标签表明开始配置切面<pre><code>     id属性:给切面指定一个唯一标识     ref属性:指明通知类的id--&gt;</code></pre></li><li><p>在aop:aspect标签内部使用对应标签类配置通知的类型</p><pre><code>   我们现在示例是让println方法在切入点之前执行:前置通知   aop:before标签表示前置通知     method属性:用于指定Logger类中的哪个方法     pointcut属性:用于指定切入点表达式，该表达式的含义值得是对业务层中那些方法增强切入点表达式的写法：   关键字：execution(表达式)   表达式：访问修饰符 返回值 包名.包名...类名.方法名(参数列表)   表达式标准写法：public void com.service.impl.AccountServiceImpl.saveAccount()   访问修饰符可省略：void com.service.impl.AccountServiceImpl.saveAccount()   返回值可以使用通配符表示任意返回值：* com.service.impl.AccountServiceImpl.saveAccount()   全通配写法 ：* *..*.*(..)</code></pre></li></ol><h3 id="3-3-1-基于xml的AOP配置-1"><a href="#3-3-1-基于xml的AOP配置-1" class="headerlink" title="3.3.1 基于xml的AOP配置"></a>3.3.1 基于xml的AOP配置</h3><p>通过以下注解进行配置<br>括号中须指明配置有@Pointcut(切入点表达式)的方法名<br>@Before()<br>@AfterReturning()<br>@AfterThrowing()<br>@After()<br>@Around()</p><h1 id="4-Spring中的事务控制"><a href="#4-Spring中的事务控制" class="headerlink" title="4. Spring中的事务控制"></a>4. Spring中的事务控制</h1><p>JavaEE体系进行分层开发，事务控制位于业务层，Spring提供了分层涉及业务层的事务处理解决方案。Spring框架为我们提供了一组事务控制的接口，在spring-tx-包中。spring事务控制都是基于AOP的，它既可以使用编程的 方式实现，也可以使用配置的方式实现。</p><h2 id="4-1-Spring中事务控制的API"><a href="#4-1-Spring中事务控制的API" class="headerlink" title="4.1 Spring中事务控制的API"></a>4.1 Spring中事务控制的API</h2><h3 id="PlatformTransactionManager接口"><a href="#PlatformTransactionManager接口" class="headerlink" title="PlatformTransactionManager接口"></a>PlatformTransactionManager接口</h3><p>该接口有两个实现类：<br>DataSourceTransactionManager:使用Spring JDBC或者MyBatis进行持久化数据时使用。<br>HibernateTransactionManager:使用Hibernate版本进行持久化数据时使用。<br>实现类就是相当于配置bean。</p><h3 id="TransctionDefinition接口"><a href="#TransctionDefinition接口" class="headerlink" title="TransctionDefinition接口"></a>TransctionDefinition接口</h3><p>事务的定义信息对象。</p><h3 id="TransactionStatus接口"><a href="#TransactionStatus接口" class="headerlink" title="TransactionStatus接口"></a>TransactionStatus接口</h3><p>提供的是事务具体的运行状态，描述了某个时间点上事务对象的状态信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿#  1. IOC（控制反转，Inversion of Control）&lt;/p&gt;
&lt;p&gt;IOC：把创建对象的权力交给框架，是框架的重要特征，包括依赖注入和依赖查找。可降低类之间的耦合度。如果自己写代码，可以简单地通过工厂创建对象，若为单例可以将在初始化工厂时将对象放入容器
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://jwkang99.github.io/categories/Spring/"/>
    
    
      <category term="框架" scheme="https://jwkang99.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://jwkang99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>139.单词拆分</title>
    <link href="https://jwkang99.github.io/posts/e43b0cf4.html"/>
    <id>https://jwkang99.github.io/posts/e43b0cf4.html</id>
    <published>2020-07-09T07:02:48.000Z</published>
    <updated>2020-07-22T14:01:15.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定&nbsp;<em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><ul>   <li>拆分时可以重复使用字典中的单词。</li>   <li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><pre><strong>输入:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]<strong>输出:</strong> true<strong>解释:</strong> 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</pre><p><strong>示例 2：</strong></p><pre><strong>输入:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]<strong>输出:</strong> true<strong>解释:</strong> 返回 true 因为 <code>&quot;</code>applepenapple<code>&quot;</code> 可以被拆分成 <code>&quot;</code>apple pen apple<code>&quot;</code>。&nbsp;    注意你可以重复使用字典中的单词。</pre><p><strong>示例 3：</strong></p><pre><strong>输入:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]<strong>输出:</strong> false</pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><h5 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h5><p>对于输入示例1：<code>s=&quot;leetcode&quot;,wordDict=[&quot;leet&quot;,&quot;code&quot;]</code>.</p><ul><li>先判断<code>l</code>是否在字典中，</li><li>若在字典中，则判断剩余字符串是否能拆分</li><li>若不在字典中，则判断<code>le</code>是否在字典中</li></ul><p><a href="/posts/e43b0cf4/139_1.png" data-fancybox="group" data-caption="139_1" class="fancybox"><img alt="139_1" style="zoom:36%;" title="139_1" data-src="/posts/e43b0cf4/139_1.png" class="lazyload"></a></p><p>如下为未优化的DFS代码；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将list转为set方便判断单词是否存在于字典中</span></span><br><span class="line">    <span class="keyword">return</span> wordBreakHelper(s,<span class="keyword">new</span> HashSet&lt;&gt;(wordDict),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++)&#123;</span><br><span class="line">        <span class="comment">//若s.substring(start,end)在字典中，则判断剩余字符串是否可拆分</span></span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(s.substring(start,end)))&#123;</span><br><span class="line">            <span class="keyword">boolean</span> endRes = wordBreakHelper(s,wordDict,end);</span><br><span class="line">            <span class="comment">//若剩余字符串也可分则整个字符串可分，返回true</span></span><br><span class="line">            <span class="keyword">if</span>(endRes)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于存在冗余计算，在一些测试用例下会超时。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab&quot;</span><br><span class="line">[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;,&quot;aaaaa&quot;,&quot;aaaaaa&quot;,&quot;aaaaaaa&quot;,&quot;aaaaaaaa&quot;,&quot;aaaaaaaaa&quot;,&quot;aaaaaaaaaa&quot;]</span><br></pre></td></tr></table></figure></div><ul><li>首先判断<code>0</code>处的a在字典中，随后递归判断<code>1-end</code>子串是否可分。在判断<code>1-end</code>是否可分的递归中，同时判断出了<code>2-end、3-end、4-end...</code>是否可分，将这些结果记录下来</li><li>上一步中<code>0</code>和<code>1-end</code>的划分结果返回为<code>false</code>；随后判断<code>01</code>和<code>2-end</code>的划分是否可行，此时<code>2-end</code>的返回结果可直接使用记忆化结果，不用再递归计算结果。</li></ul><p><a href="/posts/e43b0cf4/139_2.png" data-fancybox="group" data-caption="139_2" class="fancybox"><img alt="139_2" style="zoom:36%;" title="139_2" data-src="/posts/e43b0cf4/139_2.png" class="lazyload"></a></p><p>如下为记忆化搜索的DFS代码；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wordBreakHelper(s,<span class="keyword">new</span> HashSet&lt;&gt;(wordDict),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(start))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(s.substring(start,end)))&#123;</span><br><span class="line">            <span class="keyword">boolean</span> startRes = wordBreakHelper(s,wordDict,end);</span><br><span class="line">            map.put(start,startRes);</span><br><span class="line">            <span class="keyword">if</span>(startRes)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(start,<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h5><p>用$dp[i]$表示$0-i$的子串是否可划分，转移方程可表示为：</p><script type="math/tex; mode=display">dp[i]=dp[0]\&\&check(1,i)||...||dp[j]\&\&check(j+1,i)</script><p>其中，$check(1,i)$表示判断子串$1-i$是否在字典中。</p><p>代码实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; set.contains(s.substring(j,i)))&#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>下述方法与上面的思想类似，不过转为判断字典中的每一个单词是否为当前子串的后缀，转移方程为：</p><script type="math/tex; mode=display">dp[i]=dp[i-curLen]\&\&check(i-curLen,i)</script><p>当前字典中的单词为<code>word</code>，单词长度为<code>curLen</code>，且<code>check(i-curLen,i)</code>判断子串的后缀<code>i-curLen..i</code>是否与<code>word</code>相等。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = word.length();</span><br><span class="line">            <span class="keyword">if</span>(curLen&lt;=i &amp;&amp; res[i-curLen] </span><br><span class="line">               &amp;&amp; word.equals(s.substring(i-curLen,i))) &#123;</span><br><span class="line">                res[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法三：字典树（Trie）"><a href="#方法三：字典树（Trie）" class="headerlink" title="方法三：字典树（Trie）"></a>方法三：字典树（Trie）</h5><p><strong>字典树/前缀树</strong>。使用场景：<strong>需要大量地判断某个字符串是否是给定单词列表中的前缀/后缀</strong></p><p>（部分图片来自leetcode）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;139-单词拆分&quot;&gt;&lt;a href=&quot;#139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;139.单词拆分&quot;&gt;&lt;/a&gt;139.单词拆分&lt;/h2&gt;&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL DB - Redis详解</title>
    <link href="https://jwkang99.github.io/posts/298b5fc3.html"/>
    <id>https://jwkang99.github.io/posts/298b5fc3.html</id>
    <published>2020-06-12T07:02:48.000Z</published>
    <updated>2021-06-11T10:17:17.298Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 分布缓存原理Redis 的全称是 Remote Dictionary Server（远程字典服务器）。它将数据以字典结构存储在内存中，应用可以直接到内存读写Redis存储的数据。</p><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供<strong>字符串，哈希，列表，队列，集合</strong>结构直接存取，基于内存，可持久化。</p><p>Redis 集群是一个典型的去中心化结构，每个节点都负责一部分数据的存储，同时，每个节点还会进行<strong>主备</strong>设计来提高 Redis 的可靠性。</p><p>Redis 中与缓存关系最紧密的三个特性：<strong>支持多数据结构、支持持久化和主备同步</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 分布缓存原理Redis 的全称是 Remote Dictionary Server（远程字典服务器）。它将数据以字典结构存储在内存中，应用可以直接到内存读写Redis存储的数据。&lt;/p&gt;
&lt;p&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用
      
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://jwkang99.github.io/categories/uncategorized/"/>
    
    
      <category term="进阶" scheme="https://jwkang99.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="数据库" scheme="https://jwkang99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="缓存" scheme="https://jwkang99.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>309.股票最大收益</title>
    <link href="https://jwkang99.github.io/posts/bc673c55.html"/>
    <id>https://jwkang99.github.io/posts/bc673c55.html</id>
    <published>2020-06-12T07:02:48.000Z</published>
    <updated>2020-07-22T13:50:30.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="309-股票最大收益"><a href="#309-股票最大收益" class="headerlink" title="309.股票最大收益"></a>309.股票最大收益</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个整数数组，其中第<em>&nbsp;i</em>&nbsp;个元素代表了第&nbsp;<em>i</em>&nbsp;天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul>   <li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>   <li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><pre><strong>输入:</strong> [1,2,3,0,2]<strong>输出: </strong>3 <strong>解释:</strong> 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><p>leetcode上股票类型的题目</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></p><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></p><p><strong>本题解析</strong>：</p><p>​        由于每一天可能存在冷冻期的状态，加上买入卖出一共三种状态，可是使用动态规划对每一天的状态进行表示。</p><p>​        使用$dp[i]$表示每一天结束之后的累计最大收益，对于每一天的状态表示如下：</p><ul><li>$dp[i][0]$ 表示第$i$天持有股票<ul><li>由于第$i$天持有股票，要么是继续持有$i-1$的股票，要么是第$i$天新买入一只股票</li><li>转移方程为：$dp[i][0] = max(dp[i-1][0],dp[i-1][2]-prices[i])$</li></ul></li><li>$dp[i][1]$表示第$i$天进行了卖出操作，即第$i$天结束之后不持有股票，且处于冷冻期，<ul><li>第$i$天结束之后不持有股票，且为冷冻期，则第$i$天进行了卖出操作，且$i-1$天需持有股票</li><li>转移方程为：$dp[i][1] = dp[i-1][0]+prices[i]$</li></ul></li><li>$dp[i][2]$表示第$i$天结束不持有股票，且不处于冷冻期  <ul><li>第$i$天结束之后不持有股票，且不是冷冻期，则$i-1$天没有买入且不是冷冻期，或者是$i-1$天是冷冻期</li><li>转移方程为：$dp[i][2] = max(dp[i-1][1],dp[i-1][2])$.</li></ul></li></ul><p>代码实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i] 表示第i天结束之后的最大收益</span></span><br><span class="line">    <span class="comment">//dp[][0] 表示持有股票</span></span><br><span class="line">    <span class="comment">//dp[][1] 表示不持有股票，且处于冷冻期</span></span><br><span class="line">    <span class="comment">//dp[][2] 表示持有股票，且不处于冷冻期</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">1</span>],dp[prices.length-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于$dp[i]$只和$dp[i-1]$有关，故可以进行矩阵压缩。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i] 表示第i天结束之后的最大收益</span></span><br><span class="line">    <span class="comment">//dp[][0] 表示持有股票</span></span><br><span class="line">    <span class="comment">//dp[][1] 表示不持有股票，且处于冷冻期</span></span><br><span class="line">    <span class="comment">//dp[][2] 表示持有股票，且不处于冷冻期</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_dp0 = Math.max(dp[<span class="number">0</span>],dp[<span class="number">2</span>]-prices[i]);</span><br><span class="line">        <span class="keyword">int</span> new_dp1 = dp[<span class="number">0</span>] + prices[i];</span><br><span class="line">        <span class="keyword">int</span> new_dp2 = Math.max(dp[<span class="number">1</span>],dp[<span class="number">2</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = new_dp0;</span><br><span class="line">        dp[<span class="number">1</span>] = new_dp1;</span><br><span class="line">        dp[<span class="number">2</span>] = new_dp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[<span class="number">1</span>],dp[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;309-股票最大收益&quot;&gt;&lt;a href=&quot;#309-股票最大收益&quot; class=&quot;headerlink&quot; title=&quot;309.股票最大收益&quot;&gt;&lt;/a&gt;309.股票最大收益&lt;/h2&gt;&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>字典树（Trie树）</title>
    <link href="https://jwkang99.github.io/posts/67cf0c47.html"/>
    <id>https://jwkang99.github.io/posts/67cf0c47.html</id>
    <published>2020-06-12T07:02:48.000Z</published>
    <updated>2021-06-04T13:39:09.630Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="https://jwkang99.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="https://jwkang99.github.io/posts/df41aea9.html"/>
    <id>https://jwkang99.github.io/posts/df41aea9.html</id>
    <published>2020-05-05T12:37:00.000Z</published>
    <updated>2021-05-27T14:46:35.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-synchronized修饰非静态方法"><a href="#1-synchronized修饰非静态方法" class="headerlink" title="1. synchronized修饰非静态方法"></a>1. synchronized修饰非静态方法</h3><p>每一个java对象都有一个内部锁，并且这个锁有一个内部条件。这个锁会管理试图进入synchronized方法的线程，这个条件可以管理调用了wait的线程。<br>synchronized修饰非静态方法和synchronized(this)修饰代码块是等价的。<br>当有一个线程t1进入对象Obj的synchronized修饰的非静态方法时，该线程就持有了该对象的锁，其他线程都不能进入该对象的其他synchronized修饰的非静态方法（不一定是同一个方法），需要等待t1释放锁，其他线程才能执行synchronized修饰的非静态方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处用synchronized修饰代码块的方式获得对象锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" enters into synchronized block print1"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print1"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处用synchronized修饰非静态方法的方式获得对象锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" enters into synchronized print2"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print2"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实例化一个Eg类的对象，并让两个线程分别运行两个同步方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Eg eg1 = <span class="keyword">new</span> Eg();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(eg1::print1, <span class="string">"t1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(eg1::print2, <span class="string">"t2"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></div><p>输出结果如下，说明两个线程顺序获得同一个对象锁，只有等t1释放eg1的对象锁之后，t2才能执行。如果t2调用的是eg2的print2()方法，则两个线程互不干扰。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 enters into print1 with synchronized(this)</span><br><span class="line">t1 leaves print1</span><br><span class="line">t2 enters into synchronized print2</span><br><span class="line">t2 leaves print2</span><br></pre></td></tr></table></figure></div><h3 id="2-synchronized修饰静态方法"><a href="#2-synchronized修饰静态方法" class="headerlink" title="2.synchronized修饰静态方法"></a>2.synchronized修饰静态方法</h3><p>如果synchronized修饰静态方法，那么该同步静态方法被调用时，Eg.class对象的锁会被锁定（成为<strong>类锁</strong>）。其他线程都不能调用该类的任何静态同步方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" enters into static synchronized print1"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print1"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Eg<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" enters into print2 with synchronized(Eg.class)"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行如下代码</span></span><br><span class="line">Eg eg1 = <span class="keyword">new</span> Eg();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(Eg::print1, <span class="string">"t1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(eg1::print2, <span class="string">"t2"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></div><p>执行后结果如下。虽然t2调用的时对象eg1的方法，但是该方法中需要对类加锁，和同步静态方法争夺同一个锁，所以才会顺序执行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 enters into static synchronized print1</span><br><span class="line">t1 leaves print1</span><br><span class="line">t2 enters into print2 with synchronized(Eg.class)</span><br><span class="line">t2 leaves print2</span><br></pre></td></tr></table></figure></div><p><strong>注</strong>：类锁被锁定时，并不意味着该类的所有实例对象都被锁定，类锁和对象锁是不冲突的。</p><p>示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" enters into static synchronized print1"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print1"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" enters into synchronized print2"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print2"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行如下代码</span></span><br><span class="line">Eg eg1 = <span class="keyword">new</span> Eg();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(Eg::print1, <span class="string">"t1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(eg1::print2, <span class="string">"t2"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></div><p>执行结果如下，可以看出t1获得类锁的同时，t2也获得了对象锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 enters into static synchronized print1</span><br><span class="line">t2 enters into synchronized print2</span><br><span class="line">t1 leaves print1</span><br><span class="line">t2 leaves print2</span><br></pre></td></tr></table></figure></div><h3 id="3-同步静态方法和同步非静态方法均修改静态变量"><a href="#3-同步静态方法和同步非静态方法均修改静态变量" class="headerlink" title="3. 同步静态方法和同步非静态方法均修改静态变量"></a>3. 同步静态方法和同步非静态方法均修改静态变量</h3><p>由第二节的实例可以得知，t1调用同步静态方法和t2调用对象的同步非静态方法时所争夺的锁是不冲突的，但是如果两者中对同一个静态变量做出修改呢？是否能保证原子性？<br>废话不多说，直接上例子。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg</span></span>&#123;</span><br><span class="line">    <span class="comment">// 声明静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" enters into static synchronized print1"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 同步静态方法中修改静态变量</span></span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + count);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print1"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" enters into synchronized print2"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 同步非静态方法中修改静态变量</span></span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + count);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" leaves print2"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行如下代码</span></span><br><span class="line">Eg eg1 = <span class="keyword">new</span> Eg();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(Eg::print1, <span class="string">"t1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(eg1::print2, <span class="string">"t2"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></div><p>执行结果如下。运行了好多次之后，虽然t1和t2确实是交错执行，但是结果和我最初预想的会破坏count增加的原子性不同，静态变量的原子性得到了保证。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t1 enters into static synchronized print1</span><br><span class="line">t2 enters into synchronized print2</span><br><span class="line">t2: 2</span><br><span class="line">t1: 1</span><br><span class="line">t1: 3</span><br><span class="line">t2: 4</span><br><span class="line">t2: 5</span><br><span class="line">t1: 6</span><br><span class="line">t1: 7</span><br><span class="line">t2: 8</span><br><span class="line">t1: 9</span><br><span class="line">t2: 10</span><br><span class="line">t1 leaves print1</span><br><span class="line">t2 leaves print2</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-synchronized修饰非静态方法&quot;&gt;&lt;a href=&quot;#1-synchronized修饰非静态方法&quot; class=&quot;headerlink&quot; title=&quot;1. synchronized修饰非静态方法&quot;&gt;&lt;/a&gt;1. synchronized修饰非静态方法
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySql</title>
    <link href="https://jwkang99.github.io/posts/a21c04fc.html"/>
    <id>https://jwkang99.github.io/posts/a21c04fc.html</id>
    <published>2020-04-19T07:21:00.000Z</published>
    <updated>2021-06-04T13:39:20.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL架构"><a href="#1-MySQL架构" class="headerlink" title="1.MySQL架构"></a>1.MySQL架构</h1><h2 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h2><p><a href="/posts/a21c04fc/structure.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/a21c04fc/structure.png" class="lazyload"></a></p><p>最上层为客户端，表示可以通过各种MySQL连接协议连接到MySQL的客户端比如JDBC等。最上层的客户端服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</p><p>第二层是MySQL服务层，大多数的核心服务都在这一层。所有跨存储引擎的服务都在这一层。</p><p>第三层存储引擎层，最常用的有MyISAM和InnoDB。</p><h2 id="1-2-MySQL常用的存储引擎"><a href="#1-2-MySQL常用的存储引擎" class="headerlink" title="1.2 MySQL常用的存储引擎"></a>1.2 MySQL常用的存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL5.5之前版本默认存储引擎，也是MySQL大部分系统表和临时表（这里所说的临时表示在排序、分组等操作中，当数量超过一定大小之后，有查询优化器建立的临时表）所使用的存储引擎。</p><p><strong>特性</strong></p><ul><li><p>并发性和锁级别<br>MyISAM使用的表级锁，而不是行级锁，对表进行修改时需要对整个表进行加锁。而对表的内容进行读取时，也需要对所有的数据加共享锁。-</p></li><li><p>表损坏修复<br>可通过<code>check table tablename</code>命令对表进行检查，<code>repair table tablename</code>命令对表进行修复</p></li><li>支持的索引类型<br>支持全文索引，blob等格式的索引</li><li>支持数据压缩（myisampack）</li></ul><p><strong>限制</strong></p><ul><li>版本在MySQL5.0之前，默认单表限制为4G，如果要存储达标则要修改MAX_Rows和AVG_ROW_LENGTH</li><li>版本在MySQL5.0之后的默认大小为256T，足够使用。</li></ul><p><strong>应用场景</strong></p><ul><li>非事务场景<br>MyISAM存储引擎不支持事务，例如一些在线分析应用，数据仓库，报表应用等</li><li>只读类应用</li><li>空间类应用<br>在MySQL5.7之前，MyISAM是唯一支持空间函数的存储引擎。</li></ul><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p>MySQL5.5之后版本默认存储引擎，Innodb使用表空间进行数据存储，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。</p><p>具体存在什么样的表空间中，由参数<code>innodb_file_per_table</code>字段的值决定。<br>为ON时，表示独立表空间，则为每个InnoDB表建立一个<code>tablename.ibd</code>。<br>如果为<code>OFF</code>，表示为系统表空间，会在数据存放在系统的共享表空间<code>ibdataX</code>。</p><p><strong>注</strong>：系统表空间和独立表空间要如何选择</p><p>比较：（建议使用独立表空间）</p><ul><li>系统表空间无法简单的收缩文件大小，造成大量空间浪费和碎片。</li><li>独立表空间可以通过<code>optimize table</code>命令收缩系统文件。</li><li>系统表空间会产生IO瓶颈。</li><li>独立表空间可以同时向多个文件刷新数据。</li></ul><p>把原来存在于系统表空间的表转移到独立表空间中，表转移步骤：</p><p>①使用mysqldump到处所有的数据库表数据<br>②停止MySQL服务，修改参数，并删除InnoDB相关文件<br>③重启M有SQL服务，重建InnoDB系统表空间<br>④重新导入数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MySQL架构&quot;&gt;&lt;a href=&quot;#1-MySQL架构&quot; class=&quot;headerlink&quot; title=&quot;1.MySQL架构&quot;&gt;&lt;/a&gt;1.MySQL架构&lt;/h1&gt;&lt;h2 id=&quot;1-1-MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#1-1-MySQL逻辑架
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://jwkang99.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://jwkang99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://jwkang99.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录</title>
    <link href="https://jwkang99.github.io/posts/1dca5680.html"/>
    <id>https://jwkang99.github.io/posts/1dca5680.html</id>
    <published>2020-03-12T07:02:48.000Z</published>
    <updated>2020-07-10T09:41:00.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071.字符串的最大公因子"></a>1071.字符串的最大公因子</h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p>leetcode地址：<a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/" target="_blank" rel="noopener">字符串的最大公因子</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.枚举，最大公因字串一定是两个字符串的公共前缀</span></span><br><span class="line"><span class="comment">//时间O((len1+len2)*(len1,len2)公因子个数)</span></span><br><span class="line"><span class="comment">//空间O(len1+len2)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubstring</span><span class="params">(String str, String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()%s.length()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = str.length() / s.length();</span><br><span class="line">    String ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        ans += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一次时间为O(str.length)</span></span><br><span class="line">    <span class="keyword">return</span> ans.equals(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1==<span class="keyword">null</span> || str1.equals(<span class="string">""</span>) || str1==<span class="keyword">null</span> || str1.equals(<span class="string">""</span>) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length(),len2 = str2.length();</span><br><span class="line">    <span class="comment">//按长度从大到小枚举，碰到的第一个满足条件的返回即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Math.min(len1,len2);i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        String res = str1.substring(<span class="number">0</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(isSubstring(str1,res) &amp;&amp; isSubstring(str2,res))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.分析的如果存在最大公因子串，那么该字串的长度一定是两原串的最大公约数</span></span><br><span class="line"><span class="comment">//故直接判断长度为最大公约数的前缀是否满足条件即可</span></span><br><span class="line"><span class="comment">//时间O(len1+len2)，求最大公约数时间为log(len1+len2)</span></span><br><span class="line"><span class="comment">//空间O(len1+len2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        b = a%b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length(),len2 = str2.length();</span><br><span class="line">    String res = str1.substring(<span class="number">0</span>,gcd(len1,len2));</span><br><span class="line">    <span class="keyword">return</span> isSubstring(str1,res)&amp;&amp;isSubstring(str2,res) ? res:<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.数学方法，如果str1+str2与str2+str1相同，则一定存在最长公因子串</span></span><br><span class="line"><span class="comment">//且最长公因子串长度为最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        b = a%b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(str1+str2).equals(str2+str1))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length(),len2 = str2.length();</span><br><span class="line">    String res = str1.substring(<span class="number">0</span>,gcd(len1,len2));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a>300.最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。该题leetcode地址：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划,时间O(n2),空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移，dp[i]表示以nums[i]结尾的最长递增子序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算每个dp[i]需要表里dp&#123;0-i&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                maxval = Math.max(maxval, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录最大值</span></span><br><span class="line">        maxans = Math.max(maxans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心+二分，</span></span><br><span class="line"><span class="comment">//贪心:为了使自增子序列尽可能长，那么每次选的最后一个元素都尽肯能的小</span></span><br><span class="line"><span class="comment">//考虑到上述算每个dp[i]都需要遍历dp&#123;0-i&#125;需要O(n)的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注：cell并不是最终的最长递增子序列</span></span><br><span class="line">    <span class="comment">//cell[i]表示长度为i的最长递增子序列末尾元素的最小值。</span></span><br><span class="line">    <span class="comment">//故最终，cell数组的长度就是最长自增子序列长度</span></span><br><span class="line">    <span class="comment">//以输入序列 [0, 8, 4, 12, 2]为例：</span></span><br><span class="line">    <span class="comment">//第一步插入 0,d=[0]；</span></span><br><span class="line">    <span class="comment">//第二步插入 8,d=[0,8]；</span></span><br><span class="line">    <span class="comment">//第三步插入 4,d=[0,4]；</span></span><br><span class="line">    <span class="comment">//第四步插入 12,d=[0,4,12]；</span></span><br><span class="line">    <span class="comment">//第五步插入 22,d=[0,2,12]；</span></span><br><span class="line">    <span class="keyword">int</span>[] cell = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    cell[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,k=res;</span><br><span class="line">        <span class="comment">//二分法插入cell数组</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (j+k)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cell[mid] &lt; nums[i])&#123;</span><br><span class="line">                j = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cell[j] &lt; nums[i])&#123;</span><br><span class="line">            cell[++j] = nums[i];</span><br><span class="line">            res++; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cell[j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h2><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。该题leetcode地址：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">岛屿的最大面积</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可在dfs和bfs的基础上稍加修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用于记录最大面积</span></span><br><span class="line"><span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//grid的行列元素数</span></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = grid.length;</span><br><span class="line">    n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//当前岛屿的面积</span></span><br><span class="line">                <span class="keyword">int</span> localArea = dfsHelper(grid,i,j);</span><br><span class="line">                maxArea = Math.max(maxArea,localArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化当前岛屿的面积</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; grid[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        count += dfsHelper(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        count += dfsHelper(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        count += dfsHelper(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        count += dfsHelper(grid,i-<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06.字符串压缩"></a>面试题 01.06.字符串压缩</h2><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。该题leetcode地址：<a href="https://leetcode-cn.com/problems/compress-string-lcci/" target="_blank" rel="noopener">字符串压缩</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = S.length();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处将S转化为字符数按下标更快</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(S.charAt(i)!=S.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">            res.append(S.charAt(i));</span><br><span class="line">            res.append(count);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(S.charAt(len-<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">        res.append(++count);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.length()&lt;len ? res.toString():S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160.拼写单词"></a>1160.拼写单词</h2><p>给你一份『词汇表』（字符串数组） <code>words</code> 和一张『字母表』（字符串） <code>chars</code>。假如你可以用 <code>chars</code> 中的『字母』（字符）拼写出 <code>words</code> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。返回词汇表 <code>words</code> 中你掌握的所有单词的 <strong>长度之和</strong>。注意：每次拼写时，<code>chars</code> 中的每个字母都只能用一次。该题leetcode地址：<a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">拼写单词</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把每个字母的频率存下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dic = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars==<span class="keyword">null</span> || chars.length()==<span class="number">0</span> || words==<span class="keyword">null</span> || words.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars.toCharArray())&#123;</span><br><span class="line">            dic[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chars.length() &gt;= words[i].length() &amp;&amp; isLearned(words[i].toCharArray()))&#123;</span><br><span class="line">                lenSum += words[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLearned</span><span class="params">(<span class="keyword">char</span>[] word)</span></span>&#123;</span><br><span class="line">        <span class="comment">//每个单词的临时表</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length;i++)&#123;</span><br><span class="line">            temp[word[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(temp[word[i]-<span class="string">'a'</span>]&gt;dic[word[i]-<span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.dfs（时间超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">boolean</span>[] learned;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars==<span class="keyword">null</span> || chars.length()==<span class="number">0</span> || words==<span class="keyword">null</span> || words.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length()];</span><br><span class="line">        learned = <span class="keyword">new</span> <span class="keyword">boolean</span>[words.length];</span><br><span class="line">        <span class="keyword">char</span>[] dic = chars.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">            countCharactersHelper(words[i].toCharArray(),i,dic,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countCharactersHelper</span><span class="params">(<span class="keyword">char</span>[] word,<span class="keyword">int</span> index,<span class="keyword">char</span>[] chars,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(learned[index])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==word.length)&#123;</span><br><span class="line">            lenSum += word.length;</span><br><span class="line">            learned[index] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || chars[i]!=word[start])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            countCharactersHelper(word,index,chars,start+<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="836-矩阵重叠"><a href="#836-矩阵重叠" class="headerlink" title="836.矩阵重叠"></a>836.矩阵重叠</h2><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。判断两矩阵是否重叠。</p><p><code>输入：rec1=[0,0,2,2],rec2=[1,1,3,3]。输出：true</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.两矩阵重叠可分为两部分，在xy两轴上的投影都相交。</span></span><br><span class="line"><span class="comment">//对于线段(x1,x2)和(x3,x4)，</span></span><br><span class="line"><span class="comment">//当min(x2,x4)&gt;max(x1,x3)时重叠</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rec1.length!=<span class="number">4</span> || rec2.length!=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x轴投影相交</span></span><br><span class="line">    <span class="keyword">return</span> rec1[<span class="number">0</span>]&lt;rec2[<span class="number">2</span>]&amp;&amp;rec1[<span class="number">2</span>]&gt;rec2[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">//y轴投影相交</span></span><br><span class="line">        &amp;&amp;rec1[<span class="number">1</span>]&lt;rec2[<span class="number">3</span>]&amp;&amp;rec1[<span class="number">3</span>]&gt;rec2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.还可以考虑相反的情况，不重叠</span></span><br><span class="line"><span class="comment">//不重叠rec1一定在rec2的上下左右一侧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]<span class="comment">//rec2在rec1右边</span></span><br><span class="line">                ||rec1[<span class="number">3</span>]&lt;=rec2[<span class="number">1</span>]<span class="comment">//rec2在rec1上边</span></span><br><span class="line">                ||rec1[<span class="number">0</span>]&gt;=rec2[<span class="number">2</span>]<span class="comment">//rec2在rec1左边</span></span><br><span class="line">                ||rec1[<span class="number">1</span>]&gt;=rec2[<span class="number">3</span>]);<span class="comment">//rec2在rec1下边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。leetcode地址：<a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">最长回文串</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : cs)&#123;</span><br><span class="line">        arr[c-<span class="string">'A'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> remain = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">58</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr[i]/<span class="number">2</span>;</span><br><span class="line">        res += n*<span class="number">2</span>;</span><br><span class="line">        arr[i]=arr[i]%<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!remain &amp;&amp; arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            remain = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(remain)&#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a>面试题40. 最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。用最大堆实现。</p><h2 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="365.水壶问题"></a>365.水壶问题</h2><p>有两个容量分别为 x升和y升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好z升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的z升水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.深度优先搜索</span></span><br><span class="line"><span class="comment">//空间时间都为O(xy)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//深度优先遍历两个水壶所有可能的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x+y&lt;z)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Pair&gt; reachable = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stack&lt;Pair&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Pair init = <span class="keyword">new</span> Pair(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        stack.push(init);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            Pair cur = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> remainX = cur.first;</span><br><span class="line">            <span class="keyword">int</span> remainY = cur.second;</span><br><span class="line">            <span class="keyword">if</span>(remainX==z || remainY==z || remainX+remainY==z)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(reachable.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reachable.add(cur);</span><br><span class="line">            <span class="comment">//把x填满</span></span><br><span class="line">            <span class="keyword">if</span>(remainX &lt; x)&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pair(x,remainY));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把y填满</span></span><br><span class="line">            <span class="keyword">if</span>(remainY &lt; y)&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pair(remainX,y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//清空x</span></span><br><span class="line">            stack.push(<span class="keyword">new</span> Pair(<span class="number">0</span>,remainY));</span><br><span class="line">            <span class="comment">//清空y</span></span><br><span class="line">            stack.push(<span class="keyword">new</span> Pair(remainX,<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//把x的倒入到y中，y满或者x空为止</span></span><br><span class="line">            <span class="keyword">int</span> acceptableY = y-remainY;</span><br><span class="line">            <span class="keyword">if</span>(remainX&gt;<span class="number">0</span> &amp;&amp; acceptableY&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(remainX &lt;= acceptableY)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(<span class="number">0</span>,remainY+remainX));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(remainX-acceptableY,y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把y的倒入到x中,x满或者y空为止</span></span><br><span class="line">            <span class="keyword">int</span> acceptableX = x-remainX;</span><br><span class="line">            <span class="comment">//如果y中还有水，且x没满</span></span><br><span class="line">            <span class="keyword">if</span>(remainY&gt;<span class="number">0</span> &amp;&amp; acceptableX&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(remainY &lt;= acceptableX)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(remainY+remainX,<span class="number">0</span>));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(x,remainY-acceptableX));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span> <span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set去重是需要比较hashcode和内容，故需要重写这两个方法</span></span><br><span class="line">    <span class="comment">//保证first和second相同时，两个Pair也相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Pair pair = (Pair) o;</span><br><span class="line">        <span class="keyword">return</span> first == pair.first &amp;&amp;</span><br><span class="line">                second == pair.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(first)+Objects.hash(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>数学方法：每次倒水都会给水的总量带来x或者y的变化量，因为</p><ul><li>两桶水不可能同时有水且不满，题目要求的操作都是至少一个是满的或者空的。</li><li>对一个不满的桶加水会回到初始状态，没有意义</li><li>把一个不满的桶的水倒掉也会回到初始状态，没有意义。</li></ul><p>所以在每次操作都会给两桶水总量带来x或者y的变化，即找到$ax+by=z$。</p><p>而贝祖定理告诉我们，$ax+by=z$ 有解当且仅当$z$是$x$,$y$的最大公约数的倍数。因此我们只需要找到 x, y<em>x</em>,<em>y</em> 的最大公约数并判断 z<em>z</em> 是否是它的倍数即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x+y&lt;z)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span> || y==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> z==<span class="number">0</span> || x+y==z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z % gcd(x,y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp%y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a>面试题 17.16. 按摩师</h2><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。与打家劫舍类似。地址：<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">按摩师</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，时间空间O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = dp[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">        max = Math.max(max,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化空间为O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> former = <span class="number">0</span>,latter = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = latter;</span><br><span class="line">        latter = Math.max(former+nums[i],latter);</span><br><span class="line">        former = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> latter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892.三维形体的表面积"></a>892.三维形体的表面积</h2><p>在 N <em> N 的网格上，我们放置一些 1 </em> 1 * 1  的立方体。每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。请你返回最终形体的表面积。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里采用的是加法，算出每个位置与上下左右相比没有被覆盖的部分相加。</span></span><br><span class="line"><span class="comment">//也可采用减法，时间O(n^2),空间O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] directionX = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] directionY = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = i + directionX[k];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + directionY[k];</span><br><span class="line">                    <span class="keyword">int</span> neatHeight = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;m &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;n)&#123;</span><br><span class="line">                        neatHeight = grid[newX][newY];</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    res += Math.max(grid[i][j]-neatHeight,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><p>给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><p>每组都有 X 张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X &gt;= 2 时返回 true。</p><blockquote><p>示例：<br>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p><p>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。</p></blockquote><p>分析：共n个数字，分成若干组，每组的数量都为x且每组内数字都相同。首先n一定能被x整除，且如果能成功分组，则每种数字的数量也可被x整除。所以就是一个寻找最大公约数的过程。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种暴力遍历，时间O(mn)，m为种数（10000）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deck==<span class="keyword">null</span> || deck.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储每种数字的数量</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:deck)&#123;</span><br><span class="line">        count[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = deck.length;</span><br><span class="line">    <span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//暴力判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count[j]%i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    isFound = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                isFound = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFound)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用最大公约数，O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasmGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deck==<span class="keyword">null</span> || deck.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:deck)&#123;</span><br><span class="line">        count[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gcd = count[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            gcd = gcd(gcd,count[i]);</span><br><span class="line">            <span class="comment">//可放在最后判断</span></span><br><span class="line">            <span class="keyword">if</span>(gcd==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp%y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="820-单词的压缩编码"><a href="#820-单词的压缩编码" class="headerlink" title="820. 单词的压缩编码"></a>820. 单词的压缩编码</h2><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">单词的压缩编码</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(words, (o1, o2) -&gt; o2.length()-o1.length());</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!sb.toString().contains(s+<span class="string">"#"</span>))&#123;</span><br><span class="line">            sb.append(s+<span class="string">"#"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>今天学习了一个新的知识点：<strong>字典树/前缀树</strong>。使用场景：<strong>需要大量地判断某个字符串是否是给定单词列表中的前缀/后缀</strong></p><h3 id="Trie树-字典树的实现"><a href="#Trie树-字典树的实现" class="headerlink" title="Trie树/字典树的实现"></a>Trie树/字典树的实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    TrieNode head;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head =  <span class="keyword">new</span> TrieNode(<span class="string">'r'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.children[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.children[index] = <span class="keyword">new</span> TrieNode(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        temp.isTail = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.isTail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prefix.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    <span class="keyword">boolean</span> isTail;</span><br><span class="line">    <span class="comment">//每个结点维护一个26的数组</span></span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="利用字典树优化"><a href="#利用字典树优化" class="headerlink" title="利用字典树优化"></a>利用字典树优化</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(words, (o1, o2) -&gt; o2.length()-o1.length());</span><br><span class="line">        Trie tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">            res += tree.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    TrieNode head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head =  <span class="keyword">new</span> TrieNode(<span class="string">'r'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//稍加修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">boolean</span> isNew = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.children[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                isNew = <span class="keyword">true</span>;</span><br><span class="line">                temp.children[index] = <span class="keyword">new</span> TrieNode(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在以word[i]为后缀的单词，就不加入单词列表</span></span><br><span class="line">        <span class="keyword">return</span> isNew?len+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162.地图分析"></a>1162.地图分析</h2><p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p><p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>leetcode地址：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">地图分析</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用bfs遍历，每次只出队一层，出完一层step++，最后遍历到的那个0就是最远的海洋</span></span><br><span class="line"><span class="comment">//该方法相当于多源的最短路径，也可用单源的最短路径</span></span><br><span class="line"><span class="comment">//当前海洋到最近陆地的距离在每个单源到某一海洋的距离中取最小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span> []&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(queue.size()==<span class="number">0</span> || queue.size()==grid.length*grid.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;curSize;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur[<span class="number">0</span>],y=cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newX&lt;grid.length&amp;&amp; newX&gt;=<span class="number">0</span> &amp;&amp; newY&lt;grid.length&amp;&amp;newY&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[newX][newY]==<span class="number">0</span>)&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                        grid[newX][newY] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h2><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。leetcode地址：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a>。</p><p>分析：最直观的方法就是模拟删除的这个过程，若这一次删除的是下标index位置的元素，下一次删除的可以算出来：(index+m-1)%size；因为删除了一个元素所以下标位置要减一。第一个想到的是用LinkedList实现，但是LinkedList找第i个结点需要遍历链表。用ArrayList查找元素为O(1)但删除元素需要大量移动，故两个方案时间复杂度差不多一致。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用ArrayList实现，时间O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemainingn</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        index = (index+m-<span class="number">1</span>)%n;</span><br><span class="line">        list.remove(index);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上边用容器模拟的方法时间复杂度不太理想，下边一种数学方法可以在<code>O(n)</code>完成。最后留下的数字在当前轮次的位置为index，在上一轮的位置为(index+m)%上一轮剩下的元素个数。</p><p><a href="/posts/1dca5680/面试62.png" data-fancybox="group" data-caption="面试62" class="fancybox"><img alt="面试62" title="面试62" data-src="/posts/1dca5680/面试62.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res = (res+m)%i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><a href="/posts/1dca5680/42.png" data-fancybox="group" data-caption="面试62" class="fancybox"><img alt="面试62" style="zoom:67%;" title="面试62" data-src="/posts/1dca5680/42.png" class="lazyload"></a></p><blockquote><p>示例：<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p></blockquote><p>分析：当前位置的雨水多少取决于两边墙的高度，明显由左右两边最高的墙的较小者决定。故可以遍历每一个位置，分别算出该位置左右两边的最大值，取最小的与当前位置做差。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把每个位置的左右两边的最大值存到数组中，时间O(n)，空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = height.length;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] maxToRight = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] maxToLeft = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    maxToLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    maxToRight[len-<span class="number">1</span>] = height[len-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        maxToLeft[i] = Math.max(height[i],maxToLeft[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        maxToRight[i] = Math.max(height[i],maxToRight[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        res+=(Math.min(maxToLeft[i],maxToRight[i])-height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>分析：由于每个位置的左右两端的最大值只用一次，而且<code>maxToRight</code>和<code>maxToLeft</code>都是单调的的，且都与<code>height(right)</code>和<code>height(left)</code>相关，故可以设置两个指针left和right分别用于更新左右两端的最大值。<code>height(left)&lt;height(right)</code>时一定有<code>maxToLeft&lt;maxToRight</code>，则left位置处的雨水多少取决于maxToLeft，计算left处的雨水量，反之计算right处的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.优化空间，时间O(n)，空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = height.length;</span><br><span class="line">    <span class="keyword">int</span> maxToRight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxToLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//此时left位置处的左墙最大值一定比右墙的小</span></span><br><span class="line">        <span class="comment">//故left位置的结果只取决于maxToLeft</span></span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">            maxToLeft = Math.max(maxToLeft,height[left]);</span><br><span class="line">            res+=(maxToLeft-height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//反之亦然</span></span><br><span class="line">            maxToRight = Math.max(maxToRight,height[right]);</span><br><span class="line">            res+=(maxToRight-height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>分析3：积水可以看作是左右两端的墙构成的一个凹槽，凹槽储水的多少也是右左右两边的墙决定的，可以看作是类似括号匹配的一个过程。用栈来模拟。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = height.length;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[stack.peek()]&lt;height[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> curIdx = stack.pop();</span><br><span class="line">            <span class="comment">//可以减少一些冗余计算</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[curIdx]==height[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.peek();</span><br><span class="line">                <span class="comment">//这里计算的是curIdx位置的在</span></span><br><span class="line">                <span class="comment">//min(height[top],height[i])高度限制下的水量</span></span><br><span class="line">                res += (Math.min(height[top],height[i])-height[curIdx])*(i-top-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="460-LFU缓存（困难）"><a href="#460-LFU缓存（困难）" class="headerlink" title="460. LFU缓存（困难）"></a>460. LFU缓存（困难）</h2><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：①插入一个字符、②删除一个字符、③替换一个字符</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a>。</p><blockquote><p>示例：<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p></blockquote><p>分析：可用动态规划解决。<code>dp[i][j]</code>表示<code>word1</code>的前<code>i</code>个字符转化为和<code>word2</code>的前<code>j</code>个字符一样所需的最小步数。则可得以下转移方程：$dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i][j])+1$。括号中的三个位置分别表示删除，增加，和替换操作。</p><p>在上例基础上解释：<br><code>dp[5][3]</code>为例，即要将表示<code>word1</code>的前<code>5</code>个字符转化为和<code>word2</code>的前<code>3</code>个字符，也就是将 horse 转换为 ros，因此有：<br>(1) <code>dp[i-1][j-1]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）</p><p>(2) <code>dp[i][j-1]</code>，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</p><p>(3) <code>dp[i-1][j]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = word1.length(),len2=word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> delAndAdd = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = Math.min(delAndAdd,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(delAndAdd,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h2><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间能否做到？</p><blockquote><p>给定 matrix =<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>原地旋转输入矩阵，使其变为:<br>  [7,4,1]<br>  [8,5,2]<br>  [9,6,3]</p></blockquote><p>分析：①可以使用辅助数组，第一行存在第一列。②在不是用辅助数组的情况下，观察发现第一列的1、4、7跑到了第一行而且顺序倒置了，可以想到先沿对角线反转，第一行得到1、4、7然后每行再翻转就解决了。③还有一种方法，考虑左上角<code>（i,j）</code>位置反转90度之后再数组中的位置，之后对应的三个位置为<code>（j,n-i-1）</code>、<code>（n-i-1,n-j-1）</code>、<code>（n-j-1,i）</code>，这四个位置的元素依次后移一位即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.先对角反转，再沿垂直中线反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="comment">//先对角反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//沿垂直中线反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[i][n-j-<span class="number">1</span>];</span><br><span class="line">            matrix[i][n-j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将左上角的元素以及之后对应的元素 顺时针后移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(n+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="comment">//四个元素顺时针后移</span></span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n-j-<span class="number">1</span>][i];</span><br><span class="line">            matrix[n-j-<span class="number">1</span>][i] = matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>];</span><br><span class="line">            matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>] = matrix[j][n-i-<span class="number">1</span>];</span><br><span class="line">            matrix[j][n-i-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。该题leetcode地址：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p><blockquote><p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p></blockquote><p>分析：参考<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">这里</a>。</p><p><a href="/posts/1dca5680/22.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/1dca5680/22.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.深度优先（回溯）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    generateParenthesisDFS(<span class="string">""</span>,n,n,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateParenthesisDFS</span><span class="params">(String curStr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(curStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)&#123;<span class="comment">//递归剪枝</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        generateParenthesisDFS(curStr+<span class="string">"("</span>,left-<span class="number">1</span>,right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        generateParenthesisDFS(curStr+<span class="string">")"</span>,left,right-<span class="number">1</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>深度优先遍历不需要显示使用栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显示使用栈。广度优先遍历需要显式的使用队列这个数据结构。以广度优先遍历实现时，需要定义一个结点类，来保存与上边DFS类似的状态信息，即当前剩余的左右括号数等。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuffixNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    String curStr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuffixNode</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String curStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.curStr = curStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    SuffixNode root = <span class="keyword">new</span> SuffixNode(n,n,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//把这里的队列换成栈就成了深度优先遍历</span></span><br><span class="line">    Queue&lt;SuffixNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        SuffixNode cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(cur.left==<span class="number">0</span> &amp;&amp; cur.right==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(cur.curStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.left&gt;<span class="number">0</span> &amp;&amp; cur.left-<span class="number">1</span>&lt;=cur.right)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> SuffixNode(cur.left-<span class="number">1</span>,cur.right,cur.curStr+<span class="string">"("</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right&gt;<span class="number">0</span> &amp;&amp; cur.left&lt;=cur.right-<span class="number">1</span>)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> SuffixNode(cur.left,cur.right-<span class="number">1</span>,cur.curStr+<span class="string">")"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>动态规划：由<code>i</code>对括号组成的序列，与由<code>i-1</code>对括号组成的序列有关。其中<code>dp[i-1]</code>是个列表</p><blockquote><p>dp[i] = “(“ + dp[i-1可能的括号对数] + “)” + dp[i-1剩下的括号对数]</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中把dp[i-1]拆分需要用到i-1之前的括号组合序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; dp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; dp0 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dp0.add(<span class="string">""</span>);</span><br><span class="line">    dp.add(dp0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            List&lt;String&gt; component = dp.get(j);</span><br><span class="line">            List&lt;String&gt; remain = dp.get(i-j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(String comp:component)&#123;</span><br><span class="line">                <span class="keyword">for</span>(String re:remain)&#123;</span><br><span class="line">                    cur.add(<span class="string">"("</span>+comp+<span class="string">")"</span>+re);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。，其中多余的空格删除</p><blockquote><p>示例：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>输入: “  hello  world!  “<br>输出: “world! hello”</p></blockquote><p>先把每个单词分隔出来，存在一个数组里，再将数组反转，用空格连接每个单词。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用JDK的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除去开头结尾的空格</span></span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="comment">//用正则表达式，一个或多个空格分割字符串</span></span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(s.split(<span class="string">"\\s+"</span>));</span><br><span class="line">    <span class="comment">//集合反转</span></span><br><span class="line">    Collections.reverse(words);</span><br><span class="line">    <span class="comment">//用空格连接每个单词</span></span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">" "</span>, words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887.鸡蛋掉落"></a>887.鸡蛋掉落</h2><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code> 共有 <code>N</code> 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次<em>移动</em>，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.二分法，时间复杂度O(NKlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop1</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        Arrays.fill(dp[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=K;j++)&#123;</span><br><span class="line">            <span class="comment">//二分查找最小查找次数</span></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">1</span>,right=i,mid=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid-<span class="number">1</span>][j-<span class="number">1</span>]&lt;dp[i-mid][j])&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[mid-<span class="number">1</span>][j-<span class="number">1</span>]&gt;dp[i-mid][j])&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最坏情况</span></span><br><span class="line">            dp[i][j] = Math.max(dp[mid-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-mid][j])+<span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"["</span>+i+<span class="string">","</span>+j+<span class="string">"]:"</span>+dp[i][j]+ <span class="string">"---"</span>+mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a>542.01矩阵</h2><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。leetcode地址：<a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">01 矩阵</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最开始用回溯递归去做，陷入了循环递归，造成栈溢出。</span></span><br><span class="line"><span class="comment">//后来发现跟以前做过的一个多源最短路径差不多</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=matrix.length,n=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span> []&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                matrix[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(queue.size()==m*n)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">        step++;</span><br><span class="line">        <span class="comment">//一次性将一层的结点都出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;curSize;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur[<span class="number">0</span>],y=cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newX&lt;m&amp;&amp; newX&gt;=<span class="number">0</span> &amp;&amp; newY&lt;n&amp;&amp;newY&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[newX][newY]==<span class="number">1</span>)&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                        matrix[newX][newY] = <span class="number">2</span>;</span><br><span class="line">                        res[newX][newY] = step;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。地址：<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间O(nlogn),为排序的时间</span></span><br><span class="line"><span class="comment">//首先想到的这个方法思路没问题，但是用了一个list再转为int[][]，白白浪费了n的空间</span></span><br><span class="line"><span class="comment">//可以直接用int[][]保存结果。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals.length==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = intervals.length;</span><br><span class="line">    <span class="comment">//把这些区间按照左端点进行升序排序</span></span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] pre = intervals[i];</span><br><span class="line">        <span class="comment">//每拿到一个区间i,都从i开始往后遍历寻找能重合的区间</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;len &amp;&amp; !(pre[<span class="number">1</span>]&lt;intervals[j][<span class="number">0</span>]))&#123;</span><br><span class="line">            <span class="keyword">int</span>[] next = intervals[j];</span><br><span class="line">            <span class="keyword">if</span>(next[<span class="number">1</span>]&gt;pre[<span class="number">1</span>] &amp;&amp; next[<span class="number">0</span>]&lt;=pre[<span class="number">1</span>])&#123;</span><br><span class="line">                pre[<span class="number">1</span>] = next[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; newEle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        newEle.add(pre[<span class="number">0</span>]);</span><br><span class="line">        newEle.add(pre[<span class="number">1</span>]);</span><br><span class="line">        res.add(newEle);</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;size;k++)&#123;</span><br><span class="line">        ans[k][<span class="number">0</span>] = res.get(k).get(<span class="number">0</span>);</span><br><span class="line">        ans[k][<span class="number">1</span>] = res.get(k).get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p>分析：并查集</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Union</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">int</span>[] rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Union</span><span class="params">(<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m = grid.length;</span><br><span class="line">            <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        parent[i*n+j] = i*n+j;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rank[i*n+j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != parent[cur])&#123;</span><br><span class="line">                cur = parent[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = findRoot(first);</span><br><span class="line">            <span class="keyword">int</span> root2 = findRoot(second);</span><br><span class="line">            <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rank[root1] &gt; rank[root2])&#123;</span><br><span class="line">                    parent[root2] = root1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rank[root1] &lt; rank[root2])&#123;</span><br><span class="line">                    parent[root1] = root2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent[root2] = root1;</span><br><span class="line">                    rank[root1]++;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        Union un = <span class="keyword">new</span> Union(grid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;row;r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;col;c++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[r][c]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(r-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,(r-<span class="number">1</span>)*col+c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(r+<span class="number">1</span>&lt;row &amp;&amp; grid[r+<span class="number">1</span>][c]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,(r+<span class="number">1</span>)*col+c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(c-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,r*col+c-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(c+<span class="number">1</span>&lt;col &amp;&amp; grid[r][c+<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,r*col+c+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> un.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248.统计「优美子数组」"></a>1248.统计「优美子数组」</h2><p>给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。leetcode地址：<a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">统计「优美子数组」</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把所有奇数得坐标存下来，时间空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] odd = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    odd[idx++]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">            odd[idx++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    odd[idx]=len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;idx;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = i+k-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(next&gt;=idx)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里从第i个奇数到i+k-1满足k个奇数得条件</span></span><br><span class="line">        <span class="comment">//分别向左扩展值前一个奇数的位置，向后扩展至后一个奇数的位置</span></span><br><span class="line">        res += (odd[i]-odd[i-<span class="number">1</span>])*(odd[next+<span class="number">1</span>]-odd[next]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.统计以第i个数字结尾的奇数个数即为oddNum</span></span><br><span class="line"><span class="comment">//查找j&lt;i,且以j结尾的奇数个数为oddNum-k的子数组个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> oddNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        oddNum += (nums[i]&amp;<span class="number">1</span>);</span><br><span class="line">        res += (oddNum&gt;=k)? cnt[oddNum-k]:<span class="number">0</span>;</span><br><span class="line">        cnt[oddNum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="23-合并k个排序链表"><a href="#23-合并k个排序链表" class="headerlink" title="23.合并k个排序链表"></a>23.合并k个排序链表</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.分治。两两合并，结构上为一颗合并树，时间复杂度为O(knlogk)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//两两合并</span></span><br><span class="line">        ListNode res1 = merge(lists,l,mid);</span><br><span class="line">        ListNode res2 = merge(lists,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode head1,ListNode head2)</span></span>&#123;    </span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="keyword">null</span>&amp;&amp;head2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;=head2.val)&#123;</span><br><span class="line">                p.next = head1;</span><br><span class="line">                p = p.next;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = head2;</span><br><span class="line">                p = p.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = head1==<span class="keyword">null</span> ? head2:head1;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用堆，每次选出头结点值最小的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((l1,l2)-&gt;l1.val-l2.val);</span><br><span class="line">    <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = newHead;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ListNode top = queue.poll();</span><br><span class="line">        p.next = top;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span>(top.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(top.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><blockquote><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.深度优先，相当于暴力解，超时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>,nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一步一步判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums[cur];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(cur+i,nums))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.实际情况是不用一步一步判断x能否准确到达位置y，如果x+nums[x]&gt;y则x即可到y</span></span><br><span class="line"><span class="comment">//用一个变量保存当前可达的最远位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//位置i在当前可达范围内</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=max)&#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = i+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curMax&gt;max)&#123;</span><br><span class="line">                max = curMax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最后一个位置可达</span></span><br><span class="line">            <span class="keyword">if</span>(max&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><blockquote><p>输入:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>输出: 4</p></blockquote><p>$dp(i,j)$表示以$matrix(i,j)$为右下角的最大正方形的边长。</p><script type="math/tex; mode=display">dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1.</script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m =matrix.length, n =matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxRes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                maxRes = Math.max(maxRes,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxRes*maxRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h2><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><blockquote><p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>]; </span><br><span class="line">    <span class="comment">//sum[i]表示从0-i元素的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>;left&lt;nums.length;left++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=left+<span class="number">1</span>;right&lt;=nums.length;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[right]-sum[left]==k)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>分析：在上述暴力解法中，对于每个位置<code>i</code>都需要遍历后续所有位置<code>j</code>（或者对每个的<code>j</code>都需遍历前边的所有位置<code>i</code>）寻找满足<code>sum[j]-sum[i]==k</code>。换种思考方式，<strong>前缀和</strong>即对于每个位置<code>i</code>，<code>0...i</code>的和为<code>sum[i]</code>，即寻找所有的<code>j(0≤j≤i)</code>满足<code>sum[j]=sum[i]-k</code>的位置，即统计满足该条件的<code>j</code>的个数，故可以用Map存储该数据。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        count += map.getOrDefault(sum-k,<span class="number">0</span>);</span><br><span class="line">        map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a>1371. 每个元音包含偶数次的最长子字符串</h2><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。leetcode地址：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">每个元音包含偶数次的最长子字符串</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀和，思想基本和560类似</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前缀和，记录当前状态出现的最早位置</span></span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    Arrays.fill(pos,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    pos[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'a'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'e'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'i'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'o'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'u'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos[status]==-<span class="number">1</span>)&#123;</span><br><span class="line">            pos[status] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = Math.max(res,i+<span class="number">1</span>-pos[status]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h2><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？leetcode地址：<a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">课程表</a>。</p><p><strong>分析</strong>：课程的先修关系明显可以转换为图的关系，先修关系表示为后续节点，没有先修关系即没有后续节点的课程（即入度为0）先修，随后再修改图，若所有课程均可完成，则返回true。故可转化为判断有向无环图的问题上。即通过拓扑排序的思想进行判断。<br><strong>拓扑排序原理</strong>： 对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)，均有 u（在排序记录中）比 v 先出现。也可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。</p><p><strong>注</strong>：若要返回拓扑排序结果只需稍作修改即可。</p><h3 id="方法一-根据入度表进行广度优先遍历"><a href="#方法一-根据入度表进行广度优先遍历" class="headerlink" title="方法一.根据入度表进行广度优先遍历"></a>方法一.根据入度表进行广度优先遍历</h3><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 O(N + M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；</li><li>空间复杂度 O(N + M)： 为建立邻接表所需额外空间，邻接表长度为 N ，并存储 M 条临边的数据。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序思想判断是否是有向无环图</span></span><br><span class="line"><span class="comment">//需通过节点的入度进行操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将所给prerequisites数组转换成图的形式,表示的为节点之间</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(numCourses);</span><br><span class="line">    <span class="comment">//graph(i)表示节点i的后续节点集合，即邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化每个节点的入度</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] cur : prerequisites)&#123;</span><br><span class="line">        indegree[cur[<span class="number">0</span>]]++;</span><br><span class="line">        graph.get(cur[<span class="number">1</span>]).add(cur[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化节点之间的相连关系</span></span><br><span class="line">    <span class="comment">//用队列辅助广度遍历</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//每出队一个，减少一个入度为0的节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph.get(cur))&#123;</span><br><span class="line">            <span class="keyword">if</span>(--indegree[next]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有节点都出队，没有环</span></span><br><span class="line">    <span class="keyword">return</span> numCourses==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="方法二-深度优先遍历（有点不太理解）"><a href="#方法二-深度优先遍历（有点不太理解）" class="headerlink" title="方法二. 深度优先遍历（有点不太理解）"></a>方法二. 深度优先遍历（有点不太理解）</h3><p>通过DFS判断是否有环</p><p>每个节点设置flag标志位，若没访问为0，访问过一次为1，两次为-1。</p><p>对 numCourses 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 False。<br>DFS 流程；</p><ul><li><p>终止条件：<br>当 flag[i] == 1，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 True。<br>当 flag[i] == -1，说明在本轮 DFS 搜索中节点 i 被第 2 次访问，即 课程安排图有环 ，直接返回 False。</p></li><li><p>将当前访问节点 i 对应 flag[i] 置 1，即标记其被本轮 DFS 访问过；</p></li><li><p>递归访问当前节点 i 的所有邻接节点 j，当发现环直接返回 FalseFalse；</p></li><li>当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 flag 置为 −1 并返回 True。</li></ul><p>若整个图 DFS 结束并未发现环，返回 TrueTrue。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将所给prerequisites数组转换成图的形式,表示的为节点之间</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(numCourses);</span><br><span class="line">    <span class="comment">//graph(i)表示节点i的后续节点集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] cur : prerequisites)&#123;</span><br><span class="line">        graph.get(cur[<span class="number">1</span>]).add(cur[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsHelper(graph,flag,i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfsHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph,<span class="keyword">int</span>[] flag,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[index]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag[index]==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[index]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> next : graph.get(index))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsHelper(graph,flag,next))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[index]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a>.</p><blockquote><p>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”</p></blockquote><p>复杂度分析<br>时间：$O(|S|+|T|)$。空间：$O(|S|+|T|)$</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">    <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">    <span class="keyword">char</span>[] sChars = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] tChars = t.toCharArray();</span><br><span class="line">    <span class="comment">//s的字串中包含每个字符的频次</span></span><br><span class="line">    <span class="keyword">int</span>[] sFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//t中包含每个字符的频次</span></span><br><span class="line">    <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//初始化tFreq数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> tc : tChars)&#123;</span><br><span class="line">        tFreq[tc]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s的包含t所有字符的最小字串长度</span></span><br><span class="line">    <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最小字串开始位置</span></span><br><span class="line">    <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录当前s子串中t中字符出现的个数</span></span><br><span class="line">    <span class="keyword">int</span> containNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//滑动窗口左右边界</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">char</span> rightChar = sChars[right];</span><br><span class="line">        <span class="comment">//若s中的当前字符在t中未出现，right向右移动</span></span><br><span class="line">        <span class="keyword">if</span>(tFreq[rightChar]==<span class="number">0</span>)&#123;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sFreq[rightChar] &lt; tFreq[rightChar])&#123;</span><br><span class="line">            <span class="comment">//若s中的当前字符在t中出现了</span></span><br><span class="line">            <span class="comment">//且在当前s子串中出现的次数少于t</span></span><br><span class="line">            containNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只要当前字符在t中出现了，更新子串中的频次表</span></span><br><span class="line">        sFreq[rightChar]++;</span><br><span class="line">        <span class="comment">//right向右移动，保持当前子串为[left,right)</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(containNum==tLen)&#123;</span><br><span class="line">            <span class="comment">//当前字串区间为[left,right)</span></span><br><span class="line">            <span class="keyword">if</span>(minLen &gt; right - left)&#123;</span><br><span class="line">                minLen = right - left;</span><br><span class="line">                minStart = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> leftChar = sChars[left];</span><br><span class="line">            <span class="keyword">if</span>(tFreq[leftChar]==<span class="number">0</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sFreq[leftChar] == tFreq[leftChar]) &#123;</span><br><span class="line">                containNum--; </span><br><span class="line">            &#125;</span><br><span class="line">            sFreq[leftChar]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minLen == sLen+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(minStart,minStart+minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a>.</p><p><strong>分析</strong></p><ul><li>1.可用归并排序先组合再找中位数。</li><li>2.可元素大小顺序查找两个数组中在位置<code>(len1+len2)/2</code>的元素。</li><li>3.用二分查找，在两个数组中分别寻找分割线，使得两个数组分别在其分割线左边的元素为<code>(len1+len2+1)/2</code>个，如果总数为奇数，左边比右边多一个，且满足<code>nums1[i] &gt;= nums1[j-1] &amp;&amp; nums1[i-1] &lt;= nums1[j]</code>。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换的目的是保证第二个数组在分割线的两侧都有元素不会越界</span></span><br><span class="line">    <span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别在两个数组中查找分割线</span></span><br><span class="line">    <span class="comment">// 使得两个数组在分割线左边的元素总数为总个数的一半，向上取整</span></span><br><span class="line">    <span class="comment">// 防止整形溢出可以写成 len1 + (len2 - len1 +1)/2</span></span><br><span class="line">    <span class="keyword">int</span> totalLeft = (len1 + len2 + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在nums1的[0,len1]寻找分割线i</span></span><br><span class="line">    <span class="comment">// i==0表示分割线左边没有元素,i==len1表示分割线右边没有元素</span></span><br><span class="line">    <span class="comment">// i表示nums1中右部数组的起始位置</span></span><br><span class="line">    <span class="comment">// 使得nums1[i] &gt;= nums1[j-1] &amp;&amp; nums1[i-1] &lt;= nums1[j]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len1;</span><br><span class="line">    <span class="comment">//退出循环时left==right</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">//nums1分割线左边有i个元素</span></span><br><span class="line">        <span class="keyword">int</span> i = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//限制nums2分割线位置</span></span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt; nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">// 下轮搜索区间[i+1,right]</span></span><br><span class="line">            <span class="comment">// 只有两个元素时[left(mid),right]不会死循环</span></span><br><span class="line">            left = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//下轮搜索区间[left,i]</span></span><br><span class="line">            right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = totalLeft - i ;</span><br><span class="line">    <span class="comment">//i==0表示分割线左边没有值</span></span><br><span class="line">    <span class="keyword">int</span> nums1MaxLeft = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//i==len1表示分割线右边没有值</span></span><br><span class="line">    <span class="keyword">int</span> nums1MinRight = i == len1 ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">    <span class="keyword">int</span> nums2MaxLeft = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> nums2MinRight = j == len2 ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">    <span class="keyword">if</span>((len1 + len2)%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums1MaxLeft,nums2MaxLeft);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)Math.max(nums1MaxLeft,nums2MaxLeft) + Math.min(nums1MinRight,nums2MinRight))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-16-18-模式匹配"><a href="#面试题-16-18-模式匹配" class="headerlink" title="面试题 16.18. 模式匹配"></a>面试题 16.18. 模式匹配</h2><p>你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。<a href="https://leetcode-cn.com/problems/pattern-matching-lcci/" target="_blank" rel="noopener">面试题 16.18. 模式匹配</a></p><p>分析：统计a和b的个数，枚举所有可能的a的长度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">patternMatching</span><span class="params">(String pattern, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count_a = <span class="number">0</span>,count_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len_v = value.length();</span><br><span class="line">    <span class="keyword">for</span>(Character c : pattern.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'a'</span>)&#123;</span><br><span class="line">            count_a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count_b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count_a+<span class="string">"====="</span>+count_b);</span><br><span class="line">    System.out.println(<span class="string">"before==="</span>+pattern);</span><br><span class="line">    <span class="keyword">if</span>(count_a&lt;count_b)&#123;  <span class="comment">//防止下边for循环len_a=0除数为0</span></span><br><span class="line">        <span class="keyword">int</span> temp = count_a;</span><br><span class="line">        count_a = count_b;</span><br><span class="line">        count_b = temp;</span><br><span class="line">        <span class="keyword">char</span>[] chars =pattern.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pattern.length();i++)&#123;</span><br><span class="line">            chars[i] = chars[i]==<span class="string">'a'</span> ? <span class="string">'b'</span> : <span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pattern = <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len_v==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> count_b==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"after==="</span>+pattern);</span><br><span class="line">    <span class="keyword">int</span> len_a, len_b;</span><br><span class="line">    <span class="keyword">for</span>(len_a=<span class="number">0</span>;len_a*count_a&lt;=len_v;len_a++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> remain = len_v-count_a*len_a;</span><br><span class="line">        String sub_a=<span class="string">""</span>,sub_b=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((count_b==<span class="number">0</span>&amp;&amp;remain==<span class="number">0</span>) || (count_b!=<span class="number">0</span>&amp;&amp;remain%count_b==<span class="number">0</span>))&#123;</span><br><span class="line">            len_b = count_b==<span class="number">0</span>?<span class="number">0</span>:remain/count_b;</span><br><span class="line">            <span class="keyword">for</span>(Character c : pattern.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">'a'</span>)&#123;</span><br><span class="line">                    String cur_sub = value.substring(pos,pos+len_a);</span><br><span class="line">                    <span class="keyword">if</span>(sub_a.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                        sub_a = cur_sub;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!sub_a.equals(cur_sub))&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pos += len_a;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    String cur_sub = value.substring(pos,pos+len_b);</span><br><span class="line">                    <span class="keyword">if</span>(sub_b.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                        sub_b = cur_sub;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!sub_b.equals(cur_sub))&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pos += len_b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sub_a+<span class="string">"----"</span>+sub_b+<span class="string">"---"</span>+!sub_a.equals(sub_b));</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="keyword">true</span> &amp;&amp; !sub_a.equals(sub_b))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1071-字符串的最大公因子&quot;&gt;&lt;a href=&quot;#1071-字符串的最大公因子&quot; class=&quot;headerlink&quot; title=&quot;1071.字符串的最大公因子&quot;&gt;&lt;/a&gt;1071.字符串的最大公因子&lt;/h2&gt;&lt;p&gt;对于字符串 S 和 T，只有在 S = T 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
