<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>解忧杂货铺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jwkang99.github.io/"/>
  <updated>2020-07-11T02:51:17.164Z</updated>
  <id>https://jwkang99.github.io/</id>
  
  <author>
    <name>康宁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>315.计算右侧小于当前元素的个数</title>
    <link href="https://jwkang99.github.io/posts/cabc759b.html"/>
    <id>https://jwkang99.github.io/posts/cabc759b.html</id>
    <published>2020-07-10T16:00:00.000Z</published>
    <updated>2020-07-11T02:51:17.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315.计算右侧小于当前元素的个数"></a>315.计算右侧小于当前元素的个数</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个整数数组 <em>nums</em>，按要求返回一个新数组&nbsp;<em>counts</em>。数组 <em>counts</em> 有该性质： <code>counts[i]</code> 的值是&nbsp; <code>nums[i]</code> 右侧小于&nbsp;<code>nums[i]</code> 的元素的数量。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> [5,2,6,1]<strong>输出:</strong> [2,1,1,0] <strong>解释:</strong>5 的右侧有 <strong>2 </strong>个更小的元素 (2 和 1).2 的右侧仅有 <strong>1 </strong>个更小的元素 (1).6 的右侧有 <strong>1 </strong>个更小的元素 (1).1 的右侧有 <strong>0 </strong>个更小的元素.</pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><h5 id="方法一：归并排序-索引数组"><a href="#方法一：归并排序-索引数组" class="headerlink" title="方法一：归并排序+索引数组"></a>方法一：归并排序+索引数组</h5><p>该题和计算逆序数个方法类似，利用归并排序可以快速统计出两段有序数组中的逆序数。由于题目中要求我们要具体计算到元素级别。“归并排序” 完成以后，原始数组的位置就已经变化了，因此可以使用索引数组定位元素是关键。<strong>“原始数组” 不变，用于比较两个元素的大小，真正位置变换的是 “索引数组”</strong>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] counts;</span><br><span class="line">    <span class="comment">//存储下标</span></span><br><span class="line">    <span class="keyword">int</span>[] indices;</span><br><span class="line">    <span class="comment">//归并排序辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] temp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        counts = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        indices = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">///存储数组下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            indices[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        merge(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : counts)&#123;</span><br><span class="line">            res.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并降序排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        merge(nums,left,mid);</span><br><span class="line">        merge(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        mergeSort(nums,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            temp[i] = indices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left , j = mid + <span class="number">1</span>, k = left;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[temp[i]] &gt; nums[temp[j]])&#123;</span><br><span class="line">                <span class="comment">//[9,6,5 | 4,1,0]</span></span><br><span class="line">                <span class="comment">// i       j</span></span><br><span class="line">                <span class="comment">//i和j构成逆序，则j之后也为逆序，直接相加</span></span><br><span class="line">                counts[temp[i]] += (right - j + <span class="number">1</span>);</span><br><span class="line">                indices[k++] = temp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                indices[k++] = temp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            indices[k++] = temp[i++];;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">            indices[k++] = temp[j++];;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法二：树状数组"><a href="#方法二：树状数组" class="headerlink" title="方法二：树状数组"></a>方法二：树状数组</h5><p>需要学习一下再来补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;315-计算右侧小于当前元素的个数&quot;&gt;&lt;a href=&quot;#315-计算右侧小于当前元素的个数&quot; class=&quot;headerlink&quot; title=&quot;315.计算右侧小于当前元素的个数&quot;&gt;&lt;/a&gt;315.计算右侧小于当前元素的个数&lt;/h2&gt;&lt;h4 id=&quot;题目描述：
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://jwkang99.github.io/posts/52ba89f4.html"/>
    <id>https://jwkang99.github.io/posts/52ba89f4.html</id>
    <published>2020-07-10T09:10:36.725Z</published>
    <updated>2020-03-06T13:29:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>﻿#  1. IOC（控制反转，Inversion of Control）</p><p>IOC：把创建对象的权力交给框架，是框架的重要特征，包括依赖注入和依赖查找。可降低类之间的耦合度。如果自己写代码，可以简单地通过工厂创建对象，若为单例可以将在初始化工厂时将对象放入容器中，再根据类名取单例对象。<br>之前一个类内部需要创建另外一个类的对象时，自己在类内部通过new或者反射的方式创建一个对象，直通通过工厂或者框架创建，我理解的这就是控制反转吧。</p><h1 id="2-使用Spring的ioc解决程序耦合问题"><a href="#2-使用Spring的ioc解决程序耦合问题" class="headerlink" title="2. 使用Spring的ioc解决程序耦合问题"></a>2. 使用Spring的ioc解决程序耦合问题</h1><p>把对象的创建交给spring管理<br>获取spring的IOC核心容器，并根据id获取对象<br>例：通过ApplicationContext获取核心容器。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XmlName为配置文件的名称，如Bean.xml</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(XmlName);</span><br><span class="line"><span class="comment">//BeanName为xml文件中配置的类的名称</span></span><br><span class="line">Object ocj = ac.getBean(BeanName);</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="Service" class="com.service.impl.ServiceImpl"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><h2 id="2-1-ApplicationContext的三个常用实现类"><a href="#2-1-ApplicationContext的三个常用实现类" class="headerlink" title="2.1 ApplicationContext的三个常用实现类"></a>2.1 ApplicationContext的三个常用实现类</h2><ol><li>ClassPathXmlApplicationContext:<br>加载类路径下的配置文件，要求配置文件必须在类路径下。</li><li>FileSystemApplicationContext:<br>加载磁盘任意路径下的配置文件(必须有访问权限)</li><li>AnnotationConfigApplicationContext:<br>用于读取注解创建文件<h2 id="2-2-创建核心容器的两个接口的不同"><a href="#2-2-创建核心容器的两个接口的不同" class="headerlink" title="2.2 创建核心容器的两个接口的不同"></a>2.2 创建核心容器的两个接口的不同</h2>创建容器有两个接口：ApplicationContext和BeanFactory，其中BeanFactory是ApplicationContext的子接口。</li></ol><p>ApplicationContext：<br>适用于<strong>单例对象</strong>。ApplicationContext在创建核心容器时，创建对象采取的策略是立即加载的方式，即只要读取完配置文件，马上通过反射的方式创建配置文件中的对象，并加入到核心容器中。因其是底层接口，更多的采用此接口定义容器对象。<br>在上例代码中，可以在ServiceImpl的默认构造函数中输出一句话，在读取配置文件的那一行打断点，即可发现在配置文件读取完毕后，配置文件中相应的对象都已经加载完毕。</p><p>BeanFactory:<br>适用于<strong>多例对象</strong>。BeanFactory在创建核心容器时，创建对象采取的策略是延时加载的方式，运行到根据id查找对象时，即如下代码，才真正的创建对象并把对象方入容器。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object ocj = ac.getBean(BeanName);</span><br></pre></td></tr></table></figure></div><h2 id="2-3-Spring对Bean的管理细节"><a href="#2-3-Spring对Bean的管理细节" class="headerlink" title="2.3 Spring对Bean的管理细节"></a>2.3 Spring对Bean的管理细节</h2><p>(1).创建Bean的三种方式<br>①  使用默认构造函数创建：在spring配置文件中使用bean标签，配以id和class(全限定类名)属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象。若没有默认构造函数则对象无法创建。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数创建对象xml文件示例</span></span><br><span class="line">&lt;bean id="Service" class="com.service.impl.ServiceImpl"&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id="Dao" class="com.dao.impl.DaoImpl"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>② 使用普通工厂类中的方法创建对象，即使用某个类(工厂类)中的方法创建对象，并存入spring容器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个普通工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>factory-bean用于指定创建该对象的工厂类id，factory-method用于指定创建该bean对象的方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--xml配置文件中的实现如下--&gt;</span><br><span class="line">&lt;bean id="instanceFactory" class="com.factory.InstanceFactory"&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id="Service" factory-bean="instanceFactory" factory-method="getService"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>③使用静态工厂中的静态方法创建对象(使用某个类中的静态方法创建对象并存入spring)<br>静态工厂类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>配置文件：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="Service" class="com.factory.StaticFactory" factory-method="getService"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>(2).bean的作用范围调整<br>spring创建的对象默认就是单例的，通过bean中的scope属性调整<br><strong>scope</strong>：</p><ol><li>singleton单例</li><li>prototype多例</li><li>request：作用于web应用的请求范围</li><li>session：作用于web应用的会话范围</li><li>global-session：作用于集群环境的会话范围(全局会话范围)，当不是集群环境是，它就是session</li></ol><p>(3).bean对象的生命周期<br>单例对象<br>    出生：当容器创建时对象出生，即之前的ApplicationContext<br>    活着：只要容器还在，对象一致活着<br>    死亡：容器销毁，对象消亡<br>多例对象<br>出生：当使用对象时spring框架为我们创建，即之前说的BeanFactory<br>    活着：对象只要在使用过程中就一致活着<br>    死亡：当对象长时间不用，且没有别的对象引用时，有java的GC回收<br>    可在标签中指定初始方法init-method和销毁方法destroy观察</p><p>(4).spring中的依赖注入<br>依赖注入：Dependency Injection<br>IOC作用：降低程序间的耦合(依赖关系)<br>依赖关系的管理：以后都交给了Spring来维护，在当前类需要用到其他类的对象时，由spring为我们提供，我们只需要在配置文件中说明<br>依赖关系的维护就称之为依赖注入</p><p>依赖注入<br>能注入的数据，有三类<br>①    基本数据类型和String<br>②    其他bean类型(在配置文件中或者注解配置过的bean)<br>③    复杂类型/集合类型</p><p>注入的方式，有三种<br>①    使用构造函数提供<br>在bean标签内部使用constructor-arg标签，标签中的属性<br><em>type</em>：用于指定要注入的数据类型，该数据类型也是构造函数中某个或某些参数的类型<br><em>index</em>：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，从0开始<br><em>name</em>：用于指定给构造函数中指定名称的参数赋值  ，常用<br>以上三个用于指定构造函数中哪个参数赋值<br><em>value</em>：用于提供基本类型和String类型数据<br>ref：用于提供其他bean类型，如下指的就是在spring的ioc核心容器中出现过的bean对象date</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"Service"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.ServiceImpl"</span>&gt;</span><br><span class="line">    &lt;constructor-arg name="name" value="kang"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name="age" value="19"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>注：对应类中必须有对应的有相同参数的构造方法</p><p>构造函数注入方式分析：<br>    <em>优势</em>：在获取bean对象时，注入数据时必须的操作，否则对象无法创建成功，如果某些类只想提供某些参数创建对象时比其他方式更简单。<br>    <em>弊端</em>：改变了bean对象的实例化方式，即使用不到这些数据也必须提供<br>②    使用set方法提供 更常用<br>在bean标签内部使用property标签，标签中的属性有：<br>name:用于指定注入时所调用的set方法名称<br>value:用于提供基本类型和String类型数据<br>ref:用于提供其他bean类型，指的就是在spring的ioc核心容器中出现过的bean对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"Service"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.ServiceImpl"</span>&gt;</span><br><span class="line"><span class="comment">//对应实体类中必须有相应属性的set方法</span></span><br><span class="line">   &lt;property name="name" value="kang"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="age" value="19"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>set方法<br>优势：创建对象没有明确限制，可以直接使用默认构造函数<br>弊端：如果有某个成员必须有值，无法保证一定注入，有可能没有set方法，则获取对象是有可能set方法没有执行</p><p><strong>当类中有集合类型的属性时</strong>，set方法注入时结构相同标签可以互换<br>总体上分为两种标签<br>map类标签：map和property<br>array类标签：array、list和set</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"accountService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.AccountServiceImpl"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myStr"</span> &gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myList"</span> &gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myMap"</span> &gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"1"</span>&gt;</span><br><span class="line">                &lt;value&gt;aa&lt;/value&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">            &lt;entry key="2" value="bb"&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myProps"</span>&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key="3"&gt;cc&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>③    使用注解提供<br>注：如果是经常变化的数据，并不使用于注入的方式，因为单例只有一个对象，属性永远不能变。</p><h2 id="3-基于注解的IOC配置"><a href="#3-基于注解的IOC配置" class="headerlink" title="3 基于注解的IOC配置"></a>3 基于注解的IOC配置</h2><p>以下为用xml配置文件实现的创建bean对象的基本方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"Service"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.service.impl.ServiceImpl"</span> scope=<span class="string">"singleton"</span> init-method=<span class="string">""</span> destroy-method=<span class="string">""</span>&gt;</span><br><span class="line"><span class="comment">//对应实体类中必须有相应属性的set方法</span></span><br><span class="line">   &lt;property name="name" value="kang"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="age" value="19"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div><p>spring中作用于bean对象的各个注解对应于上边xml中各个部分实现的功能大体一致。要想通过使用注解的方式创建对象，就要修改xml配置文件中的相关配置。告知spring在创建容器时要扫描context名称空间和约束，而不是去扫描配置文件中的bean标签。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"GBK"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在bean的约束中，而在一个名称为context名称空间和约束中--&gt;</span><br><span class="line">     &lt;!--会扫描所有位于com包下的类和接口上的注解--&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></div><p>用注解的方式创建bean对象中的相关注解大概有这么几类</p><ol><li>用于创建对象的：作用就和在xml配置文件中的bean标签一样<br> @Component(value=name)<br> 作用：放在加载类定义的前一行，用于把当前类对象存入spring容器中。<br> 属性：value用于指定bean的id。可省略，默认值时当前类名，且首字母改小写。<br> 以下三个注解的作用和属性与@Component基本一致<br> 这三个注解分别时spring框架为我们提供明确的三层使用的注解，是我们的三层对象更加清晰。<br> @Controller：一般用于表现层<br> @Service：一般用于业务层<br> @Repository：一般用于持久层</li></ol><p>下面代码将类型为DaoImpl 的对象放入到Spring的ioc核心容器中，其中key为注解中的值Dao，value为DaoImpl类型的对象，下边两个类都可以看做时IDao类型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl1</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl2</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li><p>用于注入数据的：作用就和在xml配置文件中的bean标签中写一个property标签时一样的<br> @Autowired<br> 作用：自动按照类型注入。只要容器(key,value)中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。如果ioc容器中没有和要注入变量类型一致的对象时，则报错。如果ioc容器中有多个类型匹配时，首先按照类型(value)找出匹配的对象，然后再按照变量名称(key)查找一致的对象<br> 位置：可在方法上，也可在变量上。<br> 细节：在使用注解注入时，set方法就不是必要的了。</p><p> 如下面代码，在ioc核心容器执行了getBean(“Service”)时，当执行有关dao属性的方法时，就会自动的从容器中寻找IDao类型的对象，若容器中只有一个直接注入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"Service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><p>@Qualifier<br>    作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用，但是在给方法参数注入时可以。<br>    属性：value，用于指定bean的注入的id<br>    注：不能独立使用，只能和@Autowired配合使用<br>    下例中中，ioc容器中有两个IDao类型的对象，用Qualifier注解指定属性自动注入的Bean的id</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"Service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"Dao1"</span>)</span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl1</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Dao2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl2</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div><p>@Resource<br>作用：直接按照bean的id(key)注入<br>属性：name，用于指定bean的id</p><p><strong>注意：</strong>@Autowired、@Qulifier和@Resource三个注解只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现。</p><p>@Value<br>作用：用于注入基本类型和String类型的数据<br>属性：用于指定数据的值。可以使用spring中的SpEL（Spring中的el表达式）<br>           SpEL写法：${表达式}</p><ol start="3"><li><p>用于改变作用范围的：作用和在bean标签中的scope属性是一样的<br> @Scope<br> 作用：用于指定bean的作用范围<br> 属性：value，指定取值范围。常用取值：singleton和prototype，默认为singleton</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上边默认的情况下，为单例，as和as2指向的同一个对象</span></span><br><span class="line">IService as = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">IService as2 = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">System.out.println(as==as2);  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//若改为以下代码</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"Service"</span>)</span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"Dao1"</span>)</span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line">&#125;</span><br><span class="line">IService as = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">IService as2 = (IService) ac.getBean(<span class="string">"Service"</span>);</span><br><span class="line">System.out.println(as==as2);  <span class="comment">//false,但as和as2中的dao仍为一个对象</span></span><br></pre></td></tr></table></figure></div></li><li><p>和生命周期相关：和bean标签中init-method和destroy-method一样<br> @ProDestroy<br> 作用：用于指定销毁方法，单例对象随容器关闭销毁，容器不负责多例对象，由GC回收<br> @PostConstruct<br> 作用：用于指定初始化方法</p></li><li><p>在使用注解创建和注入自定义的类时比较方便，由于所导入的jar包无法在其类头部加上@Service的注解，并且需要指定创建ioc容器时需要扫描的包，故只能在xml文件中定义bean标签将其放入ioc容器中。为了进一步实现没有xml的基于注解的ioc配置，引入一个新的注解<br> @Configuration<br> 作用：指定当前类是一个配置类</p><p> @ComponentScan(value=packageName)<br> 作用：用于通过注解指定spring在创建容器时要扫描的包<br> 属性：value和basePackages的作用一样<br> 注意：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。<br> 使用此注解作用相当于xml中context:component-scan标签</p><p> @Bean<br> 作用：用于吧当前方法的返回值作为bean对象存入spring的ioc容器中<br> 属性：用于指定bean的id，默认值为当前方法的名称<br> 注意：当用注解配置方法时，如果方法有参数，spring框架回去容器中查找有没有可用的bean对象，查找方式和Autowired一样。</p><p> @Import<br> 作用：用于导入其他的配置类<br> 属性：value用于指定其他配置类的字节码<br> 注意：当我们使用Import注解之后，有Import注解的为父配置类，而导入的都是子配置类</p><p> @PropertySource<br> 作用：用于指定properties文件的位置<br> 属性：value用于指定文件的名称和路径<br> 关键字：classpath表示类路径下</p></li></ol><p>思考：Spring为什么要整合junit，怎么整合。</p><h1 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3.AOP"></a>3.AOP</h1><blockquote><p>AOP(Aspect Oriented Programming)：面向切面编程<br>通过预编译的方式和运行期静态代理实现程序功能的统一维护的一种技术.AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>                     –摘自百度百科                            </p></blockquote><p>简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用倒台代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。<br>优势：减少重复代码，提高开发效率，维护方便<br>Spring中的AOP通过配置的方式实现动态代理。</p><h2 id="3-1-AOP相关术语："><a href="#3-1-AOP相关术语：" class="headerlink" title="3.1 AOP相关术语："></a>3.1 AOP相关术语：</h2><p><strong>Joinpoint</strong>：连接点，是指那些被拦截到的点。在Spring中，这些点只支持方法。<br><strong>Pointcut</strong>：切入点，只的是我们要对那些Joinpoint进行拦截的定义。所有的切入点都是连接点，只有被增强的连接点才是切入点。<br><strong>Advice</strong>：通知/增强，是指拦截到Joinpoint之后所要做的事情。通知的类型有：前置通知，后置通知，异常通知，最终通知和环绕通知。<br><strong>Introducetion</strong>：引介，是一种特殊的通知，在不修改类代码的前提下，Introducetion可以在运行期间为类动态地添加一些方法或者属性。<br><strong>Target</strong>：代理的目标对象。<br><strong>Weaving</strong>：织入，是把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。<br><strong>Proxy</strong>：代理对象，一个被AOP织入增强后，就产生的一个结果代理类。<br><strong>Aspect</strong>：切面，是切入点和通知（引介）的结合。</p><h2 id="3-2-学习Spring中AOP要明确的事"><a href="#3-2-学习Spring中AOP要明确的事" class="headerlink" title="3.2 学习Spring中AOP要明确的事"></a>3.2 学习Spring中AOP要明确的事</h2><p>a. 开发阶段（我们做的）<br>编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。<br>把公用代码抽取出来，制作成通知。（开发阶段最后在做）：AOP编程人员来做。<br>在排至文件中，声明切入点与通知之间的关系，通知哪些方法不需要增强，哪些通知什么时候执行等，即切面：AOP编程人员来做。<br>b. 运行阶段（Spring框架完成的）<br>Spring框架监控切入点方法的执行，一旦监控到切入点发方被循行，使用代理机制，动态创建目标对象的带俩对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><h2 id="3-3-spring中AOP配置步骤"><a href="#3-3-spring中AOP配置步骤" class="headerlink" title="3.3 spring中AOP配置步骤"></a>3.3 spring中AOP配置步骤</h2><h3 id="3-3-1-基于xml的AOP配置"><a href="#3-3-1-基于xml的AOP配置" class="headerlink" title="3.3.1 基于xml的AOP配置"></a>3.3.1 基于xml的AOP配置</h3><ol><li><p>把通知Bean也交给spring管理配置</p></li><li><p>使用aop:config标签表明开始AOP的配置–&gt;</p></li><li><p>使用aop:aspect标签表明开始配置切面</p><pre><code>id属性:给切面指定一个唯一标识ref属性:指明通知类的id--&gt;</code></pre></li><li><p>在aop:aspect标签内部使用对应标签类配置通知的类型</p><pre><code>   我们现在示例是让println方法在切入点之前执行:前置通知   aop:before标签表示前置通知     method属性:用于指定Logger类中的哪个方法     pointcut属性:用于指定切入点表达式，该表达式的含义值得是对业务层中那些方法增强切入点表达式的写法：   关键字：execution(表达式)   表达式：访问修饰符 返回值 包名.包名...类名.方法名(参数列表)   表达式标准写法：public void com.service.impl.AccountServiceImpl.saveAccount()   访问修饰符可省略：void com.service.impl.AccountServiceImpl.saveAccount()   返回值可以使用通配符表示任意返回值：* com.service.impl.AccountServiceImpl.saveAccount()   全通配写法 ：* *..*.*(..)</code></pre></li></ol><h3 id="3-3-1-基于xml的AOP配置-1"><a href="#3-3-1-基于xml的AOP配置-1" class="headerlink" title="3.3.1 基于xml的AOP配置"></a>3.3.1 基于xml的AOP配置</h3><p>通过以下注解进行配置<br>括号中须指明配置有@Pointcut(切入点表达式)的方法名<br>@Before()<br>@AfterReturning()<br>@AfterThrowing()<br>@After()<br>@Around()</p><h1 id="4-Spring中的事务控制"><a href="#4-Spring中的事务控制" class="headerlink" title="4. Spring中的事务控制"></a>4. Spring中的事务控制</h1><p>JavaEE体系进行分层开发，事务控制位于业务层，Spring提供了分层涉及业务层的事务处理解决方案。Spring框架为我们提供了一组事务控制的接口，在spring-tx-包中。spring事务控制都是基于AOP的，它既可以使用编程的 方式实现，也可以使用配置的方式实现。</p><h2 id="4-1-Spring中事务控制的API"><a href="#4-1-Spring中事务控制的API" class="headerlink" title="4.1 Spring中事务控制的API"></a>4.1 Spring中事务控制的API</h2><h3 id="PlatformTransactionManager接口"><a href="#PlatformTransactionManager接口" class="headerlink" title="PlatformTransactionManager接口"></a>PlatformTransactionManager接口</h3><p>该接口有两个实现类：<br>DataSourceTransactionManager:使用Spring JDBC或者MyBatis进行持久化数据时使用。<br>HibernateTransactionManager:使用Hibernate版本进行持久化数据时使用。<br>实现类就是相当于配置bean。</p><h3 id="TransctionDefinition接口"><a href="#TransctionDefinition接口" class="headerlink" title="TransctionDefinition接口"></a>TransctionDefinition接口</h3><p>事务的定义信息对象。</p><h3 id="TransactionStatus接口"><a href="#TransactionStatus接口" class="headerlink" title="TransactionStatus接口"></a>TransactionStatus接口</h3><p>提供的是事务具体的运行状态，描述了某个时间点上事务对象的状态信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿#  1. IOC（控制反转，Inversion of Control）&lt;/p&gt;
&lt;p&gt;IOC：把创建对象的权力交给框架，是框架的重要特征，包括依赖注入和依赖查找。可降低类之间的耦合度。如果自己写代码，可以简单地通过工厂创建对象，若为单例可以将在初始化工厂时将对象放入容器
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://jwkang99.github.io/categories/Spring/"/>
    
    
      <category term="框架" scheme="https://jwkang99.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://jwkang99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>139.单词拆分</title>
    <link href="https://jwkang99.github.io/posts/e43b0cf4.html"/>
    <id>https://jwkang99.github.io/posts/e43b0cf4.html</id>
    <published>2020-07-09T07:02:48.000Z</published>
    <updated>2020-07-10T09:42:56.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定&nbsp;<em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><ul>   <li>拆分时可以重复使用字典中的单词。</li>   <li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><pre><strong>输入:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]<strong>输出:</strong> true<strong>解释:</strong> 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</pre><p><strong>示例 2：</strong></p><pre><strong>输入:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]<strong>输出:</strong> true<strong>解释:</strong> 返回 true 因为 <code>&quot;</code>applepenapple<code>&quot;</code> 可以被拆分成 <code>&quot;</code>apple pen apple<code>&quot;</code>。&nbsp;    注意你可以重复使用字典中的单词。</pre><p><strong>示例 3：</strong></p><pre><strong>输入:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]<strong>输出:</strong> false</pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><h5 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h5><p>对于输入示例1：<code>s=&quot;leetcode&quot;,wordDict=[&quot;leet&quot;,&quot;code&quot;]</code>.</p><ul><li>先判断<code>l</code>是否在字典中，</li><li>若在字典中，则判断剩余字符串是否能拆分</li><li>若不在字典中，则判断<code>le</code>是否在字典中</li></ul><p><a href="/posts/e43b0cf4/139_1.png" data-fancybox="group" data-caption="139_1" class="fancybox"><img alt="139_1" style="zoom:50%;" title="139_1" data-src="/posts/e43b0cf4/139_1.png" class="lazyload"></a></p><p>如下为未优化的DFS代码；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将list转为set方便判断单词是否存在于字典中</span></span><br><span class="line">    <span class="keyword">return</span> wordBreakHelper(s,<span class="keyword">new</span> HashSet&lt;&gt;(wordDict),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++)&#123;</span><br><span class="line">        <span class="comment">//若s.substring(start,end)在字典中，则判断剩余字符串是否可拆分</span></span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(s.substring(start,end)))&#123;</span><br><span class="line">            <span class="keyword">boolean</span> endRes = wordBreakHelper(s,wordDict,end);</span><br><span class="line">            <span class="comment">//若剩余字符串也可分则整个字符串可分，返回true</span></span><br><span class="line">            <span class="keyword">if</span>(endRes)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于存在冗余计算，在一些测试用例下会超时。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab&quot;</span><br><span class="line">[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;,&quot;aaaaa&quot;,&quot;aaaaaa&quot;,&quot;aaaaaaa&quot;,&quot;aaaaaaaa&quot;,&quot;aaaaaaaaa&quot;,&quot;aaaaaaaaaa&quot;]</span><br></pre></td></tr></table></figure></div><ul><li>首先判断<code>0</code>处的a在字典中，随后递归判断<code>1-end</code>子串是否可分。在判断<code>1-end</code>是否可分的递归中，同时判断出了<code>2-end、3-end、4-end...</code>是否可分，将这些结果记录下来</li><li>上一步中<code>0</code>和<code>1-end</code>的划分结果返回为<code>false</code>；随后判断<code>01</code>和<code>2-end</code>的划分是否可行，此时<code>2-end</code>的返回结果可直接使用记忆化结果，不用再递归计算结果。</li></ul><p><a href="/posts/e43b0cf4/139_2.png" data-fancybox="group" data-caption="139_2" class="fancybox"><img alt="139_2" style="zoom:50%;" title="139_2" data-src="/posts/e43b0cf4/139_2.png" class="lazyload"></a></p><p>如下为记忆化搜索的DFS代码；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wordBreakHelper(s,<span class="keyword">new</span> HashSet&lt;&gt;(wordDict),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(start))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(s.substring(start,end)))&#123;</span><br><span class="line">            <span class="keyword">boolean</span> startRes = wordBreakHelper(s,wordDict,end);</span><br><span class="line">            map.put(start,startRes);</span><br><span class="line">            <span class="keyword">if</span>(startRes)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(start,<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h5><p>用$dp[i]$表示$0-i$的子串是否可划分，转移方程可表示为：</p><script type="math/tex; mode=display">dp[i]=dp[0]\&\&check(1,i)||...||dp[j]\&\&check(j+1,i)</script><p>其中，$check(1,i)$表示判断子串$1-i$是否在字典中。</p><p>代码实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; set.contains(s.substring(j,i)))&#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>下述方法与上面的思想类似，不过转为判断字典中的每一个单词是否为当前子串的后缀，转移方程为：</p><script type="math/tex; mode=display">dp[i]=dp[i-curLen]\&\&check(i-curLen,i)</script><p>当前字典中的单词为<code>word</code>，单词长度为<code>curLen</code>，且<code>check(i-curLen,i)</code>判断子串的后缀<code>i-curLen..i</code>是否与<code>word</code>相等。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = word.length();</span><br><span class="line">            <span class="keyword">if</span>(curLen&lt;=i &amp;&amp; res[i-curLen] </span><br><span class="line">               &amp;&amp; word.equals(s.substring(i-curLen,i))) &#123;</span><br><span class="line">                res[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="方法三：字典树（Trie）"><a href="#方法三：字典树（Trie）" class="headerlink" title="方法三：字典树（Trie）"></a>方法三：字典树（Trie）</h5><p><strong>字典树/前缀树</strong>。使用场景：<strong>需要大量地判断某个字符串是否是给定单词列表中的前缀/后缀</strong></p><p>（部分图片来自leetcode）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;139-单词拆分&quot;&gt;&lt;a href=&quot;#139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;139.单词拆分&quot;&gt;&lt;/a&gt;139.单词拆分&lt;/h2&gt;&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://jwkang99.github.io/categories/uncategorized/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>309.股票最大收益</title>
    <link href="https://jwkang99.github.io/posts/bc673c55.html"/>
    <id>https://jwkang99.github.io/posts/bc673c55.html</id>
    <published>2020-06-12T07:02:48.000Z</published>
    <updated>2020-07-10T09:20:10.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="309-股票最大收益"><a href="#309-股票最大收益" class="headerlink" title="309.股票最大收益"></a>309.股票最大收益</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个整数数组，其中第<em>&nbsp;i</em>&nbsp;个元素代表了第&nbsp;<em>i</em>&nbsp;天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul>   <li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>   <li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><pre><strong>输入:</strong> [1,2,3,0,2]<strong>输出: </strong>3 <strong>解释:</strong> 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</pre><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><p>leetcode上股票类型的题目</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></p><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></p><p><strong>本题解析</strong>：</p><p>​        由于每一天可能存在冷冻期的状态，加上买入卖出一共三种状态，可是使用动态规划对每一天的状态进行表示。</p><p>​        使用$dp[i]$表示每一天结束之后的累计最大收益，对于每一天的状态表示如下：</p><ul><li>$dp[i][0]$ 表示第$i$天持有股票<ul><li>由于第$i$天持有股票，要么是继续持有$i-1$的股票，要么是第$i$天新买入一只股票</li><li>转移方程为：$dp[i][0] = max(dp[i-1][0],dp[i-1][2]-prices[i])$</li></ul></li><li>$dp[i][1]$表示第$i$天进行了卖出操作，即第$i$天结束之后不持有股票，且处于冷冻期，<ul><li>第$i$天结束之后不持有股票，且为冷冻期，则第$i$天进行了卖出操作，且$i-1$天需持有股票</li><li>转移方程为：$dp[i][1] = dp[i-1][0]+prices[i]$</li></ul></li><li>$dp[i][2]$表示第$i$天结束不持有股票，且不处于冷冻期  <ul><li>第$i$天结束之后不持有股票，且不是冷冻期，则$i-1$天没有买入且不是冷冻期，或者是$i-1$天是冷冻期</li><li>转移方程为：$dp[i][2] = max(dp[i-1][1],dp[i-1][2])$.</li></ul></li></ul><p>代码实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i] 表示第i天结束之后的最大收益</span></span><br><span class="line">    <span class="comment">//dp[][0] 表示持有股票</span></span><br><span class="line">    <span class="comment">//dp[][1] 表示不持有股票，且处于冷冻期</span></span><br><span class="line">    <span class="comment">//dp[][2] 表示持有股票，且不处于冷冻期</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">1</span>],dp[prices.length-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于$dp[i]$只和$dp[i-1]$有关，故可以进行矩阵压缩。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i] 表示第i天结束之后的最大收益</span></span><br><span class="line">    <span class="comment">//dp[][0] 表示持有股票</span></span><br><span class="line">    <span class="comment">//dp[][1] 表示不持有股票，且处于冷冻期</span></span><br><span class="line">    <span class="comment">//dp[][2] 表示持有股票，且不处于冷冻期</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_dp0 = Math.max(dp[<span class="number">0</span>],dp[<span class="number">2</span>]-prices[i]);</span><br><span class="line">        <span class="keyword">int</span> new_dp1 = dp[<span class="number">0</span>] + prices[i];</span><br><span class="line">        <span class="keyword">int</span> new_dp2 = Math.max(dp[<span class="number">1</span>],dp[<span class="number">2</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = new_dp0;</span><br><span class="line">        dp[<span class="number">1</span>] = new_dp1;</span><br><span class="line">        dp[<span class="number">2</span>] = new_dp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[<span class="number">1</span>],dp[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;309-股票最大收益&quot;&gt;&lt;a href=&quot;#309-股票最大收益&quot; class=&quot;headerlink&quot; title=&quot;309.股票最大收益&quot;&gt;&lt;/a&gt;309.股票最大收益&lt;/h2&gt;&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://jwkang99.github.io/categories/uncategorized/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>字典树（Trie树）</title>
    <link href="https://jwkang99.github.io/posts/67cf0c47.html"/>
    <id>https://jwkang99.github.io/posts/67cf0c47.html</id>
    <published>2020-06-12T07:02:48.000Z</published>
    <updated>2020-07-10T09:20:10.969Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://jwkang99.github.io/categories/uncategorized/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySql</title>
    <link href="https://jwkang99.github.io/posts/a21c04fc.html"/>
    <id>https://jwkang99.github.io/posts/a21c04fc.html</id>
    <published>2020-04-19T07:21:00.000Z</published>
    <updated>2020-07-10T09:39:02.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL架构"><a href="#1-MySQL架构" class="headerlink" title="1.MySQL架构"></a>1.MySQL架构</h1><h2 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h2><p><a href="/posts/a21c04fc/structure.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/a21c04fc/structure.png" class="lazyload"></a></p><p>最上层为客户端，表示可以通过各种MySQL连接协议连接到MySQL的客户端比如JDBC等。最上层的客户端服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</p><p>第二层是MySQL服务层，大多数的核心服务都在这一层。所有跨存储引擎的服务都在这一层。</p><p>第三层存储引擎层，最常用的有MyISAM和InnoDB。</p><h2 id="1-2-MySQL常用的存储引擎"><a href="#1-2-MySQL常用的存储引擎" class="headerlink" title="1.2 MySQL常用的存储引擎"></a>1.2 MySQL常用的存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL5.5之前版本默认存储引擎，也是MySQL大部分系统表和临时表（这里所说的临时表示在排序、分组等操作中，当数量超过一定大小之后，有查询优化器建立的临时表）所使用的存储引擎。</p><p><strong>特性</strong></p><ul><li><p>并发性和锁级别<br>MyISAM使用的表级锁，而不是行级锁，对表进行修改时需要对整个表进行加锁。而对表的内容进行读取时，也需要对所有的数据加共享锁。-</p></li><li><p>表损坏修复<br>可通过<code>check table tablename</code>命令对表进行检查，<code>repair table tablename</code>命令对表进行修复</p></li><li>支持的索引类型<br>支持全文索引，blob等格式的索引</li><li>支持数据压缩（myisampack）</li></ul><p><strong>限制</strong></p><ul><li>版本在MySQL5.0之前，默认单表限制为4G，如果要存储达标则要修改MAX_Rows和AVG_ROW_LENGTH</li><li>版本在MySQL5.0之后的默认大小为256T，足够使用。</li></ul><p><strong>应用场景</strong></p><ul><li>非事务场景<br>MyISAM存储引擎不支持事务，例如一些在线分析应用，数据仓库，报表应用等</li><li>只读类应用</li><li>空间类应用<br>在MySQL5.7之前，MyISAM是唯一支持空间函数的存储引擎。</li></ul><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p>MySQL5.5之后版本默认存储引擎，Innodb使用表空间进行数据存储，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。</p><p>具体存在什么样的表空间中，由参数<code>innodb_file_per_table</code>字段的值决定。<br>为ON时，表示独立表空间，则为每个InnoDB表建立一个<code>tablename.ibd</code>。<br>如果为<code>OFF</code>，表示为系统表空间，会在数据存放在系统的共享表空间<code>ibdataX</code>。</p><p><strong>注</strong>：系统表空间和独立表空间要如何选择</p><p>比较：（建议使用独立表空间）</p><ul><li>系统表空间无法简单的收缩文件大小，造成大量空间浪费和碎片。</li><li>独立表空间可以通过<code>optimize table</code>命令收缩系统文件。</li><li>系统表空间会产生IO瓶颈。</li><li>独立表空间可以同时向多个文件刷新数据。</li></ul><p>把原来存在于系统表空间的表转移到独立表空间中，表转移步骤：</p><p>①使用mysqldump到处所有的数据库表数据<br>②停止MySQL服务，修改参数，并删除InnoDB相关文件<br>③重启M有SQL服务，重建InnoDB系统表空间<br>④重新导入数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MySQL架构&quot;&gt;&lt;a href=&quot;#1-MySQL架构&quot; class=&quot;headerlink&quot; title=&quot;1.MySQL架构&quot;&gt;&lt;/a&gt;1.MySQL架构&lt;/h1&gt;&lt;h2 id=&quot;1-1-MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#1-1-MySQL逻辑架
      
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://jwkang99.github.io/categories/uncategorized/"/>
    
    
      <category term="数据库" scheme="https://jwkang99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://jwkang99.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录</title>
    <link href="https://jwkang99.github.io/posts/1dca5680.html"/>
    <id>https://jwkang99.github.io/posts/1dca5680.html</id>
    <published>2020-03-12T07:02:48.000Z</published>
    <updated>2020-07-10T09:41:00.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071.字符串的最大公因子"></a>1071.字符串的最大公因子</h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p>leetcode地址：<a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/" target="_blank" rel="noopener">字符串的最大公因子</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.枚举，最大公因字串一定是两个字符串的公共前缀</span></span><br><span class="line"><span class="comment">//时间O((len1+len2)*(len1,len2)公因子个数)</span></span><br><span class="line"><span class="comment">//空间O(len1+len2)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubstring</span><span class="params">(String str, String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()%s.length()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = str.length() / s.length();</span><br><span class="line">    String ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        ans += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一次时间为O(str.length)</span></span><br><span class="line">    <span class="keyword">return</span> ans.equals(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1==<span class="keyword">null</span> || str1.equals(<span class="string">""</span>) || str1==<span class="keyword">null</span> || str1.equals(<span class="string">""</span>) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length(),len2 = str2.length();</span><br><span class="line">    <span class="comment">//按长度从大到小枚举，碰到的第一个满足条件的返回即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Math.min(len1,len2);i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        String res = str1.substring(<span class="number">0</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(isSubstring(str1,res) &amp;&amp; isSubstring(str2,res))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.分析的如果存在最大公因子串，那么该字串的长度一定是两原串的最大公约数</span></span><br><span class="line"><span class="comment">//故直接判断长度为最大公约数的前缀是否满足条件即可</span></span><br><span class="line"><span class="comment">//时间O(len1+len2)，求最大公约数时间为log(len1+len2)</span></span><br><span class="line"><span class="comment">//空间O(len1+len2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        b = a%b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length(),len2 = str2.length();</span><br><span class="line">    String res = str1.substring(<span class="number">0</span>,gcd(len1,len2));</span><br><span class="line">    <span class="keyword">return</span> isSubstring(str1,res)&amp;&amp;isSubstring(str2,res) ? res:<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.数学方法，如果str1+str2与str2+str1相同，则一定存在最长公因子串</span></span><br><span class="line"><span class="comment">//且最长公因子串长度为最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        b = a%b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(str1+str2).equals(str2+str1))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length(),len2 = str2.length();</span><br><span class="line">    String res = str1.substring(<span class="number">0</span>,gcd(len1,len2));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a>300.最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。该题leetcode地址：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划,时间O(n2),空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移，dp[i]表示以nums[i]结尾的最长递增子序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算每个dp[i]需要表里dp&#123;0-i&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                maxval = Math.max(maxval, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录最大值</span></span><br><span class="line">        maxans = Math.max(maxans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心+二分，</span></span><br><span class="line"><span class="comment">//贪心:为了使自增子序列尽可能长，那么每次选的最后一个元素都尽肯能的小</span></span><br><span class="line"><span class="comment">//考虑到上述算每个dp[i]都需要遍历dp&#123;0-i&#125;需要O(n)的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注：cell并不是最终的最长递增子序列</span></span><br><span class="line">    <span class="comment">//cell[i]表示长度为i的最长递增子序列末尾元素的最小值。</span></span><br><span class="line">    <span class="comment">//故最终，cell数组的长度就是最长自增子序列长度</span></span><br><span class="line">    <span class="comment">//以输入序列 [0, 8, 4, 12, 2]为例：</span></span><br><span class="line">    <span class="comment">//第一步插入 0,d=[0]；</span></span><br><span class="line">    <span class="comment">//第二步插入 8,d=[0,8]；</span></span><br><span class="line">    <span class="comment">//第三步插入 4,d=[0,4]；</span></span><br><span class="line">    <span class="comment">//第四步插入 12,d=[0,4,12]；</span></span><br><span class="line">    <span class="comment">//第五步插入 22,d=[0,2,12]；</span></span><br><span class="line">    <span class="keyword">int</span>[] cell = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    cell[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,k=res;</span><br><span class="line">        <span class="comment">//二分法插入cell数组</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (j+k)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cell[mid] &lt; nums[i])&#123;</span><br><span class="line">                j = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cell[j] &lt; nums[i])&#123;</span><br><span class="line">            cell[++j] = nums[i];</span><br><span class="line">            res++; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cell[j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h2><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。该题leetcode地址：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">岛屿的最大面积</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可在dfs和bfs的基础上稍加修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用于记录最大面积</span></span><br><span class="line"><span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//grid的行列元素数</span></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = grid.length;</span><br><span class="line">    n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//当前岛屿的面积</span></span><br><span class="line">                <span class="keyword">int</span> localArea = dfsHelper(grid,i,j);</span><br><span class="line">                maxArea = Math.max(maxArea,localArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化当前岛屿的面积</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; grid[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        count += dfsHelper(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        count += dfsHelper(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        count += dfsHelper(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        count += dfsHelper(grid,i-<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06.字符串压缩"></a>面试题 01.06.字符串压缩</h2><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。该题leetcode地址：<a href="https://leetcode-cn.com/problems/compress-string-lcci/" target="_blank" rel="noopener">字符串压缩</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = S.length();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处将S转化为字符数按下标更快</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(S.charAt(i)!=S.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">            res.append(S.charAt(i));</span><br><span class="line">            res.append(count);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(S.charAt(len-<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">        res.append(++count);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.length()&lt;len ? res.toString():S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160.拼写单词"></a>1160.拼写单词</h2><p>给你一份『词汇表』（字符串数组） <code>words</code> 和一张『字母表』（字符串） <code>chars</code>。假如你可以用 <code>chars</code> 中的『字母』（字符）拼写出 <code>words</code> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。返回词汇表 <code>words</code> 中你掌握的所有单词的 <strong>长度之和</strong>。注意：每次拼写时，<code>chars</code> 中的每个字母都只能用一次。该题leetcode地址：<a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">拼写单词</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把每个字母的频率存下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dic = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars==<span class="keyword">null</span> || chars.length()==<span class="number">0</span> || words==<span class="keyword">null</span> || words.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars.toCharArray())&#123;</span><br><span class="line">            dic[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chars.length() &gt;= words[i].length() &amp;&amp; isLearned(words[i].toCharArray()))&#123;</span><br><span class="line">                lenSum += words[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLearned</span><span class="params">(<span class="keyword">char</span>[] word)</span></span>&#123;</span><br><span class="line">        <span class="comment">//每个单词的临时表</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length;i++)&#123;</span><br><span class="line">            temp[word[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(temp[word[i]-<span class="string">'a'</span>]&gt;dic[word[i]-<span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.dfs（时间超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">boolean</span>[] learned;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars==<span class="keyword">null</span> || chars.length()==<span class="number">0</span> || words==<span class="keyword">null</span> || words.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length()];</span><br><span class="line">        learned = <span class="keyword">new</span> <span class="keyword">boolean</span>[words.length];</span><br><span class="line">        <span class="keyword">char</span>[] dic = chars.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">            countCharactersHelper(words[i].toCharArray(),i,dic,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countCharactersHelper</span><span class="params">(<span class="keyword">char</span>[] word,<span class="keyword">int</span> index,<span class="keyword">char</span>[] chars,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(learned[index])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==word.length)&#123;</span><br><span class="line">            lenSum += word.length;</span><br><span class="line">            learned[index] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || chars[i]!=word[start])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            countCharactersHelper(word,index,chars,start+<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="836-矩阵重叠"><a href="#836-矩阵重叠" class="headerlink" title="836.矩阵重叠"></a>836.矩阵重叠</h2><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。判断两矩阵是否重叠。</p><p><code>输入：rec1=[0,0,2,2],rec2=[1,1,3,3]。输出：true</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.两矩阵重叠可分为两部分，在xy两轴上的投影都相交。</span></span><br><span class="line"><span class="comment">//对于线段(x1,x2)和(x3,x4)，</span></span><br><span class="line"><span class="comment">//当min(x2,x4)&gt;max(x1,x3)时重叠</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rec1.length!=<span class="number">4</span> || rec2.length!=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x轴投影相交</span></span><br><span class="line">    <span class="keyword">return</span> rec1[<span class="number">0</span>]&lt;rec2[<span class="number">2</span>]&amp;&amp;rec1[<span class="number">2</span>]&gt;rec2[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">//y轴投影相交</span></span><br><span class="line">        &amp;&amp;rec1[<span class="number">1</span>]&lt;rec2[<span class="number">3</span>]&amp;&amp;rec1[<span class="number">3</span>]&gt;rec2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.还可以考虑相反的情况，不重叠</span></span><br><span class="line"><span class="comment">//不重叠rec1一定在rec2的上下左右一侧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]<span class="comment">//rec2在rec1右边</span></span><br><span class="line">                ||rec1[<span class="number">3</span>]&lt;=rec2[<span class="number">1</span>]<span class="comment">//rec2在rec1上边</span></span><br><span class="line">                ||rec1[<span class="number">0</span>]&gt;=rec2[<span class="number">2</span>]<span class="comment">//rec2在rec1左边</span></span><br><span class="line">                ||rec1[<span class="number">1</span>]&gt;=rec2[<span class="number">3</span>]);<span class="comment">//rec2在rec1下边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。leetcode地址：<a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">最长回文串</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : cs)&#123;</span><br><span class="line">        arr[c-<span class="string">'A'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> remain = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">58</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr[i]/<span class="number">2</span>;</span><br><span class="line">        res += n*<span class="number">2</span>;</span><br><span class="line">        arr[i]=arr[i]%<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!remain &amp;&amp; arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            remain = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(remain)&#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a>面试题40. 最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。用最大堆实现。</p><h2 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="365.水壶问题"></a>365.水壶问题</h2><p>有两个容量分别为 x升和y升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好z升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的z升水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.深度优先搜索</span></span><br><span class="line"><span class="comment">//空间时间都为O(xy)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//深度优先遍历两个水壶所有可能的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x+y&lt;z)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Pair&gt; reachable = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stack&lt;Pair&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Pair init = <span class="keyword">new</span> Pair(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        stack.push(init);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            Pair cur = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> remainX = cur.first;</span><br><span class="line">            <span class="keyword">int</span> remainY = cur.second;</span><br><span class="line">            <span class="keyword">if</span>(remainX==z || remainY==z || remainX+remainY==z)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(reachable.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reachable.add(cur);</span><br><span class="line">            <span class="comment">//把x填满</span></span><br><span class="line">            <span class="keyword">if</span>(remainX &lt; x)&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pair(x,remainY));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把y填满</span></span><br><span class="line">            <span class="keyword">if</span>(remainY &lt; y)&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pair(remainX,y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//清空x</span></span><br><span class="line">            stack.push(<span class="keyword">new</span> Pair(<span class="number">0</span>,remainY));</span><br><span class="line">            <span class="comment">//清空y</span></span><br><span class="line">            stack.push(<span class="keyword">new</span> Pair(remainX,<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//把x的倒入到y中，y满或者x空为止</span></span><br><span class="line">            <span class="keyword">int</span> acceptableY = y-remainY;</span><br><span class="line">            <span class="keyword">if</span>(remainX&gt;<span class="number">0</span> &amp;&amp; acceptableY&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(remainX &lt;= acceptableY)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(<span class="number">0</span>,remainY+remainX));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(remainX-acceptableY,y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把y的倒入到x中,x满或者y空为止</span></span><br><span class="line">            <span class="keyword">int</span> acceptableX = x-remainX;</span><br><span class="line">            <span class="comment">//如果y中还有水，且x没满</span></span><br><span class="line">            <span class="keyword">if</span>(remainY&gt;<span class="number">0</span> &amp;&amp; acceptableX&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(remainY &lt;= acceptableX)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(remainY+remainX,<span class="number">0</span>));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Pair(x,remainY-acceptableX));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span> <span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set去重是需要比较hashcode和内容，故需要重写这两个方法</span></span><br><span class="line">    <span class="comment">//保证first和second相同时，两个Pair也相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Pair pair = (Pair) o;</span><br><span class="line">        <span class="keyword">return</span> first == pair.first &amp;&amp;</span><br><span class="line">                second == pair.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(first)+Objects.hash(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>数学方法：每次倒水都会给水的总量带来x或者y的变化量，因为</p><ul><li>两桶水不可能同时有水且不满，题目要求的操作都是至少一个是满的或者空的。</li><li>对一个不满的桶加水会回到初始状态，没有意义</li><li>把一个不满的桶的水倒掉也会回到初始状态，没有意义。</li></ul><p>所以在每次操作都会给两桶水总量带来x或者y的变化，即找到$ax+by=z$。</p><p>而贝祖定理告诉我们，$ax+by=z$ 有解当且仅当$z$是$x$,$y$的最大公约数的倍数。因此我们只需要找到 x, y<em>x</em>,<em>y</em> 的最大公约数并判断 z<em>z</em> 是否是它的倍数即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x+y&lt;z)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span> || y==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> z==<span class="number">0</span> || x+y==z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z % gcd(x,y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp%y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a>面试题 17.16. 按摩师</h2><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。与打家劫舍类似。地址：<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">按摩师</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，时间空间O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = dp[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">        max = Math.max(max,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化空间为O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> former = <span class="number">0</span>,latter = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = latter;</span><br><span class="line">        latter = Math.max(former+nums[i],latter);</span><br><span class="line">        former = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> latter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892.三维形体的表面积"></a>892.三维形体的表面积</h2><p>在 N <em> N 的网格上，我们放置一些 1 </em> 1 * 1  的立方体。每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。请你返回最终形体的表面积。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里采用的是加法，算出每个位置与上下左右相比没有被覆盖的部分相加。</span></span><br><span class="line"><span class="comment">//也可采用减法，时间O(n^2),空间O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] directionX = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] directionY = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = i + directionX[k];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + directionY[k];</span><br><span class="line">                    <span class="keyword">int</span> neatHeight = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;m &amp;&amp; newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;n)&#123;</span><br><span class="line">                        neatHeight = grid[newX][newY];</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    res += Math.max(grid[i][j]-neatHeight,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><p>给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><p>每组都有 X 张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X &gt;= 2 时返回 true。</p><blockquote><p>示例：<br>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p><p>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。</p></blockquote><p>分析：共n个数字，分成若干组，每组的数量都为x且每组内数字都相同。首先n一定能被x整除，且如果能成功分组，则每种数字的数量也可被x整除。所以就是一个寻找最大公约数的过程。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种暴力遍历，时间O(mn)，m为种数（10000）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deck==<span class="keyword">null</span> || deck.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储每种数字的数量</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:deck)&#123;</span><br><span class="line">        count[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = deck.length;</span><br><span class="line">    <span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//暴力判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count[j]%i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    isFound = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                isFound = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFound)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用最大公约数，O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasmGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deck==<span class="keyword">null</span> || deck.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:deck)&#123;</span><br><span class="line">        count[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gcd = count[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            gcd = gcd(gcd,count[i]);</span><br><span class="line">            <span class="comment">//可放在最后判断</span></span><br><span class="line">            <span class="keyword">if</span>(gcd==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp%y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="820-单词的压缩编码"><a href="#820-单词的压缩编码" class="headerlink" title="820. 单词的压缩编码"></a>820. 单词的压缩编码</h2><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">单词的压缩编码</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(words, (o1, o2) -&gt; o2.length()-o1.length());</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s : words)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!sb.toString().contains(s+<span class="string">"#"</span>))&#123;</span><br><span class="line">            sb.append(s+<span class="string">"#"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>今天学习了一个新的知识点：<strong>字典树/前缀树</strong>。使用场景：<strong>需要大量地判断某个字符串是否是给定单词列表中的前缀/后缀</strong></p><h3 id="Trie树-字典树的实现"><a href="#Trie树-字典树的实现" class="headerlink" title="Trie树/字典树的实现"></a>Trie树/字典树的实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    TrieNode head;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head =  <span class="keyword">new</span> TrieNode(<span class="string">'r'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.children[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.children[index] = <span class="keyword">new</span> TrieNode(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        temp.isTail = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.isTail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prefix.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    <span class="keyword">boolean</span> isTail;</span><br><span class="line">    <span class="comment">//每个结点维护一个26的数组</span></span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="利用字典树优化"><a href="#利用字典树优化" class="headerlink" title="利用字典树优化"></a>利用字典树优化</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(words, (o1, o2) -&gt; o2.length()-o1.length());</span><br><span class="line">        Trie tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">            res += tree.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    TrieNode head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head =  <span class="keyword">new</span> TrieNode(<span class="string">'r'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//稍加修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">boolean</span> isNew = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = cur-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.children[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                isNew = <span class="keyword">true</span>;</span><br><span class="line">                temp.children[index] = <span class="keyword">new</span> TrieNode(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在以word[i]为后缀的单词，就不加入单词列表</span></span><br><span class="line">        <span class="keyword">return</span> isNew?len+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162.地图分析"></a>1162.地图分析</h2><p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p><p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>leetcode地址：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">地图分析</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用bfs遍历，每次只出队一层，出完一层step++，最后遍历到的那个0就是最远的海洋</span></span><br><span class="line"><span class="comment">//该方法相当于多源的最短路径，也可用单源的最短路径</span></span><br><span class="line"><span class="comment">//当前海洋到最近陆地的距离在每个单源到某一海洋的距离中取最小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span> []&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(queue.size()==<span class="number">0</span> || queue.size()==grid.length*grid.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;curSize;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur[<span class="number">0</span>],y=cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newX&lt;grid.length&amp;&amp; newX&gt;=<span class="number">0</span> &amp;&amp; newY&lt;grid.length&amp;&amp;newY&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[newX][newY]==<span class="number">0</span>)&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                        grid[newX][newY] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h2><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。leetcode地址：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a>。</p><p>分析：最直观的方法就是模拟删除的这个过程，若这一次删除的是下标index位置的元素，下一次删除的可以算出来：(index+m-1)%size；因为删除了一个元素所以下标位置要减一。第一个想到的是用LinkedList实现，但是LinkedList找第i个结点需要遍历链表。用ArrayList查找元素为O(1)但删除元素需要大量移动，故两个方案时间复杂度差不多一致。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用ArrayList实现，时间O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemainingn</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        index = (index+m-<span class="number">1</span>)%n;</span><br><span class="line">        list.remove(index);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上边用容器模拟的方法时间复杂度不太理想，下边一种数学方法可以在<code>O(n)</code>完成。最后留下的数字在当前轮次的位置为index，在上一轮的位置为(index+m)%上一轮剩下的元素个数。</p><p><a href="/posts/1dca5680/面试62.png" data-fancybox="group" data-caption="面试62" class="fancybox"><img alt="面试62" title="面试62" data-src="/posts/1dca5680/面试62.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res = (res+m)%i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><a href="/posts/1dca5680/42.png" data-fancybox="group" data-caption="面试62" class="fancybox"><img alt="面试62" style="zoom:67%;" title="面试62" data-src="/posts/1dca5680/42.png" class="lazyload"></a></p><blockquote><p>示例：<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p></blockquote><p>分析：当前位置的雨水多少取决于两边墙的高度，明显由左右两边最高的墙的较小者决定。故可以遍历每一个位置，分别算出该位置左右两边的最大值，取最小的与当前位置做差。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把每个位置的左右两边的最大值存到数组中，时间O(n)，空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = height.length;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] maxToRight = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] maxToLeft = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    maxToLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    maxToRight[len-<span class="number">1</span>] = height[len-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        maxToLeft[i] = Math.max(height[i],maxToLeft[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        maxToRight[i] = Math.max(height[i],maxToRight[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        res+=(Math.min(maxToLeft[i],maxToRight[i])-height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>分析：由于每个位置的左右两端的最大值只用一次，而且<code>maxToRight</code>和<code>maxToLeft</code>都是单调的的，且都与<code>height(right)</code>和<code>height(left)</code>相关，故可以设置两个指针left和right分别用于更新左右两端的最大值。<code>height(left)&lt;height(right)</code>时一定有<code>maxToLeft&lt;maxToRight</code>，则left位置处的雨水多少取决于maxToLeft，计算left处的雨水量，反之计算right处的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.优化空间，时间O(n)，空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = height.length;</span><br><span class="line">    <span class="keyword">int</span> maxToRight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxToLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//此时left位置处的左墙最大值一定比右墙的小</span></span><br><span class="line">        <span class="comment">//故left位置的结果只取决于maxToLeft</span></span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">            maxToLeft = Math.max(maxToLeft,height[left]);</span><br><span class="line">            res+=(maxToLeft-height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//反之亦然</span></span><br><span class="line">            maxToRight = Math.max(maxToRight,height[right]);</span><br><span class="line">            res+=(maxToRight-height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>分析3：积水可以看作是左右两端的墙构成的一个凹槽，凹槽储水的多少也是右左右两边的墙决定的，可以看作是类似括号匹配的一个过程。用栈来模拟。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = height.length;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[stack.peek()]&lt;height[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> curIdx = stack.pop();</span><br><span class="line">            <span class="comment">//可以减少一些冗余计算</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[curIdx]==height[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.peek();</span><br><span class="line">                <span class="comment">//这里计算的是curIdx位置的在</span></span><br><span class="line">                <span class="comment">//min(height[top],height[i])高度限制下的水量</span></span><br><span class="line">                res += (Math.min(height[top],height[i])-height[curIdx])*(i-top-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="460-LFU缓存（困难）"><a href="#460-LFU缓存（困难）" class="headerlink" title="460. LFU缓存（困难）"></a>460. LFU缓存（困难）</h2><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：①插入一个字符、②删除一个字符、③替换一个字符</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a>。</p><blockquote><p>示例：<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p></blockquote><p>分析：可用动态规划解决。<code>dp[i][j]</code>表示<code>word1</code>的前<code>i</code>个字符转化为和<code>word2</code>的前<code>j</code>个字符一样所需的最小步数。则可得以下转移方程：$dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i][j])+1$。括号中的三个位置分别表示删除，增加，和替换操作。</p><p>在上例基础上解释：<br><code>dp[5][3]</code>为例，即要将表示<code>word1</code>的前<code>5</code>个字符转化为和<code>word2</code>的前<code>3</code>个字符，也就是将 horse 转换为 ros，因此有：<br>(1) <code>dp[i-1][j-1]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）</p><p>(2) <code>dp[i][j-1]</code>，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</p><p>(3) <code>dp[i-1][j]</code>，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = word1.length(),len2=word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> delAndAdd = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = Math.min(delAndAdd,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(delAndAdd,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h2><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间能否做到？</p><blockquote><p>给定 matrix =<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>原地旋转输入矩阵，使其变为:<br>  [7,4,1]<br>  [8,5,2]<br>  [9,6,3]</p></blockquote><p>分析：①可以使用辅助数组，第一行存在第一列。②在不是用辅助数组的情况下，观察发现第一列的1、4、7跑到了第一行而且顺序倒置了，可以想到先沿对角线反转，第一行得到1、4、7然后每行再翻转就解决了。③还有一种方法，考虑左上角<code>（i,j）</code>位置反转90度之后再数组中的位置，之后对应的三个位置为<code>（j,n-i-1）</code>、<code>（n-i-1,n-j-1）</code>、<code>（n-j-1,i）</code>，这四个位置的元素依次后移一位即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.先对角反转，再沿垂直中线反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="comment">//先对角反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//沿垂直中线反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[i][n-j-<span class="number">1</span>];</span><br><span class="line">            matrix[i][n-j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将左上角的元素以及之后对应的元素 顺时针后移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(n+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="comment">//四个元素顺时针后移</span></span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n-j-<span class="number">1</span>][i];</span><br><span class="line">            matrix[n-j-<span class="number">1</span>][i] = matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>];</span><br><span class="line">            matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>] = matrix[j][n-i-<span class="number">1</span>];</span><br><span class="line">            matrix[j][n-i-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。该题leetcode地址：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p><blockquote><p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p></blockquote><p>分析：参考<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">这里</a>。</p><p><a href="/posts/1dca5680/22.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/1dca5680/22.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.深度优先（回溯）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    generateParenthesisDFS(<span class="string">""</span>,n,n,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateParenthesisDFS</span><span class="params">(String curStr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(curStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)&#123;<span class="comment">//递归剪枝</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        generateParenthesisDFS(curStr+<span class="string">"("</span>,left-<span class="number">1</span>,right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        generateParenthesisDFS(curStr+<span class="string">")"</span>,left,right-<span class="number">1</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>深度优先遍历不需要显示使用栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显示使用栈。广度优先遍历需要显式的使用队列这个数据结构。以广度优先遍历实现时，需要定义一个结点类，来保存与上边DFS类似的状态信息，即当前剩余的左右括号数等。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuffixNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    String curStr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuffixNode</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String curStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.curStr = curStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    SuffixNode root = <span class="keyword">new</span> SuffixNode(n,n,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//把这里的队列换成栈就成了深度优先遍历</span></span><br><span class="line">    Queue&lt;SuffixNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        SuffixNode cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(cur.left==<span class="number">0</span> &amp;&amp; cur.right==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(cur.curStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.left&gt;<span class="number">0</span> &amp;&amp; cur.left-<span class="number">1</span>&lt;=cur.right)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> SuffixNode(cur.left-<span class="number">1</span>,cur.right,cur.curStr+<span class="string">"("</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right&gt;<span class="number">0</span> &amp;&amp; cur.left&lt;=cur.right-<span class="number">1</span>)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> SuffixNode(cur.left,cur.right-<span class="number">1</span>,cur.curStr+<span class="string">")"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>动态规划：由<code>i</code>对括号组成的序列，与由<code>i-1</code>对括号组成的序列有关。其中<code>dp[i-1]</code>是个列表</p><blockquote><p>dp[i] = “(“ + dp[i-1可能的括号对数] + “)” + dp[i-1剩下的括号对数]</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中把dp[i-1]拆分需要用到i-1之前的括号组合序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; dp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; dp0 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dp0.add(<span class="string">""</span>);</span><br><span class="line">    dp.add(dp0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            List&lt;String&gt; component = dp.get(j);</span><br><span class="line">            List&lt;String&gt; remain = dp.get(i-j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(String comp:component)&#123;</span><br><span class="line">                <span class="keyword">for</span>(String re:remain)&#123;</span><br><span class="line">                    cur.add(<span class="string">"("</span>+comp+<span class="string">")"</span>+re);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。，其中多余的空格删除</p><blockquote><p>示例：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>输入: “  hello  world!  “<br>输出: “world! hello”</p></blockquote><p>先把每个单词分隔出来，存在一个数组里，再将数组反转，用空格连接每个单词。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用JDK的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除去开头结尾的空格</span></span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="comment">//用正则表达式，一个或多个空格分割字符串</span></span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(s.split(<span class="string">"\\s+"</span>));</span><br><span class="line">    <span class="comment">//集合反转</span></span><br><span class="line">    Collections.reverse(words);</span><br><span class="line">    <span class="comment">//用空格连接每个单词</span></span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">" "</span>, words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887.鸡蛋掉落"></a>887.鸡蛋掉落</h2><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code> 共有 <code>N</code> 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次<em>移动</em>，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.二分法，时间复杂度O(NKlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop1</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        Arrays.fill(dp[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=K;j++)&#123;</span><br><span class="line">            <span class="comment">//二分查找最小查找次数</span></span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">1</span>,right=i,mid=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid-<span class="number">1</span>][j-<span class="number">1</span>]&lt;dp[i-mid][j])&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[mid-<span class="number">1</span>][j-<span class="number">1</span>]&gt;dp[i-mid][j])&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最坏情况</span></span><br><span class="line">            dp[i][j] = Math.max(dp[mid-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-mid][j])+<span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"["</span>+i+<span class="string">","</span>+j+<span class="string">"]:"</span>+dp[i][j]+ <span class="string">"---"</span>+mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a>542.01矩阵</h2><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。leetcode地址：<a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">01 矩阵</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最开始用回溯递归去做，陷入了循环递归，造成栈溢出。</span></span><br><span class="line"><span class="comment">//后来发现跟以前做过的一个多源最短路径差不多</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=matrix.length,n=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span> []&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                matrix[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(queue.size()==m*n)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">        step++;</span><br><span class="line">        <span class="comment">//一次性将一层的结点都出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;curSize;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur[<span class="number">0</span>],y=cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newX&lt;m&amp;&amp; newX&gt;=<span class="number">0</span> &amp;&amp; newY&lt;n&amp;&amp;newY&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[newX][newY]==<span class="number">1</span>)&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);</span><br><span class="line">                        matrix[newX][newY] = <span class="number">2</span>;</span><br><span class="line">                        res[newX][newY] = step;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。地址：<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间O(nlogn),为排序的时间</span></span><br><span class="line"><span class="comment">//首先想到的这个方法思路没问题，但是用了一个list再转为int[][]，白白浪费了n的空间</span></span><br><span class="line"><span class="comment">//可以直接用int[][]保存结果。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals.length==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = intervals.length;</span><br><span class="line">    <span class="comment">//把这些区间按照左端点进行升序排序</span></span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] pre = intervals[i];</span><br><span class="line">        <span class="comment">//每拿到一个区间i,都从i开始往后遍历寻找能重合的区间</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;len &amp;&amp; !(pre[<span class="number">1</span>]&lt;intervals[j][<span class="number">0</span>]))&#123;</span><br><span class="line">            <span class="keyword">int</span>[] next = intervals[j];</span><br><span class="line">            <span class="keyword">if</span>(next[<span class="number">1</span>]&gt;pre[<span class="number">1</span>] &amp;&amp; next[<span class="number">0</span>]&lt;=pre[<span class="number">1</span>])&#123;</span><br><span class="line">                pre[<span class="number">1</span>] = next[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; newEle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        newEle.add(pre[<span class="number">0</span>]);</span><br><span class="line">        newEle.add(pre[<span class="number">1</span>]);</span><br><span class="line">        res.add(newEle);</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;size;k++)&#123;</span><br><span class="line">        ans[k][<span class="number">0</span>] = res.get(k).get(<span class="number">0</span>);</span><br><span class="line">        ans[k][<span class="number">1</span>] = res.get(k).get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p>分析：并查集</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Union</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">int</span>[] rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Union</span><span class="params">(<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m = grid.length;</span><br><span class="line">            <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        parent[i*n+j] = i*n+j;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rank[i*n+j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != parent[cur])&#123;</span><br><span class="line">                cur = parent[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = findRoot(first);</span><br><span class="line">            <span class="keyword">int</span> root2 = findRoot(second);</span><br><span class="line">            <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rank[root1] &gt; rank[root2])&#123;</span><br><span class="line">                    parent[root2] = root1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rank[root1] &lt; rank[root2])&#123;</span><br><span class="line">                    parent[root1] = root2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent[root2] = root1;</span><br><span class="line">                    rank[root1]++;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        Union un = <span class="keyword">new</span> Union(grid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;row;r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;col;c++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[r][c]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(r-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,(r-<span class="number">1</span>)*col+c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(r+<span class="number">1</span>&lt;row &amp;&amp; grid[r+<span class="number">1</span>][c]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,(r+<span class="number">1</span>)*col+c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(c-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,r*col+c-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(c+<span class="number">1</span>&lt;col &amp;&amp; grid[r][c+<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                        un.union(r*col+c,r*col+c+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> un.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248.统计「优美子数组」"></a>1248.统计「优美子数组」</h2><p>给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。leetcode地址：<a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">统计「优美子数组」</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把所有奇数得坐标存下来，时间空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] odd = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    odd[idx++]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">            odd[idx++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    odd[idx]=len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;idx;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = i+k-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(next&gt;=idx)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里从第i个奇数到i+k-1满足k个奇数得条件</span></span><br><span class="line">        <span class="comment">//分别向左扩展值前一个奇数的位置，向后扩展至后一个奇数的位置</span></span><br><span class="line">        res += (odd[i]-odd[i-<span class="number">1</span>])*(odd[next+<span class="number">1</span>]-odd[next]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.统计以第i个数字结尾的奇数个数即为oddNum</span></span><br><span class="line"><span class="comment">//查找j&lt;i,且以j结尾的奇数个数为oddNum-k的子数组个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> oddNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        oddNum += (nums[i]&amp;<span class="number">1</span>);</span><br><span class="line">        res += (oddNum&gt;=k)? cnt[oddNum-k]:<span class="number">0</span>;</span><br><span class="line">        cnt[oddNum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="23-合并k个排序链表"><a href="#23-合并k个排序链表" class="headerlink" title="23.合并k个排序链表"></a>23.合并k个排序链表</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.分治。两两合并，结构上为一颗合并树，时间复杂度为O(knlogk)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//两两合并</span></span><br><span class="line">        ListNode res1 = merge(lists,l,mid);</span><br><span class="line">        ListNode res2 = merge(lists,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode head1,ListNode head2)</span></span>&#123;    </span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="keyword">null</span>&amp;&amp;head2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;=head2.val)&#123;</span><br><span class="line">                p.next = head1;</span><br><span class="line">                p = p.next;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = head2;</span><br><span class="line">                p = p.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = head1==<span class="keyword">null</span> ? head2:head1;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用堆，每次选出头结点值最小的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((l1,l2)-&gt;l1.val-l2.val);</span><br><span class="line">    <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = newHead;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ListNode top = queue.poll();</span><br><span class="line">        p.next = top;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span>(top.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(top.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><blockquote><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.深度优先，相当于暴力解，超时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>,nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一步一步判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums[cur];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(cur+i,nums))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.实际情况是不用一步一步判断x能否准确到达位置y，如果x+nums[x]&gt;y则x即可到y</span></span><br><span class="line"><span class="comment">//用一个变量保存当前可达的最远位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//位置i在当前可达范围内</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=max)&#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = i+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curMax&gt;max)&#123;</span><br><span class="line">                max = curMax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最后一个位置可达</span></span><br><span class="line">            <span class="keyword">if</span>(max&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><blockquote><p>输入:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>输出: 4</p></blockquote><p>$dp(i,j)$表示以$matrix(i,j)$为右下角的最大正方形的边长。</p><script type="math/tex; mode=display">dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1.</script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m =matrix.length, n =matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxRes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                maxRes = Math.max(maxRes,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxRes*maxRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h2><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><blockquote><p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>]; </span><br><span class="line">    <span class="comment">//sum[i]表示从0-i元素的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>;left&lt;nums.length;left++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=left+<span class="number">1</span>;right&lt;=nums.length;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[right]-sum[left]==k)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>分析：在上述暴力解法中，对于每个位置<code>i</code>都需要遍历后续所有位置<code>j</code>（或者对每个的<code>j</code>都需遍历前边的所有位置<code>i</code>）寻找满足<code>sum[j]-sum[i]==k</code>。换种思考方式，<strong>前缀和</strong>即对于每个位置<code>i</code>，<code>0...i</code>的和为<code>sum[i]</code>，即寻找所有的<code>j(0≤j≤i)</code>满足<code>sum[j]=sum[i]-k</code>的位置，即统计满足该条件的<code>j</code>的个数，故可以用Map存储该数据。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        count += map.getOrDefault(sum-k,<span class="number">0</span>);</span><br><span class="line">        map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a>1371. 每个元音包含偶数次的最长子字符串</h2><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。leetcode地址：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">每个元音包含偶数次的最长子字符串</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀和，思想基本和560类似</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前缀和，记录当前状态出现的最早位置</span></span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    Arrays.fill(pos,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    pos[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'a'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'e'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'i'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'o'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'u'</span>)&#123;</span><br><span class="line">            status^=(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos[status]==-<span class="number">1</span>)&#123;</span><br><span class="line">            pos[status] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = Math.max(res,i+<span class="number">1</span>-pos[status]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h2><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？leetcode地址：<a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">课程表</a>。</p><p><strong>分析</strong>：课程的先修关系明显可以转换为图的关系，先修关系表示为后续节点，没有先修关系即没有后续节点的课程（即入度为0）先修，随后再修改图，若所有课程均可完成，则返回true。故可转化为判断有向无环图的问题上。即通过拓扑排序的思想进行判断。<br><strong>拓扑排序原理</strong>： 对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)，均有 u（在排序记录中）比 v 先出现。也可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。</p><p><strong>注</strong>：若要返回拓扑排序结果只需稍作修改即可。</p><h3 id="方法一-根据入度表进行广度优先遍历"><a href="#方法一-根据入度表进行广度优先遍历" class="headerlink" title="方法一.根据入度表进行广度优先遍历"></a>方法一.根据入度表进行广度优先遍历</h3><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 O(N + M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；</li><li>空间复杂度 O(N + M)： 为建立邻接表所需额外空间，邻接表长度为 N ，并存储 M 条临边的数据。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序思想判断是否是有向无环图</span></span><br><span class="line"><span class="comment">//需通过节点的入度进行操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将所给prerequisites数组转换成图的形式,表示的为节点之间</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(numCourses);</span><br><span class="line">    <span class="comment">//graph(i)表示节点i的后续节点集合，即邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化每个节点的入度</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] cur : prerequisites)&#123;</span><br><span class="line">        indegree[cur[<span class="number">0</span>]]++;</span><br><span class="line">        graph.get(cur[<span class="number">1</span>]).add(cur[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化节点之间的相连关系</span></span><br><span class="line">    <span class="comment">//用队列辅助广度遍历</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//每出队一个，减少一个入度为0的节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph.get(cur))&#123;</span><br><span class="line">            <span class="keyword">if</span>(--indegree[next]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有节点都出队，没有环</span></span><br><span class="line">    <span class="keyword">return</span> numCourses==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="方法二-深度优先遍历（有点不太理解）"><a href="#方法二-深度优先遍历（有点不太理解）" class="headerlink" title="方法二. 深度优先遍历（有点不太理解）"></a>方法二. 深度优先遍历（有点不太理解）</h3><p>通过DFS判断是否有环</p><p>每个节点设置flag标志位，若没访问为0，访问过一次为1，两次为-1。</p><p>对 numCourses 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 False。<br>DFS 流程；</p><ul><li><p>终止条件：<br>当 flag[i] == 1，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 True。<br>当 flag[i] == -1，说明在本轮 DFS 搜索中节点 i 被第 2 次访问，即 课程安排图有环 ，直接返回 False。</p></li><li><p>将当前访问节点 i 对应 flag[i] 置 1，即标记其被本轮 DFS 访问过；</p></li><li><p>递归访问当前节点 i 的所有邻接节点 j，当发现环直接返回 FalseFalse；</p></li><li>当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 flag 置为 −1 并返回 True。</li></ul><p>若整个图 DFS 结束并未发现环，返回 TrueTrue。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将所给prerequisites数组转换成图的形式,表示的为节点之间</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(numCourses);</span><br><span class="line">    <span class="comment">//graph(i)表示节点i的后续节点集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] cur : prerequisites)&#123;</span><br><span class="line">        graph.get(cur[<span class="number">1</span>]).add(cur[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsHelper(graph,flag,i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfsHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph,<span class="keyword">int</span>[] flag,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[index]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag[index]==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[index]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> next : graph.get(index))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfsHelper(graph,flag,next))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[index]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a>.</p><blockquote><p>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”</p></blockquote><p>复杂度分析<br>时间：$O(|S|+|T|)$。空间：$O(|S|+|T|)$</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">    <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">    <span class="keyword">char</span>[] sChars = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] tChars = t.toCharArray();</span><br><span class="line">    <span class="comment">//s的字串中包含每个字符的频次</span></span><br><span class="line">    <span class="keyword">int</span>[] sFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//t中包含每个字符的频次</span></span><br><span class="line">    <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//初始化tFreq数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> tc : tChars)&#123;</span><br><span class="line">        tFreq[tc]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s的包含t所有字符的最小字串长度</span></span><br><span class="line">    <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最小字串开始位置</span></span><br><span class="line">    <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录当前s子串中t中字符出现的个数</span></span><br><span class="line">    <span class="keyword">int</span> containNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//滑动窗口左右边界</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">char</span> rightChar = sChars[right];</span><br><span class="line">        <span class="comment">//若s中的当前字符在t中未出现，right向右移动</span></span><br><span class="line">        <span class="keyword">if</span>(tFreq[rightChar]==<span class="number">0</span>)&#123;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sFreq[rightChar] &lt; tFreq[rightChar])&#123;</span><br><span class="line">            <span class="comment">//若s中的当前字符在t中出现了</span></span><br><span class="line">            <span class="comment">//且在当前s子串中出现的次数少于t</span></span><br><span class="line">            containNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只要当前字符在t中出现了，更新子串中的频次表</span></span><br><span class="line">        sFreq[rightChar]++;</span><br><span class="line">        <span class="comment">//right向右移动，保持当前子串为[left,right)</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(containNum==tLen)&#123;</span><br><span class="line">            <span class="comment">//当前字串区间为[left,right)</span></span><br><span class="line">            <span class="keyword">if</span>(minLen &gt; right - left)&#123;</span><br><span class="line">                minLen = right - left;</span><br><span class="line">                minStart = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> leftChar = sChars[left];</span><br><span class="line">            <span class="keyword">if</span>(tFreq[leftChar]==<span class="number">0</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sFreq[leftChar] == tFreq[leftChar]) &#123;</span><br><span class="line">                containNum--; </span><br><span class="line">            &#125;</span><br><span class="line">            sFreq[leftChar]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minLen == sLen+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(minStart,minStart+minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a>.</p><p><strong>分析</strong></p><ul><li>1.可用归并排序先组合再找中位数。</li><li>2.可元素大小顺序查找两个数组中在位置<code>(len1+len2)/2</code>的元素。</li><li>3.用二分查找，在两个数组中分别寻找分割线，使得两个数组分别在其分割线左边的元素为<code>(len1+len2+1)/2</code>个，如果总数为奇数，左边比右边多一个，且满足<code>nums1[i] &gt;= nums1[j-1] &amp;&amp; nums1[i-1] &lt;= nums1[j]</code>。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换的目的是保证第二个数组在分割线的两侧都有元素不会越界</span></span><br><span class="line">    <span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别在两个数组中查找分割线</span></span><br><span class="line">    <span class="comment">// 使得两个数组在分割线左边的元素总数为总个数的一半，向上取整</span></span><br><span class="line">    <span class="comment">// 防止整形溢出可以写成 len1 + (len2 - len1 +1)/2</span></span><br><span class="line">    <span class="keyword">int</span> totalLeft = (len1 + len2 + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在nums1的[0,len1]寻找分割线i</span></span><br><span class="line">    <span class="comment">// i==0表示分割线左边没有元素,i==len1表示分割线右边没有元素</span></span><br><span class="line">    <span class="comment">// i表示nums1中右部数组的起始位置</span></span><br><span class="line">    <span class="comment">// 使得nums1[i] &gt;= nums1[j-1] &amp;&amp; nums1[i-1] &lt;= nums1[j]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len1;</span><br><span class="line">    <span class="comment">//退出循环时left==right</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">//nums1分割线左边有i个元素</span></span><br><span class="line">        <span class="keyword">int</span> i = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//限制nums2分割线位置</span></span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt; nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">// 下轮搜索区间[i+1,right]</span></span><br><span class="line">            <span class="comment">// 只有两个元素时[left(mid),right]不会死循环</span></span><br><span class="line">            left = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//下轮搜索区间[left,i]</span></span><br><span class="line">            right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = totalLeft - i ;</span><br><span class="line">    <span class="comment">//i==0表示分割线左边没有值</span></span><br><span class="line">    <span class="keyword">int</span> nums1MaxLeft = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//i==len1表示分割线右边没有值</span></span><br><span class="line">    <span class="keyword">int</span> nums1MinRight = i == len1 ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">    <span class="keyword">int</span> nums2MaxLeft = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> nums2MinRight = j == len2 ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">    <span class="keyword">if</span>((len1 + len2)%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums1MaxLeft,nums2MaxLeft);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)Math.max(nums1MaxLeft,nums2MaxLeft) + Math.min(nums1MinRight,nums2MinRight))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="面试题-16-18-模式匹配"><a href="#面试题-16-18-模式匹配" class="headerlink" title="面试题 16.18. 模式匹配"></a>面试题 16.18. 模式匹配</h2><p>你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。<a href="https://leetcode-cn.com/problems/pattern-matching-lcci/" target="_blank" rel="noopener">面试题 16.18. 模式匹配</a></p><p>分析：统计a和b的个数，枚举所有可能的a的长度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">patternMatching</span><span class="params">(String pattern, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count_a = <span class="number">0</span>,count_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len_v = value.length();</span><br><span class="line">    <span class="keyword">for</span>(Character c : pattern.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'a'</span>)&#123;</span><br><span class="line">            count_a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count_b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count_a+<span class="string">"====="</span>+count_b);</span><br><span class="line">    System.out.println(<span class="string">"before==="</span>+pattern);</span><br><span class="line">    <span class="keyword">if</span>(count_a&lt;count_b)&#123;  <span class="comment">//防止下边for循环len_a=0除数为0</span></span><br><span class="line">        <span class="keyword">int</span> temp = count_a;</span><br><span class="line">        count_a = count_b;</span><br><span class="line">        count_b = temp;</span><br><span class="line">        <span class="keyword">char</span>[] chars =pattern.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pattern.length();i++)&#123;</span><br><span class="line">            chars[i] = chars[i]==<span class="string">'a'</span> ? <span class="string">'b'</span> : <span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pattern = <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len_v==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> count_b==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"after==="</span>+pattern);</span><br><span class="line">    <span class="keyword">int</span> len_a, len_b;</span><br><span class="line">    <span class="keyword">for</span>(len_a=<span class="number">0</span>;len_a*count_a&lt;=len_v;len_a++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> remain = len_v-count_a*len_a;</span><br><span class="line">        String sub_a=<span class="string">""</span>,sub_b=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((count_b==<span class="number">0</span>&amp;&amp;remain==<span class="number">0</span>) || (count_b!=<span class="number">0</span>&amp;&amp;remain%count_b==<span class="number">0</span>))&#123;</span><br><span class="line">            len_b = count_b==<span class="number">0</span>?<span class="number">0</span>:remain/count_b;</span><br><span class="line">            <span class="keyword">for</span>(Character c : pattern.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">'a'</span>)&#123;</span><br><span class="line">                    String cur_sub = value.substring(pos,pos+len_a);</span><br><span class="line">                    <span class="keyword">if</span>(sub_a.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                        sub_a = cur_sub;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!sub_a.equals(cur_sub))&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pos += len_a;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    String cur_sub = value.substring(pos,pos+len_b);</span><br><span class="line">                    <span class="keyword">if</span>(sub_b.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                        sub_b = cur_sub;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!sub_b.equals(cur_sub))&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pos += len_b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sub_a+<span class="string">"----"</span>+sub_b+<span class="string">"---"</span>+!sub_a.equals(sub_b));</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="keyword">true</span> &amp;&amp; !sub_a.equals(sub_b))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1071-字符串的最大公因子&quot;&gt;&lt;a href=&quot;#1071-字符串的最大公因子&quot; class=&quot;headerlink&quot; title=&quot;1071.字符串的最大公因子&quot;&gt;&lt;/a&gt;1071.字符串的最大公因子&lt;/h2&gt;&lt;p&gt;对于字符串 S 和 T，只有在 S = T 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>java中的各种数组相互转化</title>
    <link href="https://jwkang99.github.io/posts/bda51021.html"/>
    <id>https://jwkang99.github.io/posts/bda51021.html</id>
    <published>2020-03-11T16:02:24.000Z</published>
    <updated>2020-03-18T14:46:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>刷题的时候发现java的int[]、Integer[]、ArrayList转化这方面比较陌生。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// int[] 转 List&lt;Integer&gt;</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.stream(data).boxed().collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// Arrays.stream(arr) 可以替换成IntStream.of(arr)。</span></span><br><span class="line">        <span class="comment">// 1.使用Arrays.stream将int[]转换成IntStream。</span></span><br><span class="line">        <span class="comment">// 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream&lt;Integer&gt;。</span></span><br><span class="line">        <span class="comment">// 3.使用Stream的collect()，将Stream&lt;T&gt;转换成List&lt;T&gt;，因此正是List&lt;Integer&gt;。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// int[] 转 Integer[]</span></span><br><span class="line">        Integer[] integers1 = Arrays.stream(data).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="comment">// 前两步同上，此时是Stream&lt;Integer&gt;。</span></span><br><span class="line">        <span class="comment">// 然后使用Stream的toArray，传入IntFunction&lt;A[]&gt; generator。</span></span><br><span class="line">        <span class="comment">// 这样就可以返回Integer数组。</span></span><br><span class="line">        <span class="comment">// 不然默认是Object[]。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; 转 Integer[]</span></span><br><span class="line">        Integer[] integers2 = list1.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//  调用toArray。传入参数T[] a。这种用法是目前推荐的。</span></span><br><span class="line">        <span class="comment">// List&lt;String&gt;转String[]也同理。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; 转 int[]</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="comment">// 想要转换成int[]类型，就得先转成IntStream。</span></span><br><span class="line">        <span class="comment">// 这里就通过mapToInt()把Stream&lt;Integer&gt;调用Integer::valueOf来转成IntStream</span></span><br><span class="line">        <span class="comment">// 而IntStream中默认toArray()转成int[]。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Integer[] 转 int[]</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.stream(integers1).mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="comment">// 思路同上。先将Integer[]转成Stream&lt;Integer&gt;，再转成IntStream。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Integer[] 转 List&lt;Integer&gt;</span></span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(integers1);</span><br><span class="line">        <span class="comment">// 最简单的方式。String[]转List&lt;String&gt;也同理。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        String[] strings1 = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        <span class="comment">// String[] 转 List&lt;String&gt;</span></span><br><span class="line">        List&lt;String&gt; list3 = Arrays.asList(strings1);</span><br><span class="line">        <span class="comment">// List&lt;String&gt; 转 String[]</span></span><br><span class="line">        String[] strings2 = list3.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刷题的时候发现java的int[]、Integer[]、ArrayList转化这方面比较陌生。&lt;/p&gt;
&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight-tools&quot;&gt;&lt;i class=&quot;fa fa-angle-down c
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java实现读写锁</title>
    <link href="https://jwkang99.github.io/posts/12c3d10b.html"/>
    <id>https://jwkang99.github.io/posts/12c3d10b.html</id>
    <published>2020-03-07T07:09:06.000Z</published>
    <updated>2020-07-10T09:43:15.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> read;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> write;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.write = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(write&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        read++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        read--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(read&gt;<span class="number">0</span>||write&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        write++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        write--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="版本二（避免饿死）"><a href="#版本二（避免饿死）" class="headerlink" title="版本二（避免饿死）"></a>版本二（避免饿死）</h3><p>版本一有一个致命缺点就是，可能会导致写线程饿死。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> reader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> write;</span><br><span class="line">    <span class="comment">//实现写优先</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (write &gt; <span class="number">0</span> || writeRequests &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        reader++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reader--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        writeRequests++;</span><br><span class="line">        <span class="keyword">while</span> (reader &gt; <span class="number">0</span> || write &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        writeRequests--;</span><br><span class="line">        write++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        write--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="版本三（读读重入）"><a href="#版本三（读读重入）" class="headerlink" title="版本三（读读重入）"></a>版本三（读读重入）</h3><p>版本二中，对于写线程再去获取读锁，读线程获取写锁，写线程再次获取写锁都无法处理，还会出现死锁的情况。下边处理读读重入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存当前正在读的线程，保证读读可重入</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread,Integer&gt; readingThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> reader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writerRequest;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reader = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.writer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.writerRequest=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.readingThread = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(!isAccessRead(curThread))&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        readingThread.put(curThread,</span><br><span class="line">                          readingThread.getOrDefault(curThread,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccessRead</span><span class="params">(Thread t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//以下判断顺序 在写优先的基础上，</span></span><br><span class="line">        <span class="comment">//只允许已经在读的线程读优先级高于写操作</span></span><br><span class="line">        <span class="keyword">if</span>(writer&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(readingThread.get(t)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放在第三个判断可避免写线程和重读线程死锁</span></span><br><span class="line">        <span class="keyword">if</span>(writerRequest&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> cnt = readingThread.get(curThread);</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            readingThread.remove(curThread);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            readingThread.put(curThread,cnt-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        writerRequest++;</span><br><span class="line">        <span class="keyword">while</span>(writer&gt;<span class="number">0</span> || readingThread.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        writerRequest--;</span><br><span class="line">        writer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writer--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="版本四（写写重入）"><a href="#版本四（写写重入）" class="headerlink" title="版本四（写写重入）"></a>版本四（写写重入）</h3><p>对于同一个线程先后两次申请写锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前正在读的线程，保证读读可重入</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread,Integer&gt; readingThread;</span><br><span class="line">    <span class="comment">//获得写锁的线程数，也可以说是写操作重入数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writerAccess;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writerRequest;</span><br><span class="line">    <span class="comment">//当前正在写的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread writingThread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writerAccess = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.writerRequest=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.readingThread = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(!isAccessRead(curThread))&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        readingThread.put(curThread,readingThread.getOrDefault(curThread,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccessRead</span><span class="params">(Thread t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(writerAccess&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(readingThread.get(t)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(writerRequest&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> cnt = readingThread.get(curThread);</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            readingThread.remove(curThread);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            readingThread.put(curThread,cnt-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        writerRequest++;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(!isAccessWrite(curThread))&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        writingThread = curThread;</span><br><span class="line">        writerRequest--;</span><br><span class="line">        writerAccess++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAccessWrite</span><span class="params">(Thread t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasReader())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(writingThread==<span class="keyword">null</span> || writingThread==t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readingThread.size()&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writerAccess--;</span><br><span class="line">        <span class="keyword">if</span>(writerAccess==<span class="number">0</span>)&#123;</span><br><span class="line">            writingThread = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="版本四（读写重入）"><a href="#版本四（读写重入）" class="headerlink" title="版本四（读写重入）"></a>版本四（读写重入）</h3><p>当读线程只有一个时允许其获得写锁。写操作只能有一个线程进行，故写线程可安全的获得读锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.写的优先级高于读 </span></span><br><span class="line"><span class="comment"> * 2.重入读的优先级高于写请求</span></span><br><span class="line"><span class="comment"> * 3.在读线程只有一个时允许持有读锁重入写锁</span></span><br><span class="line"><span class="comment"> * 4.写线程允许重入持有读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前正在读的线程，保证读读可重入</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread,Integer&gt; readingThread;</span><br><span class="line">    <span class="comment">//获得写锁的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writerAccess;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writerRequest;</span><br><span class="line">    <span class="keyword">private</span> Thread writingThread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writerAccess = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.writerRequest=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.readingThread = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(!isAccessRead(curThread))&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        readingThread.put(curThread,readingThread.getOrDefault(curThread,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccessRead</span><span class="params">(Thread t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当申请读锁的线程持有写锁时可安全的加读锁</span></span><br><span class="line">        <span class="keyword">if</span>(writingThread==t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(writerAccess&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(readingThread.get(t)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(writerRequest&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> cnt = readingThread.get(curThread);</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            readingThread.remove(curThread);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            readingThread.put(curThread,cnt-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOnlyReader</span><span class="params">(Thread t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readingThread.size()==<span class="number">1</span> &amp;&amp;</span><br><span class="line">                readingThread.get(t)!=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        writerRequest++;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(!isAccessWrite(curThread))&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        writingThread = curThread;</span><br><span class="line">        writerRequest--;</span><br><span class="line">        writerAccess++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAccessWrite</span><span class="params">(Thread t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isOnlyReader(t))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hasReader())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(writingThread==<span class="keyword">null</span> || writingThread==t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readingThread.size()&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writerAccess--;</span><br><span class="line">        <span class="keyword">if</span>(writerAccess==<span class="number">0</span>)&#123;</span><br><span class="line">            writingThread = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;版本一&quot;&gt;&lt;a href=&quot;#版本一&quot; class=&quot;headerlink&quot; title=&quot;版本一&quot;&gt;&lt;/a&gt;版本一&lt;/h3&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight-tools&quot;&gt;&lt;i class=&quot;fa
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="读写锁" scheme="https://jwkang99.github.io/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer算法答案(java)</title>
    <link href="https://jwkang99.github.io/posts/30d88c90.html"/>
    <id>https://jwkang99.github.io/posts/30d88c90.html</id>
    <published>2019-11-28T07:09:06.000Z</published>
    <updated>2020-03-28T13:47:48.827Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode全部Accept的</p><h2 id="4二维数组的查找"><a href="#4二维数组的查找" class="headerlink" title="4二维数组的查找"></a>4二维数组的查找</h2><p>题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">二维数组中的查找</a></p><blockquote><p>示例：<br>1  2   8  9<br>2  4   9  12<br>4  7 10 13<br>6  8  11  15<br>查找整数7返回true，查找数字5返回false</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *暴力解时间复杂度O(mn)</span></span><br><span class="line"><span class="comment"> *由于该数组从左上角到右下角递增</span></span><br><span class="line"><span class="comment"> *从左上角或者右下角开始查询，每次都可以排除一列或这一行</span></span><br><span class="line"><span class="comment"> *时间复杂度为O(m+n)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;matrix.length &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="5-字符串：替换空格"><a href="#5-字符串：替换空格" class="headerlink" title="5.字符串：替换空格"></a>5.字符串：替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></p><blockquote><p>示例：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在原字符串上操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">while</span>((index = str.indexOf(<span class="string">" "</span>))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        str.deleteCharAt(index);</span><br><span class="line">        str.insert(index,<span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *另开一个辅助的StringBuilder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                res.append(<span class="string">"%20"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在原数组上操作，遇到空格后逐一插入%20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace1</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">            spaceNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lengthOld = str.length();</span><br><span class="line">    <span class="keyword">int</span> lengthNew = lengthOld + spaceNum*<span class="number">2</span>;</span><br><span class="line">    str.setLength(lengthNew);</span><br><span class="line">    <span class="keyword">int</span> indexOld = lengthOld-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexNew = lengthNew-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(indexNew!=indexOld&amp;&amp;indexNew&gt;=<span class="number">0</span>&amp;&amp;indexOld&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(indexOld)==<span class="string">' '</span>)&#123;</span><br><span class="line">            str.setCharAt(indexNew--,<span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(indexNew--,<span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(indexNew--,<span class="string">'%'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str.setCharAt(indexNew--, str.charAt(indexOld));</span><br><span class="line">        &#125;</span><br><span class="line">        indexOld--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="6-链表：从尾到头打印链表"><a href="#6-链表：从尾到头打印链表" class="headerlink" title="6.链表：从尾到头打印链表"></a>6.链表：从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></p><blockquote><p>示例：</p><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先想到用栈来实现，时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)</span><br><span class="line">        res[i] = stack.removeLast();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其次，也可以用递归，和栈的时间复杂都一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//中间辅助数组res，将链表的逆序值暂存</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    printListFromTailToHead(head, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 res中的值转到题目要求的int[]</span></span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">int</span>[] resArray = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        resArray[i] = res.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode node, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有后继结点，就一直递归下去</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        printListFromTailToHead(node.next, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把当前结点的值添加到结果列表中</span></span><br><span class="line">    res.add(node.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  以上两种都在不改变原链表的情况下使用辅助空间完成</span></span><br><span class="line"><span class="comment"> *  若可以更改原链表，直接反转原链表则不需要额外的空间</span></span><br><span class="line"><span class="comment"> *  即空间复杂度为O(1)，时间复杂度为O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="comment">//反转之后的头节点</span></span><br><span class="line">    ListNode headRev;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        headRev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    headRev = pre;</span><br><span class="line"> <span class="comment">//遍历反转之后的链表</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[count-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count&amp;&amp;headRev!=<span class="keyword">null</span>;i++)&#123;</span><br><span class="line">        res[i] = headRev.val;</span><br><span class="line">        headRev = headRev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="7-二叉树：重建二叉树"><a href="#7-二叉树：重建二叉树" class="headerlink" title="7.二叉树：重建二叉树"></a>7.二叉树：重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都<strong>不含重复</strong>的数字。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></p><blockquote><p>示例：</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p><p>返回根节点。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前序遍历和中序遍历结果构建二叉树，返回根节点</span></span><br><span class="line"><span class="comment"> * 递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length==<span class="number">0</span> || inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildHelper(preorder,inorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildHelper</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre, <span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span></span>&#123;</span><br><span class="line">    <span class="comment">//以前序遍历集合的第一个节点为当前子树的根节点</span></span><br><span class="line">    TreeNode cur = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">    <span class="comment">//初始化当前子树的根节点</span></span><br><span class="line">    cur.left = <span class="keyword">null</span>;</span><br><span class="line">    cur.right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果某一子树的中序遍历和前序遍历数组中只剩一个节点</span></span><br><span class="line">    <span class="comment">//那么这个唯一的节点就是该子树的根节点，并返回当前子树</span></span><br><span class="line">    <span class="keyword">if</span>(endIn==startIn &amp;&amp; endPre==startPre)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> si = startIn;</span><br><span class="line">    <span class="comment">//找出cur在当前子树中序遍历数组中的位置</span></span><br><span class="line">    <span class="keyword">while</span>(si &lt;= endIn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[si] == pre[startPre])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算出以cur为根节点的左子树的节点个数</span></span><br><span class="line">    <span class="comment">//分别截出该子树的中序遍历和前序遍历数组</span></span><br><span class="line">    <span class="keyword">int</span> leftLen = si - startIn;</span><br><span class="line">    <span class="keyword">if</span>(leftLen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cur.left = buildHelper(pre,in,startPre+<span class="number">1</span>,startPre+leftLen,startIn,si-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子树节点个数</span></span><br><span class="line">    <span class="keyword">int</span> rightLen = endIn - si;</span><br><span class="line">    <span class="keyword">if</span>(rightLen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cur.right = buildHelper(pre,in,startPre+<span class="number">1</span>+leftLen,endPre,si+<span class="number">1</span>,endIn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="8-二叉树：二叉树的下一节点"><a href="#8-二叉树：二叉树的下一节点" class="headerlink" title="8.二叉树：二叉树的下一节点"></a>8.二叉树：二叉树的下一节点</h2><p>找出二叉树中序遍历的后续结点，有父指针</p><p>根据中序遍历的特点，某一结点中序遍历的后续节点只有以下几种可能<br>(1)当该节点为有右孩子时<br>中序遍历后续节点为 该节点右孩子的最左子孙节点<br>(2)当该节点没有右孩子且又是其父节点的左孩子时<br>中序遍历后续节点为 该节点的父节点<br>(3)当该节点没有右孩子且又是其父节点的右孩子时<br>找到该节点的最近祖宗节点（该祖宗节点是某一几点的左孩子），若向上遍历到的根节点，则该节点没有中序遍历后续节点。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">getNext</span><span class="params">(TreeNode pNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode pNext = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode pRight = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(pRight.left != <span class="keyword">null</span>)&#123;  <span class="comment">//寻找右孩子最左下的子孙节点</span></span><br><span class="line">            pRight = pRight.left;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode.parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode pParent = pNode.parent;</span><br><span class="line">        TreeNode pCurrent = pNode;</span><br><span class="line">        <span class="comment">//跳出循环的条件，要么找到一个最近的为左孩子的祖宗节点</span></span><br><span class="line">        <span class="comment">//或者遍历到根节点，把根节点的父节点即null赋值给pNext</span></span><br><span class="line">        <span class="keyword">while</span>(pParent != <span class="keyword">null</span> &amp;&amp; pCurrent == pParent.right)&#123;<span class="comment">//当该节点是其父节点的右孩子时进入循环</span></span><br><span class="line">            pCurrent = pParent;             </span><br><span class="line">            pParent = pParent.parent;         </span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="9-栈与队列：用两个栈实现队列"><a href="#9-栈与队列：用两个栈实现队列" class="headerlink" title="9.栈与队列：用两个栈实现队列"></a>9.栈与队列：用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1）</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="10-斐波那契数列-青蛙跳台阶问题"><a href="#10-斐波那契数列-青蛙跳台阶问题" class="headerlink" title="10.斐波那契数列(青蛙跳台阶问题)"></a>10.斐波那契数列(青蛙跳台阶问题)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *递归计算数列,有很多冗余计算,导致效率很低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *通过循环计算数列,可以减少冗余计算</span></span><br><span class="line"><span class="comment"> *将之前计算过的存储下来，从而提高计算效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        temp = first + second;</span><br><span class="line">        first = second;</span><br><span class="line">        second = temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="10-1-变态青蛙跳台阶问题"><a href="#10-1-变态青蛙跳台阶问题" class="headerlink" title="10.1 变态青蛙跳台阶问题"></a>10.1 变态青蛙跳台阶问题</h3><p>青蛙一次可以跳1级，2级·····n级，跳上n级台阶有多少种跳法？</p><blockquote><p>分析：f(1) = 1，f(2) = 2<br>n=3时，可以每次都跳1级，或者一次2级一次1级，或者直接跳3级，f(3) = 4<br>f(3) = f(1)+f(2)+1，后边的+1为直接跳到3级。<br>故可总结f(n) = f(n-1)+f(n-2)+···+f(1)+1，由数学归纳法可得f(n) = 2^{n-1}</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=target-<span class="number">1</span>)&#123;</span><br><span class="line">        result *= <span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="10-2-矩阵覆盖"><a href="#10-2-矩阵覆盖" class="headerlink" title="10.2 矩阵覆盖"></a>10.2 矩阵覆盖</h3><p>题目描述：可以用$2×1$的小矩形横着或者竖着去覆盖更大的矩形。请问用8个小矩形无重叠的覆盖一个$2×8$的大矩形共有多少种方法？</p><blockquote><p>仍为斐波那契数列问题，与上边代码一样。</p><p>可以记用小矩形覆盖$2×n$的大矩形共有$f(n)$中方法，则<br>$f(1)=1$，$f(2)=2$，$f(3)=3$，$f(4)=5$<br>$f(n)=f(n-1)+f(n-2)$</p></blockquote><h2 id="11-递归与循环：旋转数组的最小数字"><a href="#11-递归与循环：旋转数组的最小数字" class="headerlink" title="11.递归与循环：旋转数组的最小数字"></a>11.递归与循环：旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *递归分治,只有在无重复元素时才可用递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMinNumber(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinNumber</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[start]&lt;array[end] || start==end)&#123;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(findMinNumber(array,start,mid), findMinNumber(array,mid+<span class="number">1</span>,end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *非递归二分法,有重复元素，在left,mid,right三处的值相等时，就需遍历判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> midIndex = leftIndex;</span><br><span class="line">    <span class="keyword">while</span>(array[leftIndex]&gt;=array[rightIndex])&#123;</span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">1</span>)&#123;</span><br><span class="line">            midIndex = rightIndex;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        midIndex = (leftIndex+rightIndex)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[midIndex] == array[leftIndex]</span><br><span class="line">                &amp;&amp; array[midIndex] == array[rightIndex])&#123;</span><br><span class="line">            <span class="keyword">return</span> findMinInArr(array,leftIndex,rightIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(array[midIndex]&gt;=array[leftIndex])&#123;</span><br><span class="line">            leftIndex = midIndex;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[midIndex]&lt;=array[rightIndex])&#123;</span><br><span class="line">            rightIndex = midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[midIndex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinInArr</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = array[leftIndex];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=leftIndex+<span class="number">1</span>;i&lt;rightIndex;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[leftIndex]&lt;min)&#123;</span><br><span class="line">            min = array[leftIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径<strong>不能再次</strong>进入该格子。</p><p>该题leecode地址：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></p><blockquote><p>示例：<br>输入：board = [[“A”,”B”,”C”,”E”],<br>                           [“S”,”F”,”C”,”S”],<br>                           [“A”,”D”,”E”,”E”]] </p><p>​            word = “ABCCED”<br>输出：true</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  可用DFS和BFS对矩阵进行搜索。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="comment">//标记当前位置是否访问已经在目标字符串中用过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> [][] visited;</span><br><span class="line">    <span class="comment">//四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x&gt;=<span class="number">0</span>)&amp;&amp;(x&lt;m)&amp;&amp;(y&gt;=<span class="number">0</span>)&amp;&amp;(y&lt;n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length==<span class="number">0</span> || board[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.m = board.length;</span><br><span class="line">        <span class="keyword">this</span>.n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">//如果当前字符未在目标字符串中用过</span></span><br><span class="line">                <span class="comment">//且从当前位置出发可找到对应匹配，则返回true</span></span><br><span class="line">                <span class="keyword">if</span>(!visited[i][j]&amp;&amp;dfsHelper(i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dfs搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y (x,y)表示当前匹配的矩阵中的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start  目标字符串的当前匹配位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果匹配到最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(start == word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> board[x][y] == word.charAt(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果目标字符串的当前位置与字符矩阵中当前字符相同</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == word.charAt(start))&#123;</span><br><span class="line">            visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//则分四个方向匹配目标字符串的下一位置字符</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//找到一个方向存在即返回</span></span><br><span class="line">                <span class="keyword">if</span>(inArea(newX,newY) &amp;&amp; !visited[newX][newY])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfsHelper(newX,newY,start+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前方向不存在，则把未与目标字符串成功匹配的字符重置为false</span></span><br><span class="line">            <span class="comment">//表示未使用</span></span><br><span class="line">            visited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h2><p>题目描述：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>该题的leetcode地址：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">机器人的运动范围</a></p><blockquote><p>示例：</p><p>输入：m = 2, n = 3, k = 1<br>输出：3</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  与上体相似也可以采用dfs或bfs进行搜索</span></span><br><span class="line"><span class="comment"> *  对每个位置进行判断</span></span><br><span class="line"><span class="comment"> *  时间复杂度O(mn)，需要遍历每个位置</span></span><br><span class="line"><span class="comment"> *  空间复杂度O(mn)，标记位置的二位数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> direction[][] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=m || y&lt;<span class="number">0</span> || y&gt;=n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []sumXY = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> [] XY = &#123;x,y&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(XY[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                sumXY[i] += (XY[i]%<span class="number">10</span>);</span><br><span class="line">                XY[i] /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumXY[<span class="number">0</span>]+sumXY[<span class="number">1</span>] &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span> || n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        dfsHelper(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inArea(x,y) &amp;&amp; !visited[x][y])&#123;</span><br><span class="line">            visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">            dfsHelper(x+<span class="number">1</span>,y);</span><br><span class="line">            dfsHelper(x-<span class="number">1</span>,y);</span><br><span class="line">            dfsHelper(x,y+<span class="number">1</span>);</span><br><span class="line">            dfsHelper(x,y-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14.剪绳子"></a>14.剪绳子</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剪绳子</a></p><blockquote><p>示例：<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *动态规划和贪心两种方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i],dp[i-j]*j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心，优先分出最多的3，次之分2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> reminder = n%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(reminder==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,n/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(reminder==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,n/<span class="number">3</span>-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(reminder==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,n/<span class="number">3</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h2><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></p><blockquote><p>示例：<br>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.逐位判断，时间复杂度O(logn)，空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * 这种解法可能会在n是负数时造成死循环</span></span><br><span class="line"><span class="comment"> * 因为n是负数最高位是1，右移一位高位补1</span></span><br><span class="line"><span class="comment"> * 可以选择设置flag=1，将flag逐位左移与n进行与操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        res += n &amp; <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2.分析利用n&amp;(n-1)，时间复杂度O(1的个数)，空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> *      n: 1 1 1 0 1 0</span></span><br><span class="line"><span class="comment"> *    n-1: 1 1 1 0 0 1</span></span><br><span class="line"><span class="comment"> * n&amp;(n-1): 1 1 1 0 0 0</span></span><br><span class="line"><span class="comment"> * 每次操作都会删除n中最左端的1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        n =( n &amp; (n-<span class="number">1</span>));</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方，不得使用库函数。</p><p>该题的leetcode地址：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></p><blockquote><p>示例：<br>输入: 2.00000, 10<br>输出: 1024.00000</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：需要考虑底数和指数的所有情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> N = n;</span><br><span class="line">     <span class="keyword">if</span>(N &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="comment">//指数为负数</span></span><br><span class="line">         <span class="keyword">if</span>(x==<span class="number">0.0</span>)&#123;</span><br><span class="line">             <span class="comment">//可自定义底数为0结果为0</span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>/myPowHelper(x,-N);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> myPowHelper(x,N);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPowHelper</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0.0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1.0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果指数为奇数</span></span><br><span class="line">    <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//将结果分为三部分</span></span><br><span class="line">        <span class="keyword">double</span> res = myPowHelper(x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res*res*x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//指数为偶数，将结果分为两部分</span></span><br><span class="line">        <span class="keyword">double</span> res = myPowHelper(x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><blockquote><p>示例：<br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个答案可以在leetcode上通过，</span></span><br><span class="line"><span class="comment"> * 但是剑指offer上这道题的本意并不是这种解法</span></span><br><span class="line"><span class="comment"> * 而是考虑大数问题，用字符串进行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        number = number *<span class="number">10</span> +<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[number];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">        res[i] = i+<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。即所有子树的左右孩子节点交换位置。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">二叉树的镜像</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归交换左右子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    mirrorHelper(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mirrorHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span> || (root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    mirrorHelper(root.left);</span><br><span class="line">    mirrorHelper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。对称二叉树：所有子树的左右孩子结点的值都一样</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">对称的二叉树</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树中任意两个对称的节点L和R都满足</span></span><br><span class="line"><span class="comment"> * L.val == R.val</span></span><br><span class="line"><span class="comment"> * L.left.val == R.right.val</span></span><br><span class="line"><span class="comment"> * L.right.val == R.left.val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symmetricHelper(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">symmetricHelper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span> || left.val!=right.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symmetricHelper(left.left,right.right) &amp;&amp; symmetricHelper(left.right,right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>该题的leetcode地址：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></p><blockquote><p>示例：<br>输入：matrix = [[1,2,3],<br>                             [4,5,6],<br>                             [7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p></blockquote> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置上下左右四个边界，逐渐向内缩小边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length,n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//四个边界值初始值</span></span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bottom=m-<span class="number">1</span>,right=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=bottom &amp;&amp; left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            res[num++] = matrix[top][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++top &gt; bottom)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=bottom;i++)&#123;</span><br><span class="line">            res[num++] = matrix[i][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--right &lt; left)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)&#123;</span><br><span class="line">            res[num++] = matrix[bottom][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--bottom &lt; top)</span><br><span class="line">            bottom--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=top;i--)&#123;</span><br><span class="line">            res[num++] = matrix[i][left];</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关键在于O(1)实现min方法</span></span><br><span class="line"><span class="comment"> * 1.采用辅助栈依次存入当前的最小值</span></span><br><span class="line"><span class="comment"> * 每次pop都判断是不是pop出了当前最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min.isEmpty()||min.peek()&gt;=x)&#123;</span><br><span class="line">            min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop().equals(min.peek()))&#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.第二种方法借助min和当前数的差值判断是不是最小值</span></span><br><span class="line"><span class="comment">//空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">//该方法有一个缺陷，对于大数会出现溢出情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = x-min;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            min -= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.peek()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek()+min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。该题leetcode地址：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a>。</p><blockquote><p>示例：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.用一个栈去模拟，能成功模拟出即为true</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)，所有元素出栈入栈一次为2n</span></span><br><span class="line"><span class="comment">//空间复杂度O(n)，辅助栈大小为n</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处的栈可以用数组模拟，用下标存取速度更快</span></span><br><span class="line">    <span class="comment">//int[] stack = new int[pushed.length];</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> m = pushed.length;</span><br><span class="line">    <span class="keyword">int</span> n = popped.length;</span><br><span class="line">    <span class="keyword">if</span>(m!=n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//若两个数组都为空，则直接返回空栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        stack.push(pushed[i]);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; j&lt;n &amp;&amp; stack.peek().equals(popped[j]))&#123;</span><br><span class="line">            j++;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若辅助栈为空，即模拟成功</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.上述可用数组替代栈模拟出入栈过程</span></span><br><span class="line"><span class="comment">//考虑到遍历pushed数组是pushed[i]即为栈顶元素</span></span><br><span class="line"><span class="comment">//若pushed数组可修改，则可直接用pushed数组替代栈</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = pushed.length;</span><br><span class="line">    <span class="keyword">int</span> n = popped.length;</span><br><span class="line">    <span class="keyword">if</span>(m!=n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向栈顶元素的下一个位置</span></span><br><span class="line">    <span class="keyword">int</span> stack_top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        pushed[stack_top++] = pushed[i];</span><br><span class="line">        <span class="comment">//出栈匹配</span></span><br><span class="line">        <span class="keyword">while</span>(stack_top!=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; pushed[stack_top-<span class="number">1</span>]==popped[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">            stack_top--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack_top==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="32-打印二叉树"><a href="#32-打印二叉树" class="headerlink" title="32 打印二叉树"></a>32 打印二叉树</h2><h3 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32-I 从上到下打印二叉树"></a>32-I 从上到下打印二叉树</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">从上到下打印二叉树</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很简单的层次遍历</span></span><br><span class="line"><span class="comment">//广度优先遍历，将节点存在队列中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.addLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.addLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[temp.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)&#123;</span><br><span class="line">        res[i] = temp.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="32-II-从上到下打印二叉树II"><a href="#32-II-从上到下打印二叉树II" class="headerlink" title="32-II 从上到下打印二叉树II"></a>32-II 从上到下打印二叉树II</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">从上到下打印二叉树 II</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关键在于分层</span></span><br><span class="line"><span class="comment"> * 两种办法：</span></span><br><span class="line"><span class="comment"> * 1.用两个队列进行辅助，一个队列存当前层节点，另外一个队列存下一层</span></span><br><span class="line"><span class="comment"> * （1.2 后边发现用一个辅助队列就能实现分层，且不用标记节点）</span></span><br><span class="line"><span class="comment"> * 2.标记每一层的最后一个节点，用于区分是否进入了下一层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.两个辅助队列，时间O(n),空间O(n):2n</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存当前层</span></span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">//存下一层节点</span></span><br><span class="line">    Deque&lt;TreeNode&gt; qNext = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qNext.addLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qNext.addLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前层队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) &#123;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//下一层变为当前层</span></span><br><span class="line">            q.addAll(qNext);</span><br><span class="line">            qNext.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.2.一个辅助队列是实现分层,时间O(n),空间O(n):n</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            TreeNode cur = q.removeFirst();</span><br><span class="line">            temp.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.标记节点，时间O(n),空间O(n)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="comment">//标记当前层最后一个节点</span></span><br><span class="line">    TreeNode curLast = root;</span><br><span class="line">    TreeNode nextLast = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextLast = cur.left;</span><br><span class="line">            q.addLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextLast = cur.right;</span><br><span class="line">            q.addLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == curLast)&#123;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            curLast = nextLast;</span><br><span class="line">            nextLast = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="32-III-从上到下打印二叉树III"><a href="#32-III-从上到下打印二叉树III" class="headerlink" title="32-III 从上到下打印二叉树III"></a>32-III 从上到下打印二叉树III</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">从上到下打印二叉树 III</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.记录当前行是偶数行还是奇数行的方法，</span></span><br><span class="line"><span class="comment">//如果需要逆序则在31II的基础上翻转本层数组</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="comment">//判断当前层数组是否需要反转</span></span><br><span class="line">    <span class="keyword">boolean</span> isReverse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            TreeNode cur = q.removeFirst();</span><br><span class="line">            temp.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转当前层数据，需要额外时间</span></span><br><span class="line">        <span class="keyword">if</span>(isReverse)&#123;</span><br><span class="line">            Collections.reverse(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        isReverse = !isReverse;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用双端队列，节点的存入取出做判断</span></span><br><span class="line"><span class="comment">//时间O(n),空间O(n):n一个双端队列</span></span><br><span class="line"><span class="comment">//剑指offer原书上用的是两个栈，思想基本一样</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">boolean</span> isReverse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isReverse)&#123;</span><br><span class="line">                TreeNode cur = q.removeFirst();</span><br><span class="line">                temp.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addLast(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addLast(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode cur = q.removeLast();</span><br><span class="line">                temp.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addFirst(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addFirst(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isReverse = !isReverse;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路与利用中序和前序遍历构建二叉树的递归基本一样</span></span><br><span class="line"><span class="comment">//划分+递归</span></span><br><span class="line"><span class="comment">//搜索二叉树的后序遍历结果中，最后一个节点为根节点</span></span><br><span class="line"><span class="comment">//前边的节点一定可以在某一位置分为两部分，左边为左子树都比根节点小</span></span><br><span class="line"><span class="comment">//右边为右子树，都比根节点大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postorder==<span class="keyword">null</span> || postorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verifyHelper(postorder,<span class="number">0</span>, postorder.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifyHelper</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=start,j=end-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=end &amp;&amp; postorder[i]&lt;postorder[end])&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=start &amp;&amp; postorder[j]&gt;postorder[end])&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">    <span class="keyword">if</span>(j!=i+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> left = <span class="keyword">true</span>,right = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=start)&#123;</span><br><span class="line">        left = verifyHelper(postorder,start,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;end)&#123;</span><br><span class="line">        right = verifyHelper(postorder,j,end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.二叉树中和为某一值的路径</h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。该题的leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先遍历</span></span><br><span class="line"><span class="comment"> * 最开始我写的stack里存的是TreeNode</span></span><br><span class="line"><span class="comment"> * 后边看了剑指offer书上的代码后发现，存TreeNode多余了</span></span><br><span class="line"><span class="comment"> * 递归栈已经帮我们保存了上一层的父节点，只需将遍历节点的值进行入栈出栈操作即可</span></span><br><span class="line"><span class="comment"> * 自己考虑不当</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        pathSumHelper(root,sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSumHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        stack.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(stack));</span><br><span class="line">        &#125;</span><br><span class="line">        pathSumHelper(root.left,sum);</span><br><span class="line">        pathSumHelper(root.right,sum);</span><br><span class="line">        stack.remove(stack.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。该题的leetcode：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分三步解决</span></span><br><span class="line"><span class="comment"> * 1.复制生成新的节点</span></span><br><span class="line"><span class="comment"> * 2.复制next指针</span></span><br><span class="line"><span class="comment"> * 3.复制random指针</span></span><br><span class="line"><span class="comment"> * 前两步就是与常规的链表复制一致，遍历一遍即可完成</span></span><br><span class="line"><span class="comment"> * 难点在第三步，新链表的random指针指向新复制出来的结点，</span></span><br><span class="line"><span class="comment"> * 而旧链表中random指向的旧节点，故需要将旧节点与新节点对应起来，</span></span><br><span class="line"><span class="comment"> * 原链表中的A.random指向B,则让新链表中的A'.random指向新的B'</span></span><br><span class="line"><span class="comment"> * 所以需要一个能存映射关系的数据结构map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Node cHead = <span class="keyword">new</span> Node(head.val);</span><br><span class="line">    Node cp = cHead;</span><br><span class="line">    map.put(head,cHead);</span><br><span class="line">    Node p = head;</span><br><span class="line">    <span class="keyword">while</span>(p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        Node temp = <span class="keyword">new</span> Node(p.val);</span><br><span class="line">        cp.next = temp;</span><br><span class="line">        cp = cp.next;</span><br><span class="line">        map.put(p,cp);</span><br><span class="line">    &#125;</span><br><span class="line">    cp = cHead;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span>(cp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        cp.random = map.get(p.random);</span><br><span class="line">        cp = cp.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历顺序逐一修改指针</span></span><br><span class="line"><span class="comment">//空间O(n),时间O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储中序遍历结果</span></span><br><span class="line">    List&lt;Node&gt; inOrderList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderHelper(root);</span><br><span class="line">        <span class="keyword">int</span> len = inOrderList.size();</span><br><span class="line">        <span class="comment">//按照中序遍历结果逐一修改左右指针</span></span><br><span class="line">        inOrderList.get(<span class="number">0</span>).left = inOrderList.get(len-<span class="number">1</span>);</span><br><span class="line">        inOrderList.get(<span class="number">0</span>).right = inOrderList.get(<span class="number">1</span>%len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = i%len,index_pre=(i-<span class="number">1</span>)%len,index_next=(i+<span class="number">1</span>)%len;</span><br><span class="line">            inOrderList.get(index).right = inOrderList.get(index_next);</span><br><span class="line">            inOrderList.get(index).left = inOrderList.get(index_pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inOrderList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderHelper</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderHelper(root.left);</span><br><span class="line">            inOrderList.add(root);</span><br><span class="line">            inOrderHelper(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改中序遍历，采用递归分治，把过程分解为</span></span><br><span class="line"><span class="comment">//左子树的双向链表+root+右子树的双向链表，其中，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lastNode表示当前链表的最后一个节点</span></span><br><span class="line">    Node lastNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderHelper(root);</span><br><span class="line">        Node head = lastNode;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>&amp;&amp;head.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125;</span><br><span class="line">        head.left = lastNode;</span><br><span class="line">        lastNode.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderHelper</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderHelper(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把root节点的left指针指向已构成链表的最后一个节点</span></span><br><span class="line">        root.left = lastNode;</span><br><span class="line">        <span class="comment">//如果lastNode不为空，修改lastNode的right指针</span></span><br><span class="line">        <span class="keyword">if</span>(lastNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastNode.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//root和左子树构成链表后，root变成当前链表的最后一个节点</span></span><br><span class="line">        lastNode = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderHelper(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37.序列化二叉树"></a>37.序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。该题leetcode地址：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">序列化二叉树</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 示例：</span><br><span class="line"> 1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line">序列化形式不唯一，如下为层次序列化</span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="comment">//按层次遍历字符串拼接</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"null,"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(cur.val).append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        q.addLast(cur.left);</span><br><span class="line">        q.addLast(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最后一个逗号 </span></span><br><span class="line">    res.deleteCharAt(res.length()-<span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] tree = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">//仍然依靠队列还原二叉树</span></span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = tree.length;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[<span class="number">0</span>]));</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(tree[i].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode left = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[i]));</span><br><span class="line">            cur.left = left;</span><br><span class="line">            q.addLast(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i+<span class="number">1</span>].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            cur.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode right = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[i+<span class="number">1</span>]));</span><br><span class="line">            cur.right = right;</span><br><span class="line">            q.addLast(right);</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历，采用递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"["</span>);</span><br><span class="line">    serializeHelper(root,res);</span><br><span class="line">    res.deleteCharAt(res.length()-<span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serializeHelper</span><span class="params">(TreeNode root,StringBuilder res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        res.append(<span class="string">"null,"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.append(root.val).append(<span class="string">","</span>);</span><br><span class="line">        serializeHelper(root.left,res);</span><br><span class="line">        serializeHelper(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] tree = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">//采用数组记录下标是想保持递归函数的全局可见性</span></span><br><span class="line">    <span class="keyword">int</span>[] index=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TreeNode root = deserializeHelper(tree,index);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserializeHelper</span><span class="params">(String[] tree,<span class="keyword">int</span>[] index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index[<span class="number">0</span>]].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">        index[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[index[<span class="number">0</span>]]));</span><br><span class="line">        index[<span class="number">0</span>]++;</span><br><span class="line">        <span class="comment">//以下两个递归index[0]不同</span></span><br><span class="line">        root.left = deserializeHelper(tree,index);</span><br><span class="line">        root.right = deserializeHelper(tree,index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38.字符串的排列"></a>38.字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。该题leetcode地址：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入：s = "abc"</span></span><br><span class="line"><span class="comment"> * 输出：["abc","acb","bac","bca","cab","cba"]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//当前算法时间复杂度较高</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//利用set去重</span></span><br><span class="line">    Set&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        permutationHelper(s,<span class="string">""</span>,visited);</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> String[result.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutationHelper</span><span class="params">(String s,String res,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == res.length())&#123;</span><br><span class="line">            result.add(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//表示当前字符已经用过</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//以第i个字符为开头的排列</span></span><br><span class="line">            permutationHelper(s,res+String.valueOf(c),visited);</span><br><span class="line">            <span class="comment">//重置为未使用，下一轮组合使用</span></span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。该题leetcode地址：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener"> 数组中出现次数超过一半的数字</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            majority = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(majority==n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。leetcode地址：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用最大堆实现，也可自己实现最大堆</span></span><br><span class="line"><span class="comment">//解答中还有用快排解决的，数据量大的话并不适用</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line"> <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;=k)&#123;</span><br><span class="line">         <span class="keyword">return</span> arr;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//最大堆</span></span><br><span class="line">     Queue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue(k,Comparator.reverseOrder());</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">         q.offer(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;arr.length)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[i]&lt;q.peek())&#123;</span><br><span class="line">             q.poll();</span><br><span class="line">             q.offer(arr[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Arrays.stream(q.toArray(<span class="keyword">new</span> Integer[k])).mapToInt(Integer::valueOf).toArray();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41.数据流中的中位数"></a>41.数据流中的中位数</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。leetcode地址：<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a>。</p><p>例：[2,3,4] 的中位数是 3，[2,3] 的中位数是 (2 + 3) / 2 = 2.5。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用两个堆，分别为最大堆和最小堆</span></span><br><span class="line"><span class="comment">//空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; leftQ;</span><br><span class="line">    Queue&lt;Integer&gt; rightQ;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最小堆</span></span><br><span class="line">        leftQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//最大堆</span></span><br><span class="line">        rightQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2-o1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调整两个堆使得left要么与right的size相同</span></span><br><span class="line">        <span class="comment">//要了left = right+1</span></span><br><span class="line">        <span class="keyword">if</span>(leftQ.size()==rightQ.size())&#123;</span><br><span class="line">            <span class="comment">//O(logn)</span></span><br><span class="line">            rightQ.offer(num);</span><br><span class="line">            leftQ.offer(rightQ.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            leftQ.offer(num);</span><br><span class="line">            rightQ.offer(leftQ.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//O(1)</span></span><br><span class="line">        <span class="keyword">if</span>(leftQ.size()==rightQ.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)leftQ.peek()+rightQ.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftQ.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h2><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        nums[i] += Math.max(nums[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        max = Math.max(nums[i],max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43.1～n整数中1出现的次数"></a>43.1～n整数中1出现的次数</h2><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p>分析：</p><ul><li>n=1234，可以分为1-999和1000-1234两部分，既为f(999)+234+1+f(234)</li><li>n=2134，可以分为1-999、1000-1999和2000-2134三部分，即为f(999)+1000+f(999)+f(134)</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1234</span></span><br><span class="line">    <span class="comment">//3124</span></span><br><span class="line">    <span class="comment">//21234</span></span><br><span class="line">    String s = String.valueOf(n);</span><br><span class="line">    <span class="comment">//存储数字的最高位</span></span><br><span class="line">    <span class="keyword">int</span> first = s.charAt(<span class="number">0</span>)-<span class="string">'0'</span>;</span><br><span class="line">    <span class="comment">//存储最高位的单位，万千百</span></span><br><span class="line">    <span class="keyword">int</span> pow = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//存储除了最高位的部分</span></span><br><span class="line">    <span class="keyword">int</span> last = n-first*pow;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span>(first==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> countDigitOne(pow-<span class="number">1</span>)+last+<span class="number">1</span>+countDigitOne(last);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countDigitOne(pow-<span class="number">1</span>)*first+countDigitOne(last)+pow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44.数字序列中某一位的数字"></a>44.数字序列中某一位的数字</h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用int有溢出，不通过，目前没发现哪里溢出了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> digits = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-<span class="number">9</span>*base*digits&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        n -= <span class="number">9</span>*base*digits;</span><br><span class="line">        digits++;</span><br><span class="line">        base = base*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> num = base + (n-<span class="number">1</span>)/digits;</span><br><span class="line">    <span class="keyword">long</span> remainder = n%digits;</span><br><span class="line">    System.out.println(num+<span class="string">" "</span>+remainder);</span><br><span class="line">    <span class="keyword">if</span>(remainder==<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = digits;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(digits);</span><br><span class="line">    <span class="keyword">if</span>(remainder==digits)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num%<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(num).charAt((<span class="keyword">int</span>) (remainder-<span class="number">1</span>))-<span class="string">'0'</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><blockquote><p>示例：<br>输入: [10,2]<br>输出: “102”</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串数组排序，时间O(nlogn)，空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转为字符串数组</span></span><br><span class="line">    String[] temp = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        temp[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对字符串数组按照特定顺序进行排</span></span><br><span class="line">    Arrays.sort(temp, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            String s1 = o1+o2;</span><br><span class="line">            String s2 = o2+o1;</span><br><span class="line">            <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s : temp)&#123;</span><br><span class="line">        res.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。该题leetcode地址：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">把数字翻译成字符串</a>。</p><blockquote><p>示例：<br>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，转化成字符串效率比较低</span></span><br><span class="line"><span class="comment">//可以从后往前遍历用除法取余,也可以使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = String.valueOf(num).toCharArray();</span><br><span class="line">    <span class="comment">//表示以第i-1个数字结尾的数量</span></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//表示以第i-2个数字结尾的数量</span></span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> twoDigit = (chars[i-<span class="number">1</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+(chars[i]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = cur;</span><br><span class="line">        <span class="comment">//如果i-1位与i位可以构成26以内</span></span><br><span class="line">        <span class="comment">//其中pre记录的是i-2为结尾的数量</span></span><br><span class="line">        <span class="comment">//(i)=(i-1)+co*(i-2)</span></span><br><span class="line">        <span class="keyword">int</span> co = twoDigit&gt;<span class="number">9</span>&amp;&amp;twoDigit&lt;<span class="number">26</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        cur += pre*co;</span><br><span class="line">        pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从后往前，用数字的除法，100%</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>,pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> twoDigit = num%<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = cur;</span><br><span class="line">        <span class="keyword">int</span> co = twoDigit&gt;<span class="number">9</span>&amp;&amp;twoDigit&lt;<span class="number">26</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//(i)=(i-1)+co*(i-2)</span></span><br><span class="line">        cur += pre*co;</span><br><span class="line">        pre = temp;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">9</span>) &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//xyzcba</span></span><br><span class="line">    <span class="keyword">int</span> ba = num%<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (ba&lt;=<span class="number">9</span>||ba&gt;=<span class="number">26</span>) &#123;<span class="keyword">return</span> translateNum(num/<span class="number">10</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> translateNum(num/<span class="number">10</span>)+translateNum(num/<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>简单说，只能向下或者向右，寻找一条从(0,0)到(m,n)的路径使得经过结点的和最大的。leetcode地址：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，从(0,0)到(i,j)的最大路径和为f(i,j)</span></span><br><span class="line"><span class="comment">//只能从(i-1,j)或(i,j-1)得到</span></span><br><span class="line"><span class="comment">//得递推式：f(i,j) = max&#123;f(i-1,j),f(i,j-1)&#125;+grid(i+j)</span></span><br><span class="line"><span class="comment">//可得下列代码，如果用递归会有很多冗余计算，所以用循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></div><p>上边的方法存了所有结点的最大路径，但是$(i,j)$处的最大路径和值依赖于$(i-1,j)$和$(i,j-1)$。故$i-1$行以上的部分没必要存储。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//只用于存储i-1行的数据</span></span><br><span class="line">    <span class="keyword">int</span>[]dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[j+<span class="number">1</span>] = Math.max(dp[j+<span class="number">1</span>],dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串"></a>48.最长不含重复字符的子字符串</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>leetcode地址：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a>。</p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p></blockquote><p><strong>注</strong>： 最开始看这道题的时候想错了，做成了子序列，子序列相对简单一点。</p><p>分析：同样用动态规划解决。如果第$i$个字符没在之前的字串中出现过，那么以第$i$个字符即为的字串长度为$f(i)=f(i-1)+1$。但是如果在前边的子串中出现过，情况就比较复杂了。需要考虑第$i$个字符上一次在字符串中出现的位置。两次出现的间隔为$d$，如果$d≤f(i-1)$，那么上一次出现的位置在以第$i-1$字符为结尾的子串中，故能保证两次出现位置之间的字符均无重复，即$f(i)=d$；若$d&gt;f(i-1)$就为第一种情况了，$f(i)=f(i-1)+1$。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个思路是剑指offer书上的，在leetcode上过不了，似乎是因为有空格和大小写的原因</span></span><br><span class="line"><span class="comment">//可以把26的数组换成Map,实际上该方法就是滑动窗口的优化解。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">if</span>(length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character,Integer&gt; position = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">int</span> d = i+<span class="number">1</span>-position.getOrDefault(c,<span class="number">0</span>);</span><br><span class="line">        position.put(c,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(d&gt;curLength)&#123;</span><br><span class="line">            curLength += <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curLength = d;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,curLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>也可以使用滑动窗口和双指针Set集合中存的是下标${i,j}$之间的元素。$j+1$个字母没在集合中时，则加入集合子串长度+1。否则，下标$i$往前移动移动，且依次将指向的字母从set删除，直到把与j+1个字母相同的那个字母不在集合中时，再把j+1个字符加入集合，有生成一个新的子串。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;length&amp;&amp;j&lt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">            set.add(s.charAt(j));</span><br><span class="line">            j++;</span><br><span class="line">            maxLength = Math.max(maxLength,j-i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.remove(s.charAt(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49.丑数"></a>49.丑数</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。leetcode地址：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a>。</p><blockquote><p>示例<br>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用于存下已经算出来的丑数，后边的丑数都是x(2,3,5)所得</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//只需把算出来的丑数，判断大小排序即可</span></span><br><span class="line">        dp[i] = Math.min(dp[p2]*<span class="number">2</span>,Math.min(dp[p3]*<span class="number">3</span>,dp[p5]*<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == dp[p2]*<span class="number">2</span>)&#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == dp[p3]*<span class="number">3</span>)&#123;</span><br><span class="line">            p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == dp[p5]*<span class="number">2</span>)&#123;</span><br><span class="line">            p5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode全部Accept的&lt;/p&gt;
&lt;h2 id=&quot;4二维数组的查找&quot;&gt;&lt;a href=&quot;#4二维数组的查找&quot; class=&quot;headerlink&quot; title=&quot;4二维数组的查找&quot;&gt;&lt;/a&gt;4二维数组的查找&lt;/h2&gt;&lt;p&gt;题目描述：在一个二维数组中，每一行都按照从
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
      <category term="剑指offer" scheme="https://jwkang99.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简单实现(结构型)</title>
    <link href="https://jwkang99.github.io/posts/41c70678.html"/>
    <id>https://jwkang99.github.io/posts/41c70678.html</id>
    <published>2019-11-16T03:59:08.000Z</published>
    <updated>2020-03-23T13:35:29.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式及简单实现"><a href="#设计模式及简单实现" class="headerlink" title="设计模式及简单实现"></a>设计模式及简单实现</h1><p>根据模式是用来完成什么工作来划分，设计模式分为三种类型，共23种。</p><p>①<strong>创建型模式</strong>（5种）：<span style="color:red">单例模式</span>、抽象工厂模式、原型模式、建造者模式、<span style="color:red">工厂方法模式</span>。</p><p>②<strong>结构型模式</strong>（7种）：适配器模式、桥接模式、<span style="color:red">装饰模式</span>、组合模式、外观模式、享元模式、<span style="color:red">代理模式</span>。</p><p>③<strong>行为型模式</strong>（11种）：模板方法模式、命令模式、访问者模式、迭代器模式、<span style="color:red">观察者模式</span>、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责模式（责任链模式）。</p><h2 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2.结构型模式"></a>2.结构型模式</h2><p>结构型模式用于描述如何将类或对象按某种布局组成更大的结构，主要特点是扩展。</p><h3 id="2-1-装饰模式"><a href="#2-1-装饰模式" class="headerlink" title="2.1 装饰模式"></a>2.1 装饰模式</h3><p>装饰模式是动态的给一个对象添加以下额外的职责，就增加功能来说，装饰比生成子类更为灵活。</p><a href="/posts/41c70678/decorator.jpg" data-fancybox="group" data-caption="decorator" class="fancybox"><img alt="decorator" style="zoom:50%;" data-src="/posts/41c70678/decorator.jpg" class="lazyload" title="decorator"></a><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装饰者模式代码</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体对象的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装饰类，继承自Component</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(Component component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(component!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            component.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A独有,对原Component进行了装饰</span></span><br><span class="line">    <span class="keyword">private</span> String addState;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addState = <span class="string">"New State"</span>;</span><br><span class="line">        System.out.println(<span class="string">"具体装饰A的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//B独有,对原Component进行了装饰</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addedBehavior</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedBehavior();</span><br><span class="line">        System.out.println(<span class="string">"具体装饰A的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先实例化ConcreteComponent对象c</span></span><br><span class="line">        ConcreteComponent c = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        ConcreteDecoratorA d1 = <span class="keyword">new</span> ConcreteDecoratorA();</span><br><span class="line">        ConcreteDecoratorB d2 = <span class="keyword">new</span> ConcreteDecoratorB();</span><br><span class="line">        <span class="comment">//然后用ConcreteDecoratorA的实例d1包装c</span></span><br><span class="line">        d1.setComponent(c);</span><br><span class="line">        <span class="comment">//再用ConcreteDecoratorB的d2包装d1</span></span><br><span class="line">        d2.setComponent(d1);</span><br><span class="line">        <span class="comment">//最终执行d2的operation()</span></span><br><span class="line">        d2.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>装饰者模式就是利用<code>setComponent</code>来对对象进行包装，这样每个装饰对象的实现就和如何利用这个对象分离了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链中。</strong></p><p>以人的服装为例，人为<code>Compoent</code>，由于只有一个人，故省略了抽象类，同时，服饰类作为装饰类继承自人类，装饰类下有多个实现。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"の装扮"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服饰类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finery</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Person component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">(Person component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(component!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            component.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体服饰类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TShirts</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">"T恤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">"运动鞋"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其余服饰省略</span></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"Coder"</span>);</span><br><span class="line">        TShirts t  = <span class="keyword">new</span> TShirts();</span><br><span class="line">        Shoes s = <span class="keyword">new</span> Shoes();</span><br><span class="line">        <span class="comment">//装饰过程，多种服饰可以有多种组合方式</span></span><br><span class="line">        t.decorate(person);</span><br><span class="line">        s.decorate(t);</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果，注意装饰的先后顺序可更改</span></span><br><span class="line">Coderの装扮</span><br><span class="line">T恤</span><br><span class="line">运动鞋</span><br></pre></td></tr></table></figure></div><p>装饰者模式是为已有功能动态地添加更多功能的一种方式。当系统需要更新功能时，是向旧类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为，<strong>而这些新家的东西仅仅是为了满足一些旨在某种特定情况下才会执行的特殊行为需求</strong>，故而客户端可以在运行是按需求选择顺序使用装饰类包装对象。</p><p>装饰模式的<strong>优点</strong>是把类中的装饰功能能从类中搬移出去，可以简化原有的类，有效地把类地核心职责和装饰功能区分开，而且可以<strong>去除相关类中重复</strong>地装饰逻辑。同时装饰模式也可以<strong>减轻类爆炸的问题</strong>，<strong>例如</strong>，在生活中奶茶店买饮料，有多种不同的饮料只是配方不同，如果都单纯的去继承实现Drink接口，若新增一种调料，具体类的数量将会倍增，这种情况下就非常适合用装饰者模式，只需新增调料类，让客户端去选择配方调料或者顺序，也可计算加了各种配料的总价格。</p><p><strong>在JDK中的IO结构中</strong>，<code>FilterInputStream</code>就是一个装饰者模式。</p><a href="/posts/41c70678/iodecorator.jpg" data-fancybox="group" data-caption="iodecorator" class="fancybox"><img alt="iodecorator" style="zoom:80%;" data-src="/posts/41c70678/iodecorator.jpg" class="lazyload" title="iodecorator"></a><h3 id="2-2-代理模式"><a href="#2-2-代理模式" class="headerlink" title="2.2 代理模式"></a>2.2 代理模式</h3><p>代理模式为其他对象提供一种代理以控制对这个对象的访问，即通过代理对象访问目标对象，可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。</p><p>代理模式有三种形式，<strong>静态代理</strong>、<strong>动态代理</strong>(JDK代理或接口代理)和<strong>Cglib代理</strong>（可以在内存中动态的创建对象，而不需要实现接口，属于动态代理的范畴）。</p><p>代理模式还有几种变体：防火墙代理，缓存代理，远程代理，同步代理（用于多线程）。</p><h4 id="2-2-1-静态代理"><a href="#2-2-1-静态代理" class="headerlink" title="2.2.1 静态代理"></a>2.2.1 静态代理</h4><p>静态代理<strong>优点</strong>是在不修改目标对象的前提下，对目标对象进行增强扩展；<strong>缺点</strong>是代理对象需要与目标对象实现一样的接口，规模大时类的数量爆炸。一旦接口增加方法，目标类和代理类都要维护。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObject</span> <span class="keyword">implements</span> <span class="title">IObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"目标对象run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">implements</span> <span class="title">IObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IObject obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> ConcreteObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理对象对目标对象增强中"</span>);</span><br><span class="line">        obj.run();</span><br><span class="line">        System.out.println(<span class="string">"增强结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IObject proxy = <span class="keyword">new</span> ProxyObject();</span><br><span class="line">        proxy.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-2-2-动态代理"><a href="#2-2-2-动态代理" class="headerlink" title="2.2.2 动态代理"></a>2.2.2 动态代理</h4><p>①代理对象不需要实现接口，但是没目标对象要实现接口，否则不能使用动态代理。</p><p>②代理对象的生成时利用JDK的API，动态的在内存中构建代理对象，即反射。代理类所在的包<code>java.lang.reflcet.Proxy</code>，只需使用<code>newProxyInstance</code>即可生成代理对象。</p><p>③动态代理也叫做JDK代理、接口代理</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObject</span> <span class="keyword">implements</span> <span class="title">IObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"目标对象run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象出一个代理工厂，用于生成代理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.boj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//import java.lang.reflcet.Proxy</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"JDK代理增强"</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法并增强</span></span><br><span class="line">                        Object returnVal = method.invoke(obj,args);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>()</span>&#123;</span><br><span class="line">    IObject obj = <span class="keyword">new</span> ConcreteObject();</span><br><span class="line">    IObject proxy = (IObject)<span class="keyword">new</span> ProxyFactory(obj).getProxyInstance();</span><br><span class="line">    <span class="comment">//proxy对象为Proxy类型</span></span><br><span class="line">    System.out.println(proxy);</span><br><span class="line">    proxy.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-2-3-Cglib代理"><a href="#2-2-3-Cglib代理" class="headerlink" title="2.2.3 Cglib代理"></a>2.2.3 Cglib代理</h4><p>①静态代理和JDK代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个对象，<strong>没有实现任何接口</strong>，这时可以使用目标对象的子类来实现代理。</p><p>②Cglib代理也称子类代理，它时在内存中构建一个子类对象从而实现对目标对象功能扩展。</p><p>③Cglib是一个强大的高性能的代码生成包（需要导入四个包），可以在运行期间扩展类与实现接口，广泛应用于AOP框架，例如Spring AOP，实现方法拦截。</p><p>④Cglib包底层是通过使用字节码处理框架ASM来转换字节码并生成新的类。</p><p>注：目标对象的方法为final则不会被增强，目标对象为final会出现异常。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"目标对象run..未实现接口"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//import net.sf.cglib.*;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CgProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CgProxyFactory</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个obj的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个工具类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置父类，即目标类</span></span><br><span class="line">        enhancer.setSuperclass(obj.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调函数，参数为重写了intercept的类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args,MrthodProxy arg3)</span> throw Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cglib代理..."</span>);</span><br><span class="line">        Object returnVal = method.invoke(obj,args);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    ConcreteObject obj = <span class="keyword">new</span> ConcreteObject();</span><br><span class="line">    CgProxyFactory factory = <span class="keyword">new</span> CgProxyFactory(obj);</span><br><span class="line">    <span class="comment">//proxy对象为一个普通的java类</span></span><br><span class="line">    ConcreteObject proxy = obj.getProxyInstance();</span><br><span class="line">    <span class="comment">//执行代理对象的方法，触发intercopt方法，从而实现对目标对象的调用</span></span><br><span class="line">    proxy.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-3-外观模式"><a href="#2-3-外观模式" class="headerlink" title="2.3 外观模式"></a>2.3 外观模式</h3><p>外观模式为子系统中的一组接口一个一致的界面，子模式定义了一个高层接口，这个接口是的这一子系统更加容易使用。是相对于客户端来说的，客户端只需要调用这个同一的接口即可，并不需要知道子系统的存在。</p><p>适用环境：在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。</p><p>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</p><p><strong>优点</strong>：实现了子系统与客户端之间的松耦合关系。</p><p>客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。</p><p>外观模式在MyBatis中有用到。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ModelA a = <span class="keyword">new</span> ModelA();</span><br><span class="line">    <span class="keyword">private</span> ModelB b = <span class="keyword">new</span> ModelB();</span><br><span class="line">    <span class="keyword">private</span> ModelC c = <span class="keyword">new</span> ModelC();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        b.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        c.methodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();<span class="comment">//获取门面对象</span></span><br><span class="line">        facade.MethodA();<span class="comment">//使用门面对象</span></span><br><span class="line">        facade.MethodB();</span><br><span class="line">        facade.MethodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式及简单实现&quot;&gt;&lt;a href=&quot;#设计模式及简单实现&quot; class=&quot;headerlink&quot; title=&quot;设计模式及简单实现&quot;&gt;&lt;/a&gt;设计模式及简单实现&lt;/h1&gt;&lt;p&gt;根据模式是用来完成什么工作来划分，设计模式分为三种类型，共23种。&lt;/p&gt;
&lt;p&gt;①
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="设计模式" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://jwkang99.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简单实现(行为型)</title>
    <link href="https://jwkang99.github.io/posts/74c24778.html"/>
    <id>https://jwkang99.github.io/posts/74c24778.html</id>
    <published>2019-11-16T03:59:08.000Z</published>
    <updated>2020-03-23T01:40:35.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式及简单实现"><a href="#设计模式及简单实现" class="headerlink" title="设计模式及简单实现"></a>设计模式及简单实现</h1><p>根据模式是用来完成什么工作来划分，设计模式分为三种类型，共23种。</p><p>①<strong>创建型模式</strong>（5种）：<span style="color:red">单例模式</span>、抽象工厂模式、原型模式、建造者模式、<span style="color:red">工厂方法模式</span>。</p><p>②<strong>结构型模式</strong>（7种）：适配器模式、桥接模式、<span style="color:red">装饰模式</span>、组合模式、外观模式、享元模式、<span style="color:red">代理模式</span>。</p><p>③<strong>行为型模式</strong>（11种）：模板方法模式、命令模式、访问者模式、迭代器模式、<span style="color:red">观察者模式</span>、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责模式（责任链模式）。</p><h2 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3.行为型模式"></a>3.行为型模式</h2><p>行为模式用于描述类或对象之间怎样相互协作功能完成单个对象都无法单独完成的任务，以及怎样分配职责，主要用于关注方法设计的合理性。</p><h3 id="3-1-策略模式"><a href="#3-1-策略模式" class="headerlink" title="3.1 策略模式"></a>3.1 策略模式</h3><p>策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。<font color="red">（封装变化点）</font>：①把变化的代码从不变的代码中分离出来②针对接口比安承而不是具体的类（定义了策略接口或者抽象类）③多用组合/聚合少用继承（客户端通过组合方式使用策略）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//策略接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Algorithm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Algorithm</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Algorithm</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上下文</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//针对接口编程</span></span><br><span class="line">    Strategy strategy;</span><br><span class="line">    <span class="comment">//传入具体的策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span> <span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相应策略的实现具体实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">concreteAlgorithm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.Algorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//组合</span></span><br><span class="line">        Context context;</span><br><span class="line">        <span class="comment">//传入具体的策略        </span></span><br><span class="line">        context = <span class="keyword">new</span> Context(StrategyA);</span><br><span class="line">        context.concreteAlgorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以实际生活中的超市收费为例，超市的收费标准可能会因时而不同，不如打八折，满减，增积分等多种不同得到策略，这样就适合用策略模式。示例如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收费接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//折扣</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CashDiscount</span> <span class="keyword">implements</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> discount = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashDiscount</span><span class="params">(<span class="keyword">double</span> discount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.discount = discount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money*discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//满减</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CashReturn</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> condition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> moneyReturn;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashReturn</span><span class="params">(<span class="keyword">double</span> condition,<span class="keyword">double</span> moneyReturn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">        <span class="keyword">this</span>.moneyReturn = moneyReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money-(money/condition)*moneyReturn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上下文</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//针对接口编程</span></span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line">    <span class="comment">//传入具体的策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span> <span class="params">(CashSuper cs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cs = cs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相应策略的实现具体实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.getResult(<span class="keyword">double</span> money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//组合</span></span><br><span class="line">        Context context;</span><br><span class="line">        <span class="comment">//传入具体的策略,八折      </span></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> CashDiscount(<span class="number">0.8</span>));</span><br><span class="line">        context.getMoney(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>上例中有一个缺点</strong>，决定调用哪个算法又变成了客户端的职责，而简单工厂可以将这些判断从客户端移走，故策略模式和工厂模式可以结合一下，把策略决定步骤放在Context中，Context的部分修改代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上下文，策略模式与简单工厂结合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//针对接口编程</span></span><br><span class="line">    <span class="keyword">private</span> CashSuper cs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//传入具体的策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span> <span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"正常收费"</span>))&#123;</span><br><span class="line">            <span class="keyword">this</span>.cs = <span class="keyword">new</span> CashDiscount(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"满300减100"</span>))&#123;</span><br><span class="line">            <span class="keyword">this</span>.cs = <span class="keyword">new</span> CashReturn(<span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cs为空的判断省略</span></span><br><span class="line">    <span class="comment">//相应策略的实现具体实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.getResult(<span class="keyword">double</span> money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端部分代码</span></span><br><span class="line">Context context = <span class="keyword">new</span> Context(type);</span><br><span class="line"><span class="comment">//如果当前问题只在简单工厂模式下，客户端代码大致如下</span></span><br><span class="line">CashSuper cs = Factory.createCs(type);</span><br></pre></td></tr></table></figure></div><p>由上可以看出，策略模式和简单工厂模式极为相似，但又有许多不同的地方，例如在上边客户端的实现的地方，策略模式中客户端只需要了解Context这一个类即可，具体的策略算法与客户端彻底分离。而工厂模式下，客户端需要知道<code>CashSuper</code>和<code>Factory</code>两个类，耦合较高。</p><p>策略模式的<strong>优点</strong>减少了各种算法类与使用算法类之间的耦合，同时每个算法都有自己的类，简化的单元测试。策略模式就是用来封装算法的，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可已考虑使用策略模式处理这种变化的可能性。同样策略模式也有<strong>不足</strong>，比如仍然存在逻辑判断决定生成哪一种具体的策略，和抽象工厂模式类似，也可以用反射来实现。</p><p><font color="red">JDK中Arrays的Comparator就使用了策略模式</font>，Comparator是策略接口，Arrays中的sort中使用的Comparator就是具体策略。</p><h4 id="策略模式和工厂模式的区别"><a href="#策略模式和工厂模式的区别" class="headerlink" title="策略模式和工厂模式的区别"></a>策略模式和工厂模式的区别</h4><p>这两种模式在结构即为相似，除了上述的策略模式中客户端需要知道更少的类，耦合更低外，还有以下区别：</p><ul><li>用途不一样</li></ul><p>工厂模式时创建型模式，用在创建对象。策略模式是行为型模式，它的作用是让一个对象在许多行为中选择一种行为。</p><ul><li>关注点不一样</li></ul><p>一个关注对象创建，一个关注行为的封装。</p><ul><li>解决不同的问题</li></ul><p>工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例，主要解决资源统一分发，将对象的创建完全独立出来，而对象的创建与使用的客户无关。主要应用在多数据库选择，类库文件加载等。而策略模式是为了解决策略的切换与扩展，也就是定义策略组，分别封装起来，让他们之间可以相互替换，<font color="red">让策略的变化独立于策略使用者</font>。</p><ul><li>工厂模式相当于黑盒子，策略相当于白盒子</li></ul><p>举例说明：在工厂模式下，客户去吃披萨，A和B店都有，客户选择了A店，过了一会披萨就送来了，但是披萨怎么做的，配料怎样客户都不知道。在策略模式下，客户需要一个披萨，老板说有标准的披萨，也可以自己做，配料有什么，制作方法有几种，到底怎么做就取决与客户的选择了。</p><h3 id="3-2-模板方法模式"><a href="#3-2-模板方法模式" class="headerlink" title="3.2 模板方法模式"></a>3.2 模板方法模式</h3><p>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个<strong>算法的结构</strong>即可重定义该算法的某些特定步骤。</p><p>当我们要完成在某一细节层次一致的一个过程或一系列步骤，但是个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。    </p><p>通俗的理解，某一算法过程分为多个步骤，个别步骤在具体实现上有一些区别，则可以把所有步骤提取成一个抽象类，不同的细节步骤由子类来具体实现。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmStructure</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一般的方法都会加上final防止子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        run1Step();</span><br><span class="line">        run2Step();</span><br><span class="line">        run3Step();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1Step</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行相同的第一步..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这一步由具体的子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run2Step</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run3Step</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行相同的第三步..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteA</span> <span class="keyword">extends</span> <span class="title">AlgorithmStructure</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run2Step</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A具体的第二步..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>()</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行A</span></span><br><span class="line">        AlgorithmStructure A = <span class="keyword">new</span> ConcreteA();</span><br><span class="line">        A.run();</span><br><span class="line">        <span class="comment">//执行相同的第一步...</span></span><br><span class="line">        <span class="comment">//A具体的第二步...</span></span><br><span class="line">        <span class="comment">//执行相同的第三步...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>模板方法中的钩子方法</strong>表示定义一个方法，默认不做任何事情，子类可视情况而定是否重写，例如返回一个bool值，默认返回true，可重写返回false，执行相应的程序。</p><p>在Spring IOC容器初始化时运用到的模板方。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式及简单实现&quot;&gt;&lt;a href=&quot;#设计模式及简单实现&quot; class=&quot;headerlink&quot; title=&quot;设计模式及简单实现&quot;&gt;&lt;/a&gt;设计模式及简单实现&lt;/h1&gt;&lt;p&gt;根据模式是用来完成什么工作来划分，设计模式分为三种类型，共23种。&lt;/p&gt;
&lt;p&gt;①
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="设计模式" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://jwkang99.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简单实现(创建型)</title>
    <link href="https://jwkang99.github.io/posts/f9f3b918.html"/>
    <id>https://jwkang99.github.io/posts/f9f3b918.html</id>
    <published>2019-11-16T03:59:08.000Z</published>
    <updated>2020-03-26T01:33:49.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式及简单实现"><a href="#设计模式及简单实现" class="headerlink" title="设计模式及简单实现"></a>设计模式及简单实现</h1><p>根据模式是用来完成什么工作来划分，设计模式分为三种类型，共23种。</p><p>①<strong>创建型模式</strong>（5种）：<span style="color:red">单例模式</span>、抽象工厂模式、原型模式、建造者模式、<span style="color:red">工厂方法模式</span>。</p><p>②<strong>结构型模式</strong>（7种）：适配器模式、桥接模式、<span style="color:red">装饰模式</span>、组合模式、外观模式、享元模式、<span style="color:red">代理模式</span>。</p><p>③<strong>行为型模式</strong>（11种）：模板方法模式、命令模式、访问者模式、迭代器模式、<span style="color:red">观察者模式</span>、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责模式（责任链模式）。</p><h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1 创建型模式"></a>1 创建型模式</h2><p>重点强调的是对象创建的时候怎么设计代码，它的主要特点是将对象的创建与使用分离开来。创建型模式包括以下几种：<span style="color:red">单例模式</span>、抽象工厂模式、原型模式、建造者模式、<span style="color:red">工厂模式</span>。</p><h3 id="1-1-单例模式"><a href="#1-1-单例模式" class="headerlink" title="1.1 单例模式"></a>1.1 单例模式</h3><p>单例模式保证一个类只有一个实例对象，并提供一个访问它的全局访问点。</p><p>使用场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）。</p><p>单例模式共有以下几种方式。</p><h4 id="1-1-1-饿汉式（静态常量）"><a href="#1-1-1-饿汉式（静态常量）" class="headerlink" title="1.1.1 饿汉式（静态常量）"></a>1.1.1 饿汉式（静态常量）</h4><p>优点：写法简单，在类装载的时候完成实例化。<strong>避免了线程同步问题</strong>。</p><p>缺点：在类装载的时候完成实例化，没有达到懒加载的效果。如果从未使用这个实例，则会浪费内存。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此单例模式可用，但会浪费内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton_1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有，外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton_1 instance = <span class="keyword">new</span> Singleton_1();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton_1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-1-2-饿汉式（静态代码块）"><a href="#1-1-2-饿汉式（静态代码块）" class="headerlink" title="1.1.2 饿汉式（静态代码块）"></a>1.1.2 饿汉式（静态代码块）</h4><p>和上一实现方式类似，优缺点一致。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton_2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有，外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton_2 instance;</span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">//在静态代码块中创建实例对象</span></span><br><span class="line">        instance = <span class="keyword">new</span> Singleton_2()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton_2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-1-3-懒汉式（线程不安全）"><a href="#1-1-3-懒汉式（线程不安全）" class="headerlink" title="1.1.3 懒汉式（线程不安全）"></a>1.1.3 懒汉式（线程不安全）</h4><p>优点：起到了懒加载的效果，用到额才会加载。</p><p>缺点：只能在单线程下使用，线程不安全。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际开发中不使用，多线程不可用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton_3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton_3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//用到才加载</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton_3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-1-4-懒汉式（线程安全，同步方法）"><a href="#1-1-4-懒汉式（线程安全，同步方法）" class="headerlink" title="1.1.4 懒汉式（线程安全，同步方法）"></a>1.1.4 懒汉式（线程安全，同步方法）</h4><p>优点：解决了线程不安全问题</p><p>缺点：效率太低了，每个线程想要获取实例时，都要进行同步。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐使用，多线程可用，但效率太低</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton_4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton_4 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//加上synchronized关键字，加入同步机制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton_4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton_4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-1-5-懒汉式（同步代码块）"><a href="#1-1-5-懒汉式（同步代码块）" class="headerlink" title="1.1.5 懒汉式（同步代码块）"></a>1.1.5 懒汉式（同步代码块）</h4><p><strong>这种方式不可取</strong>，本意时想要对第四种方式的效率问题进行改进，实际仍会产生多个实例。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能实现线程安全，多线程不可用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton_5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton_5 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//仍会有多个线程进入if创建实例对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton_8<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton_5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-1-6-双重检查"><a href="#1-1-6-双重检查" class="headerlink" title="1.1.6 双重检查"></a>1.1.6 双重检查</h4><p>优点：保证了线程安全的情况下，实现了懒加载，避免反复进行方法同步，也保证了多线程下的效率。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile保证instance可见性，禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton_6 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//doube check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton_6<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton_6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-1-7-静态内部类"><a href="#1-1-7-静态内部类" class="headerlink" title="1.1.7 静态内部类"></a>1.1.7 静态内部类</h4><p>静态内部类特点</p><ul><li>外部类装载的时候内部类不会被装载</li><li>在调用的时候装载内部类，并且线程安全</li></ul><p>优点：</p><ul><li>这种方式利用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式Singleton_7类被装载时并不会立即实例化，二十在需要实例化时调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton_7的实例化。</li><li>类的静态属只会在第一次加载在类的时候初始化，所以JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>总的来说优点，线程安全，利用静态内部类特点实现了加载延迟，效率高</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全，效率高推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_7</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_7</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态内部类，该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton_7 INSTANCE = <span class="keyword">new</span> Singleton_7();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-1-8-枚举"><a href="#1-1-8-枚举" class="headerlink" title="1.1.8 枚举"></a>1.1.8 枚举</h4><p>借助JDK1.5中添加的枚举来实现单例。不仅能够<strong>避免多线程同步问题</strong>，还能防止反序列化重新创建新的对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全，推荐使用</span></span><br><span class="line"><span class="keyword">enum</span> Singleton_8 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">//enum的构造函数只支持private </span></span><br><span class="line">    <span class="comment">//而且因为所有枚举都继承自java.lang.Enum类 </span></span><br><span class="line">    <span class="comment">//因此枚举不能再继承其他类 但是可以实现接口</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_8</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="1-2-工厂模式"><a href="#1-2-工厂模式" class="headerlink" title="1.2 工厂模式"></a>1.2 工厂模式</h3><h4 id="1-2-1-简单工厂模式"><a href="#1-2-1-简单工厂模式" class="headerlink" title="1.2.1 简单工厂模式"></a>1.2.1 简单工厂模式</h4><p>简单工厂模式是工厂模式的一种，是由一个工厂对象决定创建出哪一种产品类的实例，是工厂模式家族最简单实用的模式。</p><p>简单的说：简单工厂模式定义了一个创建对象的类，由这个类来<strong>封装实例化对象</strong>的行为（代码）。</p><p>使用场景：当我们会大量创建某种、某类或者某批对象是，就会使用到工厂模式。</p><p>在以下简单工厂的例子中，如果没有工厂类，Store类直接接管所有车类，当有新车型C时，所有Store就都需要修改。增加工厂类，Store只负责从工厂类中拿到相应的车型，不关心车如何生产。当增加车型只需要修改工厂类的代码即可，所有store类都不需要修改。（工厂类也可使用单例或者静态方法）</p><p>优点：不需要修改客户端代码（Store类）</p><p>缺点：当需要增加新的Car类时，不仅需新Car类代码，还要修改工厂类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是A车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BCar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        ICar iCar = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"A"</span>))&#123;</span><br><span class="line">            iCar = <span class="keyword">new</span> ACar();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"B"</span>))&#123;</span><br><span class="line">            iCar = <span class="keyword">new</span> BCar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iCar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//车店1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarStore1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//简单工厂模式中，本例中</span></span><br><span class="line">    <span class="comment">//客户端需要知道两个类SimpleFactory和ICar</span></span><br><span class="line">    SimpleFactory factory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellCar</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        ICar car = factory.createCar(type);</span><br><span class="line">        <span class="keyword">if</span>(car==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"买车失败"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            car.getInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-2-2-工厂方法模式"><a href="#1-2-2-工厂方法模式" class="headerlink" title="1.2.2 工厂方法模式"></a>1.2.2 工厂方法模式</h4><p>工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p>工厂方法模式与简单工厂有所区别，简单工厂模式只有一个工厂，工厂方法模式的每一中产品都有一个工厂，抽象出一个核心工厂类。</p><p>优点：当有新增Car类型时，只需增加对应的Car类和工厂类。</p><p>缺点：会修改客户端代码，工厂方法模式将简单工厂的内部判断逻辑移到了客户端内进行，增加了用户操作的复杂性。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是A车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BCar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ICar <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A车工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACarFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ACar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B车接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BCarFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//车店1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarStore1</span> </span>&#123;</span><br><span class="line">    IFactory aFactory = <span class="keyword">new</span> ACarFactory();</span><br><span class="line">    IFactory bFactory = <span class="keyword">new</span> BCarFactory();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellCar</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        ICar car = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"A"</span>))&#123;</span><br><span class="line">            car = aFactory.createCar();</span><br><span class="line">            car.getInfo();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"B"</span>))&#123;</span><br><span class="line">            car = bFactory.createCar();</span><br><span class="line">            car.getInfo();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"买车失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-2-3-抽象工厂模式"><a href="#1-2-3-抽象工厂模式" class="headerlink" title="1.2.3 抽象工厂模式"></a>1.2.3 抽象工厂模式</h4><p>抽象工厂模式可以将简单工厂模式和工厂方法模式整合，将一组有共同特征的产品（产品族）放在同一工厂内生产。</p><p><strong>提供一个创建一系列相关或相互依赖对象的接口</strong>，而无需指定他们具体的类。我们有两个产品族，保证同一种工厂只能生产对应的产品。当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自行车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是A车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A自行车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABike</span> <span class="keyword">implements</span> <span class="title">IBike</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A自行车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BCar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B自行车B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBike</span> <span class="keyword">implements</span> <span class="title">IBike</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B自行车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ICar <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">IBike <span class="title">createBike</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A车工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"A"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ACar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBike <span class="title">createBike</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ABike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B车接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBike <span class="title">createBike</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只需要确定实例化哪一个品牌族给factory</span></span><br><span class="line">    IFactory factory = <span class="keyword">new</span> AFactory();</span><br><span class="line">    <span class="comment">//与具体某品牌的产品生产过程解除依赖</span></span><br><span class="line">    ICar ac = factory.createCar();</span><br><span class="line">    ac.getInfo();</span><br><span class="line">    IBike ab = factory.createBike();</span><br><span class="line">    ab.getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="注：简单工厂vs工厂方法vs抽象工厂"><a href="#注：简单工厂vs工厂方法vs抽象工厂" class="headerlink" title="注：简单工厂vs工厂方法vs抽象工厂"></a>注：简单工厂vs工厂方法vs抽象工厂</h4><p>简单工厂的最大<strong>优点</strong>在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。<strong>缺点</strong>在于当需要扩展时一定要在工厂类内部修改判断条件，增加判断分支，修改了原有的类，违反了开闭原则。</p><p>工厂方法实现时，<strong>优点</strong>在于扩展新的功能模块时完全符合开闭原则。<strong>缺点</strong>是客户端需要决定实例化哪一个工厂生产具体的产品，选择判断的问题还是存在，也就是工厂方法将简单工厂的内部逻辑判断移到了客户端，选择新加的功能则要修改客户端。</p><p>抽象工厂最大的<strong>优点</strong>是易于交换产品系列，由于具体工厂类在一个应用中只需要初始化的时候出现一次，这使得改变一个应用的具体工厂非常容易，只需要改变具体工厂即可使用不同的产品配置。第二个<strong>优点</strong>是让具体的创建产品实例过程与客户端分离，客户端时通过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。<strong>缺点</strong>是当两个品牌都新增产品时，需要修改的类过多，<code>IFactory</code>及其实现都要修改。另外，当有多个客户端时，客户都想要更换产品族则每个客户端都要进行修改。</p><h4 id="1-2-4-用简单工厂改进抽象工厂"><a href="#1-2-4-用简单工厂改进抽象工厂" class="headerlink" title="1.2.4 用简单工厂改进抽象工厂"></a>1.2.4 用简单工厂改进抽象工厂</h4><p>利用简单工厂改进抽象工厂改进上述缺点，去掉众多工厂类，取而代之的是统一的<code>Provider</code>类。当新增产品时，只需在该类中增加方法即可，不需要修改众多的工厂类，并且客户端中没有出现任何与品牌相关的字样，达到了解耦的目的。但是有一个只<strong>致命缺点</strong>，当新增一个品牌时，原先在抽象工厂方法中只需增加一个工厂即可，现在就需要修改<code>Provider</code>中的条件语句。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A和B的Car、Bike实现与上相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String type=<span class="string">"A"</span>;</span><br><span class="line">    <span class="comment">//private static String type="B";</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ICar <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ICar car = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"A"</span>.equals(type))&#123;</span><br><span class="line">            car = <span class="keyword">new</span> ACar();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"B"</span>.equals(type))&#123;</span><br><span class="line">            car = <span class="keyword">new</span> BCar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBike <span class="title">createBike</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IBike bike = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"A"</span>.equals(type))&#123;</span><br><span class="line">            bike = <span class="keyword">new</span> ABike();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"B"</span>.equals(type))&#123;</span><br><span class="line">            bike = <span class="keyword">new</span> BBike();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端直接得到相应的产品族实例，不存在仍和依赖</span></span><br><span class="line">    ICar ac = Provider.createCar();</span><br><span class="line">    ac.getInfo();</span><br><span class="line">    IBike ab = Provider.createBike();</span><br><span class="line">    ab.getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="1-2-5-利用反射改进抽象工厂"><a href="#1-2-5-利用反射改进抽象工厂" class="headerlink" title="1.2.5 利用反射改进抽象工厂"></a>1.2.5 利用反射改进抽象工厂</h4><p>代码如下，通过type字段和反射机制，实例化相应的产品。当新增产品时只需在<code>Provide</code>中新增方法，新增品牌时，除了新增相应品牌的实体类，无需做其他修改。<strong>缺点</strong>，当需要切换品牌时仍需修改type字段。可通过配置文件的方法，从而实现不修改任何类完成产品切换，代码这里就不写了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String type=<span class="string">"A"</span>;</span><br><span class="line">    <span class="comment">//private static String type="B";</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ICar <span class="title">createCar</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ICar car = (ICar) Class.forName(type+<span class="string">"Car"</span>).newInstance();</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBike <span class="title">createBike</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IBike bike = (ICar) Class.forName(type+<span class="string">"Car"</span>).newInstance();</span><br><span class="line">        <span class="keyword">return</span> bike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端直接得到相应的产品族实例，不存在仍和依赖</span></span><br><span class="line">    ICar ac = Provider.createCar();</span><br><span class="line">    ac.getInfo();</span><br><span class="line">    IBike ab = Provider.createBike();</span><br><span class="line">    ab.getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>所有在有简单工厂的地方，都可以考虑用反射来去除switch和if语句，接触分支判断带来的耦合</strong>！</p><h3 id="1-3-原型模式"><a href="#1-3-原型模式" class="headerlink" title="1.3 原型模式"></a>1.3 原型模式</h3><p>原型模式（Prototype），用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<strong>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节</strong>。通过原型对象.clone()创建新的对象。</p><p>在克隆羊的例子中，传统方法中每克隆一只羊都要重新获取原始对象的每个属性，并且重新初始化对象，而不是动态地获得对象运行时地状态，不够灵活，如果创建地对象比较复杂，效率低。</p><p>原型模式结构图：</p><p><a href="/posts/f9f3b918/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%5Cprototype.jpg" data-fancybox="group" data-caption="prototype" class="fancybox"><img alt="prototype" data-src="/posts/f9f3b918/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%5Cprototype.jpg" class="lazyload" title="prototype"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据类图中的结构大致实现如下</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title">Clone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototypeA</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototypeA</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">Clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ConcretePrototypeA p1 = <span class="keyword">new</span> ConcretePrototypeA(<span class="string">"AAA"</span>);</span><br><span class="line">        ConcretePrototypeA c1 = (ConcretePrototypeA)p1.Clone();</span><br><span class="line">        System.out.println(c1.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><font color="red">注：</font>Java中Object类时所有类的根类，Object的方法提供了一个clone()方法，可以将Java对象复制一份，但是需要实现clone的Java类必须实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力。（这就是原型模式）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用java中Object中的clone()实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用默认的Object中的clone完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep= (Sheep) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"TOM"</span>);</span><br><span class="line">        Sheep sheep1 = (Sheep) sheep.clone();</span><br><span class="line">        <span class="comment">//两个Sheep对象并不是同一个，也不是new出来的</span></span><br><span class="line">        System.out.println(sheep); <span class="comment">//Sheep@154617c</span></span><br><span class="line">        System.out.println(sheep1);<span class="comment">//Sheep@a14482</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Spring中往IOC容器中注入bean可以配置为原型模式(Prototype)。（?）</p><h4 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h4><ul><li>浅拷贝</li></ul><p>上述例子和结构图都为浅拷贝。</p><p>当原型对象的成员变量是基本数据类型时，浅拷贝会直接将值传递，即复制一份给新的对象；若成员变量时引用类型时，比如某个数组或某个类的对象，那么浅拷贝会进行引用传递，即拷贝出来的副本对象的该成员属性与原型对象的属性<strong>指向同一个对象实例</strong>，在原型对象修改该成员变量时，所有对象的该属性都受到影响。浅拷贝是使用<strong>默认</strong>的clone()完成的。</p><ul><li>深拷贝</li></ul><p>与浅拷贝相对，深拷贝复制原型对象的所有基本数据类型的成员变量值。为所有引用类型的成员变量申请存储空间，并且对引用类型的成员变量也进行拷贝，那么原型对象和副本的属性指向的就不是同一个对象。<strong>深拷贝深入到多少层要视情况而定，否则会出现循环引用</strong>。</p><p>深拷贝实现方式：<font color="red">重写clone()</font>或者<font color="red">通过对象序列化</font>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="comment">//使用java中Object中的clone()实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Serialiazable</span>,<span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Sheep wife;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝方式1：重写clone完成深拷贝</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep= (Sheep) <span class="keyword">super</span>.clone();</span><br><span class="line">            sheep.wife = (Sheep)wife.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝方式2：对象序列化实现（推荐）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            <span class="comment">//以对象流的方式输出</span></span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteInputStream(bos.toByteArray(),bos.toByteArray().length);</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            Sheep copySheep = (Sheep) ois.readObject();</span><br><span class="line">            <span class="keyword">return</span> copySheep;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="1-4-建造者模式"><a href="#1-4-建造者模式" class="headerlink" title="1.4 建造者模式"></a>1.4 建造者模式</h3><p><strong>将一个复杂对象的构建与它的表示分离</strong>，使得同样的构建过程可以创建不同的表示。用户只需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不知道了。</p><p>建造者中有四个角色：<br>①Product（产品）：一个具体的产品对象<br>②Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口/抽象类<br>③ConcreteBuiler（具体建造者）：实现接口，狗i教案和装配各个部件<br>④Director（指挥者）：构建一个使用Builer接口的对象，主要用于创建一个复杂的对象。作用有两个，一是隔离了客户与对象的生产过程，二是负责控制产品对象的生产过程。</p><a href="/posts/f9f3b918/builder.jpg" data-fancybox="group" data-caption="decorator" class="fancybox"><img alt="decorator" style="zoom:50%;" data-src="/posts/f9f3b918/builder.jpg" class="lazyload" title="decorator"></a><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String basic;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roof;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象的建造者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildRoof</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//将产品返回，在buildHouse中可以组合固定建造顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommonHouse Basic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommonHouse Wall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildRoof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommonHouse Roof"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpecialHouse Basic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpecialHouse Wall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildRoof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpecialHouse Roof"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体如何建房子交给指挥者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWall();</span><br><span class="line">        houseBuilder.buildRoof();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CommonHouse c = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        SpecialHouse s = <span class="keyword">new</span> SpecialHouse();</span><br><span class="line">        HouseDirector d = <span class="keyword">new</span> HouseDirector(c);</span><br><span class="line">        House house = director.getHouse();</span><br><span class="line">        <span class="comment">//CommonHouse Basic</span></span><br><span class="line"><span class="comment">//CommonHouse Wall</span></span><br><span class="line"><span class="comment">//CommonHouse Roof</span></span><br><span class="line">        HouseDirector d = <span class="keyword">new</span> HouseDirector(s);</span><br><span class="line">        House house1 = director.getHouse();</span><br><span class="line">        <span class="comment">//SpecialHouse Basic</span></span><br><span class="line"><span class="comment">//SpecialHouse Wall</span></span><br><span class="line"><span class="comment">//SpecialHouse Roof</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>java中的StringBuilder用的就是建造者模式。    </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似于StirngBuilder里的源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attr1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attr2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attr3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        attr1 = builder.attr1;</span><br><span class="line">        attr2 = builder.attr2;</span><br><span class="line">        attr3 = builder.attr3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> attr1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> attr2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> attr3 = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//修改属性 返回this</span></span><br><span class="line">        Builder(<span class="keyword">int</span> attr1)&#123;</span><br><span class="line">            <span class="keyword">this</span>.attr1 = attr1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">attr2</span><span class="params">(<span class="keyword">int</span> attr2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attr2 = attr2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">attr3</span><span class="params">(<span class="keyword">int</span> attr3)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attr3 = attr3;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用MyClass构造函数传入Builder对象构建 返回MyClass对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyClass <span class="title">Build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyClass(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"attr1:"</span>+attr1+<span class="string">" attr2:"</span>+attr2+<span class="string">" attr3:"</span>+attr3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass obj1 = <span class="keyword">new</span> MyClass.Builder(<span class="number">1</span>).attr2(<span class="number">20</span>).attr3(<span class="number">30</span>).Build();</span><br><span class="line">        System.out.println(obj2);<span class="comment">//attr1:1 attr2:20 attr3:30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>使用建造者模式的好处：<br>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。<br>使用建造者模式的场合:<br>1.创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。<br>2.要创建的复杂对象的算法，独立于该对象的组成部分，也独立于组成部分的装配方法时。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式及简单实现&quot;&gt;&lt;a href=&quot;#设计模式及简单实现&quot; class=&quot;headerlink&quot; title=&quot;设计模式及简单实现&quot;&gt;&lt;/a&gt;设计模式及简单实现&lt;/h1&gt;&lt;p&gt;根据模式是用来完成什么工作来划分，设计模式分为三种类型，共23种。&lt;/p&gt;
&lt;p&gt;①
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="设计模式" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://jwkang99.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式的七大原则概述</title>
    <link href="https://jwkang99.github.io/posts/364ea8cc.html"/>
    <id>https://jwkang99.github.io/posts/364ea8cc.html</id>
    <published>2019-11-15T08:18:49.000Z</published>
    <updated>2020-03-23T13:36:08.211Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式的出现是为了让程序（软件）具有更好的①代码可重用性②可读性③可扩展性④可靠性⑤使程序或软件高内聚、低耦合。</p><p>本文将对设计模式的七大原则进行一个简单的说明。</p><h1 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h1><p>设计模式很大程度上是面向对象设计原则的体现，常用的面向对象设计原则包括七个，这些原则相互依赖，相互补充。这些原则其实就是<strong>程序员在变成是应当遵守的原则</strong>，也是各种<strong>设计模式的基础</strong>（设计模式为什么这样设计的依据）。</p><h2 id="1-单一职责原则-Single-Responsibility-Principle"><a href="#1-单一职责原则-Single-Responsibility-Principle" class="headerlink" title="1 单一职责原则(Single Responsibility Principle)"></a>1 单一职责原则(Single Responsibility Principle)</h2><p>单一职责原则（Single Responsibility Principle）：对类来说，即一个类应该只负责一项职责，不能将太多的职责放在一个类中，控制类的粒度大小。</p><p>单一职责原则注意事项和细节：</p><ul><li>降低类的负责都，一个类负责一项职责</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，<strong>我们应当遵守单一职责原则</strong>，只有逻辑足够简单，才可以在类级别违反单一职责原则；只有类中方法数量足够少，可以再方法级别上保持单一职责原则。</li></ul><h2 id="2-开闭原则"><a href="#2-开闭原则" class="headerlink" title="2 开闭原则"></a>2 开闭原则</h2><p>开闭原则（Open Close Principle）是编程中最基础、最重要的原则。</p><p>一个软件实体，如类，应该<strong>对扩展开放（对提供方）</strong>，<strong>对修改关闭（对使用方）</strong>，用抽象构建框架，用实现扩展细节。</p><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。所以一句话概括：为了程序的扩展性好，易于维护和升级。想要达到这样的效果，需要使用到接口和抽象类。</p><p>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。</p><h2 id="3-里氏代换原则"><a href="#3-里氏代换原则" class="headerlink" title="3 里氏代换原则"></a>3 里氏代换原则</h2><p>里氏代换原则（Liskov Substitution Principle）：是面向对象设计的基本原则之一，所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p><p>例：T2是T1的子类型，如果所有类T1的对象o1，都有类T2的对象o2，使得以T1定义的所有程序p在所有对象o1都替换成o2时，程序p的行为没有发生变化，那么满足里氏代换原则。</p><p><strong>分析</strong>：</p><ul><li>在使用继承时，遵循里氏代换原则，在<strong>子类中尽量不要重写父类中的方法</strong>。</li><li>继承实际上让两个类耦合性增强了，如果不得已必须重写父类的多个方法，可以在适当的情况下可以通过聚合，组合，依赖来解决问题，（即取消原有的继承关系，可继承更通俗的base类）。</li></ul><h2 id="4-依赖倒转原则"><a href="#4-依赖倒转原则" class="headerlink" title="4 依赖倒转原则"></a>4 依赖倒转原则</h2><p>依赖倒转原则（Dependence Inversion Principle）：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p><strong>中心思想</strong>：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</p><p><strong>注意和细节</strong>：</p><ul><li>底层模块尽量都要有抽象类或接口，程序稳定星更好。</li><li>变量的声明类型尽量是抽象类或这接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于成旭扩展和优化。</li><li>继承是遵循里氏替换原则。</li></ul><h2 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5 接口隔离原则"></a>5 接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle）：客户端不应该依赖那些它不需要的接口，即一个类对另外一个类的以来应该建立在最小的接口上。</p><p>如下图，类B和类D实现接口Interface，类A和类C通过接口分别依赖B,D。但是类A只需要1，2，3三个方法，类B只需要1，4，5三个方法。</p><a href="/posts/364ea8cc/接口隔离.jpg" data-fancybox="group" data-caption="接口隔离" class="fancybox"><img alt="接口隔离" style="zoom:67%;" data-src="/posts/364ea8cc/接口隔离.jpg" class="lazyload" title="接口隔离"></a><p><strong>注意事项</strong></p><ul><li>类A通过接口Interface依赖类B，类C通过接口Interface依赖类D，如果Interface对于类A和类C来说不是最小接口，那么类B和类D就必须去实现不必要的方法。</li><li>将接口Interface拆分为独立的几个接口，类A和类C分别与他们需要的接口建立以来关系，也就是遵守接口隔离原则。</li></ul><a href="/posts/364ea8cc/接口隔离2.jpg" data-fancybox="group" data-caption="接口隔离" class="fancybox"><img alt="接口隔离" style="zoom:67%;" data-src="/posts/364ea8cc/接口隔离2.jpg" class="lazyload" title="接口隔离"></a><h2 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6 合成复用原则"></a>6 合成复用原则</h2><p>合成复用原则（Composite Reuse Principle）：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="7-迪米特法则（最少知道原则）"><a href="#7-迪米特法则（最少知道原则）" class="headerlink" title="7 迪米特法则（最少知道原则）"></a>7 迪米特法则（最少知道原则）</h2><p>迪米特法则（Demeter Principle）：一个实体应当尽量少的与其他实体之间发生相互作用，是的系统的功能模块相对独立。</p><p>迪米特法则还有个更简单的定义：至于直接的朋友通信。</p><p><strong>直接的朋友</strong>：类中出现其他类的成员变量，方法参数，方法返回值，都为直接朋友。而出现在局部变量的类不是直接朋友。也就是说陌生的类最好不要以方法局部变量的形式出现在类的内部。</p><p><strong>分析</strong>：当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
&lt;p&gt;设计模式的出现是为了让程序（软件）具有更好的①代码可重用性②可读性③可扩展性④可靠性⑤使程序或软件高内聚、低耦合。&lt;/p
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="设计模式" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://jwkang99.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTTP范围请求</title>
    <link href="https://jwkang99.github.io/posts/b1fd81d6.html"/>
    <id>https://jwkang99.github.io/posts/b1fd81d6.html</id>
    <published>2019-10-12T16:00:00.000Z</published>
    <updated>2020-07-10T09:46:34.705Z</updated>
    
    <content type="html"><![CDATA[<p>​        人们下载文件时断网重连之后，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p><p>​        要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。基于范围请求也可实现多线程分片下载。</p><p>​        只有双端（客户端和服务器端）都支持HTTP/1.1才能使用范围请求。</p><h4 id="1-范围请求的请求报文"><a href="#1-范围请求的请求报文" class="headerlink" title="1.范围请求的请求报文"></a>1.范围请求的请求报文</h4><p>​        在HTTP/1.1的请求报文中，有一个首部字段<code>Range</code>来指定请求资源的byte范围。</p><p>范围请求报文示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /tip.jpg HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Range: bytes =5001-10000</span><br></pre></td></tr></table></figure></div><p>想要继续下载后边的字节在请求头加<code>Ranges:bytes=10000-</code>即可。</p><p>​        byte范围指定形式如下：</p><ul><li>5001-10000：指定开始和结束的范围</li><li>5001- ：指定开始区间，表示从5001字节之后的所有内容</li><li>-3000：指定结束区间，表示从一开始到3000字节</li><li>-3000, 5001-：表示多重范围</li></ul><h4 id="2-范围请求的响应报文"><a href="#2-范围请求的响应报文" class="headerlink" title="2.范围请求的响应报文"></a>2.范围请求的响应报文</h4><p>​        针对范围请求，通过响应头<code>Accept-Ranges:bytes</code>表示当前资源支持范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。针对请求报文中的Range字段，响应报文中也又响应的字段<code>Content-Range</code>来标记响应的实体内容范围。</p><p>范围请求的响应报文示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Date: Fri, 13 Jul 2019 17:38:17 GMT</span><br><span class="line">Content-Range: bytes 5001-10000/10000</span><br><span class="line">Content-Length: 5000</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure></div><p>​        <code>Content-Range</code>字段的格式如上，首先表示单位是byte，然后表明本次响应的实体长度，和所请求资源的总长度，上例则表示本次响应了从5001到10000字节的图片，该图片的总大小为10000字节。而<code>Content-Length</code>表示的是此次响应的实体内容长度。</p><p>​        <strong>另外，</strong>对于多重范围请求，响应会在首部字段<code>Content-Type</code>标明<code>multipart/byteranges</code>后返回响应报文。</p><p>​        如果服务器不安无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p><h4 id="3-请求失效"><a href="#3-请求失效" class="headerlink" title="3.请求失效"></a>3.请求失效</h4><p>​        在下载文件时暂停，继续时从头开始。可能时http请求失效了，也有可能是所请求的资源在这个过程中发生了变化，比如后台开发者更新了这个图片。如果下载的过程中服务器端资源更新了，而下载的URL没有变，如果能够继续下载，下载完成之后就可能出现两部分不能正确拼接的错误情况。</p><p>​        在HTTP协议中，响应报文可以通过<code>ETag</code>字段或者<code>Last-Modified</code>字段标识资源是否更新。请求报文则使用<code>If-Range</code>字段把<code>ETag</code>字段或者<code>Last-Modified</code>字段的内容复制即可。</p><p>​        如果两次操作都是同一个资源，则返回206，并继续后续操作。否则则返回200，重新开始下载。</p><p><a href="/posts/b1fd81d6/164c57b24948a9a2.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/b1fd81d6/164c57b24948a9a2.jpg" class="lazyload"></a></p><p>（内容参考《图解HTTP》和<a href="https://www.cnblogs.com/plokmju/p/http_range.html）" target="_blank" rel="noopener">https://www.cnblogs.com/plokmju/p/http_range.html）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        人们下载文件时断网重连之后，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。&lt;/p&gt;
&lt;p&gt;​        要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。基于范围请求也可实现多线程
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="http" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/http/"/>
    
    
      <category term="知识记录" scheme="https://jwkang99.github.io/tags/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    
      <category term="http" scheme="https://jwkang99.github.io/tags/http/"/>
    
      <category term="范围请求" scheme="https://jwkang99.github.io/tags/%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82/"/>
    
      <category term="断点续传" scheme="https://jwkang99.github.io/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS图解</title>
    <link href="https://jwkang99.github.io/posts/cbcc831f.html"/>
    <id>https://jwkang99.github.io/posts/cbcc831f.html</id>
    <published>2019-10-12T07:02:48.000Z</published>
    <updated>2020-07-10T09:41:39.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-HTTP的不足"><a href="#1-HTTP的不足" class="headerlink" title="1.HTTP的不足"></a>1.HTTP的不足</h4><ul><li>通信使用明文（不加密），内容会被窃听</li><li>不验证通信方的的身份，因此有可能遭遇伪装</li><li>无法验证报文的完整性，所以可能被篡改</li></ul><p>这些问题不仅在HTTP上出现，其他未加密的协议中也会存在这类问题。</p><p><strong>另外</strong>，如果只是对传输内容进行加密，通信内容同样会被窥视到，只不过就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。<strong>因此</strong>，通信内容仍然有被篡改的风险。</p><p>如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页 面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号和密码就暴露了。</p><h4 id="2-HTTPS"><a href="#2-HTTPS" class="headerlink" title="2.HTTPS"></a>2.HTTPS</h4><h5 id="加密处理防止被窃听"><a href="#加密处理防止被窃听" class="headerlink" title="加密处理防止被窃听"></a>加密处理防止被窃听</h5><ul><li><p>通信的加密</p><p>HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用加密HTTP的通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。</p><p><a href="/posts/cbcc831f/image-20200301213039998.png" data-fancybox="group" data-caption="image-20200301213039998" class="fancybox"><img alt="image-20200301213039998" style="zoom:50%;" title="image-20200301213039998" data-src="/posts/cbcc831f/image-20200301213039998.png" class="lazyload"></a></p></li><li><p>内容的加密</p><p>还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中 没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。 在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。</p><p><a href="/posts/cbcc831f/image-20200301213133133.png" data-fancybox="group" data-caption="image-20200301213133133" class="fancybox"><img alt="image-20200301213133133" style="zoom:50%;" title="image-20200301213133133" data-src="/posts/cbcc831f/image-20200301213133133.png" class="lazyload"></a></p></li></ul><h5 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS=HTTP+加密+认证+完整性保护"></a>HTTPS=HTTP+加密+认证+完整性保护</h5><p>HTTPS并不是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p><p><a href="/posts/cbcc831f/image-20200301213708496.png" data-fancybox="group" data-caption="image-20200301213708496" class="fancybox"><img alt="image-20200301213708496" style="zoom:50%;" title="image-20200301213708496" data-src="/posts/cbcc831f/image-20200301213708496.png" class="lazyload"></a></p><p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应 用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。</p><p>HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。由于非对称加密与对称加密相比，其处理速度要慢，若密钥能够实现安全交换，则优先使用对称加密来通信。<br>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。</p><p><strong>HTTPS采用混合加密机制</strong>，即采用了对称加密和非对称加密，图中的公开密钥加密即为通过非对称密钥加密，共享密钥解密即为对称加密。</p><p><a href="/posts/cbcc831f/image-20200301213913892.png" data-fancybox="group" data-caption="image-20200301213913892" class="fancybox"><img alt="image-20200301213913892" style="zoom:55%;" title="image-20200301213913892" data-src="/posts/cbcc831f/image-20200301213913892.png" class="lazyload"></a></p><p><strong>非对称加密中的问题</strong>：</p><p>在交换公开密钥的过程中，原本的公开密钥有可能被替换，从而收到攻击者发送的公开密钥。那么后续的加密传输就形同虚设了。</p><ul><li>为了解决上述问题，可以使用由<strong>数字证书认证机构</strong>（CA，Certificate Authority）和其相关机关颁发的<strong>公开密钥证书</strong>。</li></ul><blockquote><p>公钥证书大致流程：</p><p>​        首先，服务器 的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证 机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签 名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书 后绑定在一起。</p><p>​        服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称 为证书。</p><p>​        接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书 上的数字签名进行验证，一旦验证通过，客户端便可明确两件事： 一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二， 服务器的公开密钥是值得信赖的。</p><p>​        此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布浏览器时，会事先在内部植入常用认证机关的公开密钥。</p></blockquote><p><a href="/posts/cbcc831f/TIM截图20200301220224.png" data-fancybox="group" data-caption="TIM截图20200301220224" class="fancybox"><img alt="TIM截图20200301220224" title="TIM截图20200301220224" data-src="/posts/cbcc831f/TIM截图20200301220224.png" class="lazyload"></a></p><ul><li><p><strong>可证明组织真实性的 EV SSL 证书</strong></p><p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另 外一个作用是可确认对方服务器背后运营的企业是否真实存在。 拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certificate）。 </p><p>持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色 的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL 证书中记录的组织名称以及颁发证书的认证机构的名称。</p></li><li><p><strong>用以确认客户端的客户端证书</strong></p><p>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认 证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。</p><p>想获取证书时，用户得自行安装客户端证书。但由于客户端证书 是要付费购买的，且每张证书对应到每位用户也就意味着需支付 和用户数对等的费用。另外，要让知识层次不同的用户们自行安 装证书，这件事本身也充满了各种挑战。<br>现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。<br>例如，银行的网上银行就采用了客户端证书。在登录网银时不仅 要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以 确认用户是否从特定的终端访问网银。</p></li></ul><h4 id="3-HTTPS的安全通信机制"><a href="#3-HTTPS的安全通信机制" class="headerlink" title="3.HTTPS的安全通信机制"></a>3.HTTPS的安全通信机制</h4><p><a href="/posts/cbcc831f/TIM截图20200301220224.png" data-fancybox="group" data-caption="TIM截图20200301220224" class="fancybox"><img alt="TIM截图20200301220224" style="zoom:50%;" title="TIM截图20200301220224" data-src="/posts/cbcc831f/TIM截图20200301220224.png" class="lazyload"></a></p><p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的 加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。  </p><p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准</p><p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 9： 服务器同样发送 Finished 报文。</p><p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接 就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p><p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><p>下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥 证书（服务器证书）建立 HTTPS 通信的整个过程。</p><p><a href="/posts/cbcc831f/image-20200301221424525.png" data-fancybox="group" data-caption="image-20200301221424525" class="fancybox"><img alt="image-20200301221424525" style="zoom:50%;" title="image-20200301221424525" data-src="/posts/cbcc831f/image-20200301221424525.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-HTTP的不足&quot;&gt;&lt;a href=&quot;#1-HTTP的不足&quot; class=&quot;headerlink&quot; title=&quot;1.HTTP的不足&quot;&gt;&lt;/a&gt;1.HTTP的不足&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文（不加密），内容会被窃听&lt;/li&gt;
&lt;li&gt;不验证通信方的的
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="http" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/http/"/>
    
    
      <category term="https" scheme="https://jwkang99.github.io/tags/https/"/>
    
      <category term="知识记录" scheme="https://jwkang99.github.io/tags/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础知识</title>
    <link href="https://jwkang99.github.io/posts/df41aea9.html"/>
    <id>https://jwkang99.github.io/posts/df41aea9.html</id>
    <published>2019-09-22T12:37:00.000Z</published>
    <updated>2020-03-22T15:01:25.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1.常见操作"></a>1.常见操作</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>Tab：命令和文件名补全</li><li>Ctrl+C：终端正在运行的程序</li><li>Ctrl+D：结束键盘输入（End of File，EOF）</li></ul><h2 id="求助"><a href="#求助" class="headerlink" title="求助"></a>求助</h2><h3 id="1-–help"><a href="#1-–help" class="headerlink" title="1. –help"></a>1. –help</h3><p>指令的基本用法与选项介绍</p><h3 id="2-man"><a href="#2-man" class="headerlink" title="2. man"></a>2. man</h3><p>man是manual的缩写，将指令的具体信息显示出来，例如man git。</p><p>当执行<code>man date</code>时，有DATE(1)出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p><table><thead><tr><th>代号</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>用户在 shell 环境中可以操作的指令或者可执行文件</td></tr><tr><td>5</td><td>配置文件</td></tr><tr><td>8</td><td>系统管理员可以使用的管理指令</td></tr></tbody></table><h3 id="3-info"><a href="#3-info" class="headerlink" title="3. info"></a>3. info</h3><p>info和man类似，但是info将文档分为一个个页面，每个页面可以跳转。</p><h3 id="4-doc"><a href="#4-doc" class="headerlink" title="4. doc"></a>4. doc</h3><p>/usr/share/doc存档这软件的一整套说明文件、</p><h3 id="关机"><a href="#关机" class="headerlink" title="## 关机"></a>## 关机</h3><h3 id="1-who"><a href="#1-who" class="headerlink" title="1. who"></a>1. who</h3><p>在关机前需要先使用who命令查看有没有其他用户在线。</p><h3 id="2-sync"><a href="#2-sync" class="headerlink" title="2. sync"></a>2. sync</h3><p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行sunc同步操作。</p><h3 id="3-shutdown"><a href="#3-shutdown" class="headerlink" title="3.shutdown"></a>3.shutdown</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># shutdown [-krhc] 时间 [信息]</span><br><span class="line">-k ： 不会关机，只是发送警告信息，通知所有在线的用户</span><br><span class="line">-r ： 将系统的服务停掉后就重新启动</span><br><span class="line">-h ： 将系统的服务停掉后就立即关机</span><br><span class="line">-c ： 取消已经在进行的 shutdown</span><br></pre></td></tr></table></figure></div><h2 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h2><p>可以在环境变量PATH中声明可执行文件的路径，路径之间用：分隔。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;home&#x2F;dmtsai&#x2F;.local&#x2F;bin:&#x2F;home&#x2F;dmtsai&#x2F;bin</span><br></pre></td></tr></table></figure></div><p>修改PATH的方法有很多，例如</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;new&#x2F;bin</span><br></pre></td></tr></table></figure></div><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>sudo允许一般用户使用root可执行的命令，不过只有在/etc/sudoers配置文件中添加的用户才可以使用该命令。</p><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><p>RPM和DPKG为最常见的两类软件包管理工具。</p><ul><li>RPM全称为Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。</li><li>与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。</li></ul><h2 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h2><p>Linux发行版是Linux内核及各种应用软件的集成版本。</p><table><thead><tr><th>基于的包管理工具</th><th>商业发行版</th><th>社区发行版</th></tr></thead><tbody><tr><td>RPM</td><td>Red Hat</td><td>Fedora / CentOS</td></tr><tr><td>DPKG</td><td>Ubuntu</td><td>Debian</td></tr></tbody></table><h2 id="VIM三个模式"><a href="#VIM三个模式" class="headerlink" title="VIM三个模式"></a>VIM三个模式</h2><p><a href="/posts/df41aea9/vim.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/df41aea9/vim.png" class="lazyload"></a></p><ul><li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li><li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li><li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li></ul><p>在指令列模式下，有以下命令：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>写入磁盘</td></tr><tr><td>:w!</td><td>当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr><tr><td>:q</td><td>离开</td></tr><tr><td>:q!</td><td>强制离开不保存</td></tr><tr><td>:wq</td><td>写入磁盘后离开</td></tr><tr><td>:wq!</td><td>强制写入磁盘后离开</td></tr></tbody></table><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h2><p>GNU计划，它的目标是创建一套完全自由的操作系统，成为GNU，其内容软件完全以GPL方式发布，。其中，GPL全程为GNU通用公共许可协议（GNU General Public License），包含了以下内容：</p><ul><li>以任何目的运行此程序的自由；</li><li>再复制的自由；</li><li>改进此程序，并公开发布改进的自由。</li></ul><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">如何选择开源协议</a></li></ul><h1 id="二、磁盘"><a href="#二、磁盘" class="headerlink" title="二、磁盘"></a>二、磁盘</h1><h2 id="磁盘接口和磁盘文件名"><a href="#磁盘接口和磁盘文件名" class="headerlink" title="磁盘接口和磁盘文件名"></a>磁盘接口和磁盘文件名</h2><p>接口有SATA、SAS、SCSI、IDE等四种接口。</p><p>Linux中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p><ul><li>IDE磁盘：/dev/hd[a-d]</li><li>SATA/SCSI/SAS磁：/dev/sd[a-p]</li></ul><h1 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h1><p>磁盘分区表主要有两种格式，一种是限制较多的MBR分区表，一种是较新且限制较少的GPT分区表。</p><h1 id="四、文件系统"><a href="#四、文件系统" class="headerlink" title="四、文件系统"></a>四、文件系统</h1><h1 id="五、文件"><a href="#五、文件" class="headerlink" title="五、文件"></a>五、文件</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>用户分为三种：文件拥有者、群组以及其他人，对不同的用户有不同的文件权限。</p><p>使用ls查看一个文件时，会显示一个文件的信息，例如<code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li><li>3：链接数</li><li>root：文件拥有者</li><li>root：所属群组</li><li>17：文件大小</li><li>May 6 00:14：文件最后被修改的时间</li><li>.config：文件名</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul><p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p><p>文件时间有以下三种：</p><ul><li>modification time (mtime)：文件的内容更新就会更新；</li><li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li><li>access time (atime)：读取文件时就会更新。</li></ul><h2 id="文件与目录的基本操作"><a href="#文件与目录的基本操作" class="headerlink" title="文件与目录的基本操作"></a>文件与目录的基本操作</h2><h3 id="1-ls"><a href="#1-ls" class="headerlink" title="1.ls"></a>1.ls</h3><p>列出文件或者目录的信息， 目录的信息就是其中包含的文件。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls [-aAdfFhilnrRSt] file|dir</span><br><span class="line">-a ：列出全部的文件</span><br><span class="line">-d ：仅列出目录本身</span><br><span class="line">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span><br></pre></td></tr></table></figure></div><h3 id="2-cd"><a href="#2-cd" class="headerlink" title="2.cd"></a>2.cd</h3><p>更换当前目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure></div><h3 id="3-mkdir"><a href="#3-mkdir" class="headerlink" title="3.mkdir"></a>3.mkdir</h3><p>创建目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mkdir [-mp] 目录名称</span><br><span class="line">-m ：配置目录权限</span><br><span class="line">-p ：递归创建目录  例mkdir -p a&#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure></div><h3 id="4-rmdir"><a href="#4-rmdir" class="headerlink" title="4.rmdir"></a>4.rmdir</h3><p>删除目录，目录必须为空</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br><span class="line">-p ：递归删除目录</span><br></pre></td></tr></table></figure></div><h3 id="5-touch"><a href="#5-touch" class="headerlink" title="5.touch"></a>5.touch</h3><p>更新文件时间或者建立新文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># touch [-acdmt] filename</span><br><span class="line">-a ： 更新 atime</span><br><span class="line">-c ： 更新 ctime，若该文件不存在则不建立新文件</span><br><span class="line">-m ： 更新 mtime</span><br><span class="line">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date&#x3D;&quot;日期或时间&quot;</span><br><span class="line">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure></div><h3 id="6-cp"><a href="#6-cp" class="headerlink" title="6.cp"></a>6.cp</h3><p>复制文件，如果源文件有两个以上，则目的文件一定要是目录才行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp [-adfilprsu] source destination</span><br><span class="line">-a ：相当于 -dr --preserve&#x3D;all</span><br><span class="line">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖前会先询问</span><br><span class="line">-p ：连同文件的属性一起复制过去</span><br><span class="line">-r ：递归复制</span><br><span class="line">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span><br><span class="line">--preserve&#x3D;all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span><br></pre></td></tr></table></figure></div><h3 id="7-rm"><a href="#7-rm" class="headerlink" title="7.rm"></a>7.rm</h3><p>删除文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rm [-fir] 文件或目录</span><br><span class="line">-r ：递归删除</span><br></pre></td></tr></table></figure></div><h3 id="8-mv"><a href="#8-mv" class="headerlink" title="8.mv"></a>8.mv</h3><p>移动文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mv [-fiu] source destination</span><br><span class="line"># mv [options] source1 source2 source3 .... directory</span><br><span class="line">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br></pre></td></tr></table></figure></div><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r:4、w:2、x:1。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chmod [-R] xyz dirname&#x2F;filename</span><br><span class="line">示例：将.bashrc 文件的权限修改为 -rwxr-xr--</span><br><span class="line"># chmod 754 .bashrc</span><br></pre></td></tr></table></figure></div><p>也可以使用符号来设定权限。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># chmod [ugoa]  [+-&#x3D;] [rwx] dirname&#x2F;filename</span><br><span class="line">- u：拥有者</span><br><span class="line">- g：所属群组</span><br><span class="line">- o：其他人</span><br><span class="line">- a：所有人</span><br><span class="line">- +：添加权限</span><br><span class="line">- -：移除权限</span><br><span class="line">- &#x3D;：设定权限</span><br><span class="line">示例：为 .bashrc 文件的所有用户添加写权限。</span><br><span class="line"># chmod a+w .bashrc</span><br></pre></td></tr></table></figure></div><h2 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h2><ul><li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw-。</li><li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li></ul><p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。</p><h2 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h2><p>文件名不是存储在一个文件的内容，而是存储在一个文件所在的目录。因此，拥有文件的 w 权限并<strong>不能对文件名进行修改</strong>。</p><p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-常见操作&quot;&gt;&lt;a href=&quot;#1-常见操作&quot; class=&quot;headerlink&quot; title=&quot;1.常见操作&quot;&gt;&lt;/a&gt;1.常见操作&lt;/h1&gt;&lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://jwkang99.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jwkang99.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="https://jwkang99.github.io/posts/319bf02d.html"/>
    <id>https://jwkang99.github.io/posts/319bf02d.html</id>
    <published>2019-06-07T07:02:48.000Z</published>
    <updated>2020-07-10T09:42:09.575Z</updated>
    
    <content type="html"><![CDATA[<h5 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h5><p>Session和Cookie都是为了解决HTTP无状态问题的。</p><p>Cookie：</p><ol><li>cookie运行在客户端，类型是文本文件</li><li>用于服务器辨别用户身份，并进行Session会话跟踪</li><li>由客户端暂存或者永久保存</li></ol><p>Session:</p><ol><li>session运行在服务端，是以类似散列表结构存储用户属性和特定信息。</li><li>当用户在应用程序的Web页之间跳转时，存储在Session对象的信息不会丢失，而是在整个用户会话中一直存在下去。</li><li>当用户发起请求时，如果用户还没有会话，服务器会自动创建一个Session对象和sessionID，sessionID唯一标识Session对象（只访问HTML、IMAGE等静态资源并不会创建Session）。</li><li>服务器通过返回响应将sessionID发送回浏览器。</li><li>浏览器第二次向该服务器发送请求时会携带该sessionID。</li><li>服务器通过这个sessionID找到对应的session获取用户数据。</li><li>Session生成后，值要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。</li></ol><p>session和cookies的区别：</p><ol><li>存储位置不同，Cookie在客户端，Session在服务器端。</li><li>存储数据大小不同，Cookie最大能存储4K数据，并且浏览器在存cookie的个数也有限制。而Session是没有大小限制，其能存储的最大数据量与服务器的内存大小有关。</li><li>安全性由所差异，由于Cookie存在本地，故安全性相对于Session差一点。容易被盗导致Cookie诈骗。</li><li>性能问题，由于Session存在服务器，session过多时会对服务器的性能造成一定的影响。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;学习记录&quot;&gt;&lt;a href=&quot;#学习记录&quot; class=&quot;headerlink&quot; title=&quot;学习记录&quot;&gt;&lt;/a&gt;学习记录&lt;/h5&gt;&lt;p&gt;Session和Cookie都是为了解决HTTP无状态问题的。&lt;/p&gt;
&lt;p&gt;Cookie：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;co
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="http" scheme="https://jwkang99.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/http/"/>
    
    
      <category term="cookie" scheme="https://jwkang99.github.io/tags/cookie/"/>
    
      <category term="session" scheme="https://jwkang99.github.io/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础</title>
    <link href="https://jwkang99.github.io/posts/b4fe5633.html"/>
    <id>https://jwkang99.github.io/posts/b4fe5633.html</id>
    <published>2019-05-23T03:06:18.000Z</published>
    <updated>2020-04-09T10:12:20.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务是指满足ACID特性的一组操作，可通过Commit提交一个事务，也可以通过Rollback进行回滚。</p><p><a href="/posts/b4fe5633/acid.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/b4fe5633/acid.png" class="lazyload"></a></p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1.原子性（Atomicity）"></a>1.原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2.一致性（Consistency）"></a>2.一致性（Consistency）</h3><p>数据库在事务执行前后都报纸一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3.隔离性（Isolation）"></a>3.隔离性（Isolation）</h3><p>一个事务所作的修改在最终提交前，对其他事务不可见。</p><h3 id="4持久性（Durability）"><a href="#4持久性（Durability）" class="headerlink" title="4持久性（Durability）"></a>4持久性（Durability）</h3><p>一旦事务提交，则其所作的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的时数据也的物理修改。</p><hr><p>事务的ACID特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><p><a href="/posts/b4fe5633/acid2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/b4fe5633/acid2.png" class="lazyload"></a></p><h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL么人采用自动提交模式。也就是说，如果不显式使用<code>START TRANSCATION</code>语句来开始一个事务，那么每个查询操作都会被当作一个事务并自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T1和T2两个事务都对一个数据及性能修改，T1先修改，T2后修改，T2的修改覆盖了T1的修改。</p><p><a href="/posts/b4fe5633/lostModify.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/b4fe5633/lostModify.png" class="lazyload"></a></p><h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T1修改了一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据就是脏数据。</p><p><a href="/posts/b4fe5633/dirtyData.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/b4fe5633/dirtyData.png" class="lazyload"></a></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T2读取一个数据，T1对该数据进行了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><a href="/posts/b4fe5633/repeatRead.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/b4fe5633/repeatRead.png" class="lazyload"></a></p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>T1读取某个范围的数据。T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同，与不可重复度的区别是幻读重点在新增和删除，不可重复度重点在修改。</p><p><a href="/posts/b4fe5633/read.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:67%;" data-src="/posts/b4fe5633/read.png" class="lazyload"></a></p><hr><p>产生并发不一致问题的主要原因是破坏了事务的隔离性，解决方法通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别让用户以一种更轻松的方式处理并发一致性问题。</p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL中提供了两种封锁粒度：行级锁和表级锁。</p><p>应该尽量之锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发成都就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发成都之间做一个权衡。</p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1.读写锁"></a>1.读写锁</h3><ul><li>互斥锁（Exclusive），简写x锁，或写锁。</li><li>共享锁（Shared），简写S锁，或读锁。</li></ul><p>读写锁属于行级锁，有以下两个规定：</p><ul><li>一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁。</li><li>一个事务对数据对象A加了S锁，可以对A进行读取操作，但是不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。</li></ul><p>锁的兼容关系如下：</p><p><a href="/posts/b4fe5633/xslock.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/b4fe5633/xslock.png" class="lazyload"></a></p><h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2.意向锁"></a>2.意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁，属于表级锁。</p><p>在存在行级锁和表级锁地情况下，事务T想要对表A加X锁，就需要先检测是否有其他事务对表A或者表A中地任意一行加了锁，那么就需要对表A地每一行度检测一次，这是非常耗时的。</p><p>意向锁在原来的X/S锁之上引入了IX、IS，IX和IS都是<strong>表锁</strong>，用来表示一个事务想要在表中的某个数据行加上X锁或S锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁。</li><li>一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。</li></ul><p>通过引入意向锁，事务T想要对表A加X锁，只需先检测是否有其他事务对表A加了X、IX、S、IS锁，如果加了就表示有其他事务正在使用这个表或者某一行的锁，因此事务T加X锁失败。</p><p>各种所得兼容如下：</p><table><thead><tr><th></th><th><strong>X</strong></th><th><strong>IX</strong></th><th><strong>S</strong></th><th><strong>IS</strong></th></tr></thead><tbody><tr><td><strong>X</strong></td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td><strong>IX</strong></td><td>–</td><td></td><td>–</td><td></td></tr><tr><td><strong>S</strong></td><td>–</td><td>–</td><td></td><td></td></tr><tr><td><strong>IX</strong></td><td>–</td><td></td><td>–</td><td></td></tr></tbody></table><p>解释：</p><ul><li>任意IS/IX锁之间都是兼容的，因为他们表示<strong>想要</strong>对表加锁，而不是真正的加锁。</li><li>这里的兼容关系针对的是表级锁，而表级的IX锁和行级的X锁兼容，两个事务可以对两个数据加X锁。（事务T1想要对数据行R1加X锁，事务T2想要对同一个表的数据行R2加X锁，两个事务都需要对该表加IX锁，但是IX是兼容的，并且IX锁与行级的X锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1.三级封锁协议"></a>1.三级封锁协议</h3><h4 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h4><p>事务T要修改数据A时必须加X锁，直到事务T结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><a href="/posts/b4fe5633/firstlevel.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/b4fe5633/firstlevel.png" class="lazyload"></a></p><h4 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h4><p>在一级的基础上，要求读取数据A时必须加S锁，<strong>读取完马上释放S锁</strong>。</p><p>可以解决脏数据问题，因为如果一个事务在对数据A进行修改，根据一级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入数据。</p><p><a href="/posts/b4fe5633/secondlevel.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/b4fe5633/secondlevel.png" class="lazyload"></a></p><h4 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><a href="/posts/b4fe5633/thirdlevel.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/b4fe5633/thirdlevel.png" class="lazyload"></a></p><h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务<strong>遵循两段锁协议</strong>是保证可串行化调度的<strong>充分条件</strong>。例如以下操作满足两段锁协议，它是可串行化调度。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加锁阶段</span><br><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...</span><br><span class="line">&#x2F;&#x2F;解锁阶段</span><br><span class="line">unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure></div><p>但<strong>不是必要条件</strong>，例如以下操作<strong>不满足两段锁协议</strong>，但他还是可串行化调度。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure></div><h2 id="MySQL隐式与显式锁定"><a href="#MySQL隐式与显式锁定" class="headerlink" title="MySQL隐式与显式锁定"></a>MySQL隐式与显式锁定</h2><p>MySQL的<strong>InnoDB存储引擎</strong>采用<strong>两段锁协议</strong>，会根据隔离级别再需要的时候自动加锁，并且所有的锁都是再同一时刻释放，这被称为隐式锁定。</p><p>InnoDB也可以使用特定的语句进行显示锁定：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></div><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其他事务也是可见的，但不允许两个事务同时修同一数据。<strong>可以处理丢失修改</strong>。需要排他锁。</p><h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>​        一个事务只能读取已经提交的事务所做的修改。换句话说，该级别下，一个事务不能读取其他食物已改动但未提交的数据，一个事务所做的修改在提交之前对其他事务是不可见的。<strong>可以处理丢失修改和脏读</strong>。</p><p>​        但仍可能出现不可重复读和幻读，例如事务A读取某一行数据，事务B删除或改动这一行数据，事务A再去读，就会出现不可重复度或者幻读的问题。</p><h2 id="可重复度（REPEATABLE-READ）"><a href="#可重复度（REPEATABLE-READ）" class="headerlink" title="可重复度（REPEATABLE READ）"></a>可重复度（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同一数据的结果是一样的。<strong>可以处理丢失修改、脏读、不可重复度和幻读</strong>。</p><p><strong>注</strong>：可重复读仅仅是说不可以删除或者改动当前数据行，可并没有强制不能插入新的满足条件新的满足条件的数据行。也就是说，在该级别下，第二次读取的内容肯定包含第一次读取的内容，可能第二次更多。这就<strong>出现了幻读</strong>。</p><h2 id="可串行化（SERIALIZABE）"><a href="#可串行化（SERIALIZABE）" class="headerlink" title="可串行化（SERIALIZABE）"></a>可串行化（SERIALIZABE）</h2><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。<strong>可以处理丢失修改、脏读、不可重复度和幻读</strong>。</p><p>反复读是为了保证在一个事务中，相同条件下读取的数据都不会变，可不保证下次相同的条件，结果记录数不会增加。序列化就是为了剞劂幻读问题存在的，他将这个查询范围都加锁了。所有不能再往这个范围插入数据了。</p><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多并发控制（Multi-Version Concurrency Control，MVCC）是MySQL的InnoDB存储引擎实现颗粒级别的一种具体方式，用于实现提交读和可重复读这两种可理解别。而未提交读可理级别总是读取最新的数据行，要求很低，无需使用多版本并发控制。可串行化隔离级别需要对所有读取的行都加锁，单纯使用多版本并发控制无法实现。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>加锁能解决多个事务同时执行时出翔的并发一致性问题。在实际场景中读操作往往多于写操作，因此有引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。</p><p>读写锁中读与写操作仍是互斥的，而MVCC利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这点和<code>CopyOnWrite</code>类似。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>系统版本号SYS_ID：是一个递增的数字，没开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号TRX_ID：事务开始时的系统版本号。</li></ul><h2 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h2><p>MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。</p><p>例如在MySQL创建一个表t，包含逐渐id和一个字段x。先插入一个数据行，然后对该数据行执行量词更新操作。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(<span class="keyword">id</span>, x) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x=<span class="string">"b"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x=<span class="string">"c"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><p>由于没有使用<code>START TRANSACTION</code>将上边三个操作当作一个事务来执行，故MySQL的AUTOCOMMIT机制会把每个操作当作一个事务来执行，一共三个事务。快照中出了记录事务版本号和操作之后，还记录了<strong>一个bit的DEL字段</strong>，用于标记是否被删除。</p><p><a href="/posts/b4fe5633/undo.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/b4fe5633/undo.png" class="lazyload"></a></p><p>INSERT、UPDATE、DELETE操作都会创建一个日志，并将事务版本号TRX_ID写入。DELETE可以看成是一个特殊的UPDATE，还会额外将DEL字段设置为1。</p><h2 id="ReadView（-）"><a href="#ReadView（-）" class="headerlink" title="ReadView（?）"></a>ReadView（?）</h2><p>MVCC维护了一个ReadView结构，主要包含了当前系统未提交事务列表TRX_IDs{TRX_ID_1,TRX_ID_2…}，还有该列表的最小值TRX_ID_MIN和TRX_ID_MAX。</p><p>在进行SELECT操作时，根据数据行快照的TRX_ID与TRX_ID_MIN和TRX_ID_MAX之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID&lt;TRX_ID_MIN，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID&gt;TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别在进行判断：<ul><li>提交读：如果TRX_ID在TRX_IDs列表中，表示该数据行快照对应的事务还未提交，则该快照不可用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p><h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1.快照读"></a>1.快照读</h3><p>多版本并发控制的SELECT操作是快照中的数据，不需要进行加锁操作。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure></div><h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2.当前读"></a>2.当前读</h3><p>多版本其他会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到多版本控制并不是完全不用加锁，而只是避免了SELECT的加锁操作。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure></div><p>在进行SELECT操作时，可以强制指定进行加锁操作。以下第一个语句需要加S锁，第二个需要加X锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> condition <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> condition <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure></div><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks时MySQL的InnoDB存储引擎的一种锁实现。</p><p>多版本并发控制不能解决幻读问题，Next-Key Locks就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题。</p><h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，俄日不是记录本身。</p><p>如果表没有设置索引，InnoDB会自动在主键上创建隐藏的聚簇索引，因此Record Locks依然可用。</p><h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其他事务就不能在t.c中插入15。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></div><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是Record Locks和Gap Locks的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭的区间，例如一个索引包含以下值：10，11，13 and 20，那么就需要锁定以下区间：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure></div><h1 id="MySql存储引擎"><a href="#MySql存储引擎" class="headerlink" title="MySql存储引擎"></a>MySql存储引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>并发性和锁级别</li></ul><p>MyISAM使用的表级锁，而不是行级锁，对表进行修改时需要对整个表进行加锁。而对表的内容进行读取时，也需要对所有的数据加共享锁。</p><ul><li><p>表损坏修复</p></li><li><p>支持的索引类型</p></li><li><p>支持数据压缩（myisampack）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://jwkang99.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://jwkang99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Map源码分析</title>
    <link href="https://jwkang99.github.io/posts/f6d3fa04.html"/>
    <id>https://jwkang99.github.io/posts/f6d3fa04.html</id>
    <published>2019-03-24T06:55:10.000Z</published>
    <updated>2020-04-03T04:02:58.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map源码分析"><a href="#Map源码分析" class="headerlink" title="Map源码分析"></a>Map源码分析</h2><p>JDK1.8</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>hashmap实现三个接口和一个抽象类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></div><h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1.存储结构"></a>1.存储结构</h4><p>hashmap内部维护一个类型为<code>Node</code>的键值对数组<code>table</code>。</p><p>table的容量一般为2的幂，因为是2的幂的时候用hashcode与数组长度-1做<code>&amp;</code>运算与取模的结果一致，且比模快。还有一个很<strong>重要的原因</strong>：如果不为2的幂，例15，n-1=14(1110)，用hashcode做与运算的时候最后一位永远是0，故数组中二进制最后一位为0的下标位置永远为null。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认大小为16</span></span><br></pre></td></tr></table></figure></div><p>下边为<code>Node</code>结点的数据结构，为hashmap的静态内部类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key + <span class="string">"="</span> + value;&#125;</span><br><span class="line"><span class="comment">//返回当前结点的hashcodo,^表示异或</span></span><br><span class="line">    <span class="comment">//为什么要这么算结点hashcode，把高16和低16为的特征融合</span></span><br><span class="line">    <span class="comment">//最终目的都是为了减少重入</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) </span><br><span class="line">            ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重写了equals方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-hashmap的属性"><a href="#2-hashmap的属性" class="headerlink" title="2.hashmap的属性"></a>2.hashmap的属性</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//最大容量为2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//装载因子，即size和容量的比值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//改用红黑树的阈值，当一个桶的节点数大于8就会转为红黑树存储</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//结点数小于6时，改用单向链表存储</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//用红黑树时的最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//map的大小，存储键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//下一次HashMap扩容的大小</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//存储负载因子的常量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//HashMap被改变的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure></div><p><strong>capacity 永远都是 2 次幂，那么如果我们指定 initialCapacity 不为 2次幂时呢，是不是就破坏了这个规则？</strong></p><p>答：不是的，HashMap的tableSizeFor方法做了处理，能保证n永远都是2次幂。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有属性都是默认的</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定容量大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定容量大小和转载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Illegal initial capacity: "</span>+initialCapacity);</span><br><span class="line">    <span class="comment">//若容量超过最大容量，则以最大容量初始化</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//装载因子不可小于0或者为Null</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Illegal load factor: "</span>+loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//设置HashMap当前阈值，超过阈值时需要扩容</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把一个map中的所有实体都放到当前hashmap中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>下边来看第三种构造方法（指定容量和装载因子）中的<code>tableSizeFor</code>方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : </span><br><span class="line">    (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="4-添加元素"><a href="#4-添加元素" class="headerlink" title="4.添加元素"></a>4.添加元素</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//计算hash的方法比较特殊，能将高区16位与低区16位的特征结合起来</span></span><br><span class="line">    <span class="comment">//此时高区16不变，低区的16位发生了变化，具体原因讲</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//put的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断table不为空且table长度部位0，否则从resize中获取</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//计算出新插入元素的hash值在数组中对应的位置是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果为空则新建一个node放在这个位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果存在冲突</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key </span><br><span class="line">             || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果数组中的元素是TreeNode</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"> <span class="function">J   <span class="title">afterNodeInsertion</span><span class="params">(evict)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="9-与hashtable的比较"><a href="#9-与hashtable的比较" class="headerlink" title="9.与hashtable的比较"></a>9.与hashtable的比较</h4><ul><li>HashTable使用synchronized来进行同步</li><li>HashMap可以插入键为null的键值对</li><li>HashMap的迭代器是fail-fast迭代器</li><li>HashMap不能保证随着时间的推移Map中的元素次序是不变的</li></ul><h3 id="ConncurrentHashMap"><a href="#ConncurrentHashMap" class="headerlink" title="ConncurrentHashMap"></a>ConncurrentHashMap</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>ConcurrentHashMap的继承实现关系如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></div><p>ConcurrentHashMap 和 HashMap 实现上类似。在JDK1.7中，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    Segment(<span class="keyword">float</span> lf) &#123; <span class="keyword">this</span>.loadFactor = lf; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在JDK1.8中，抛弃了原有的Segment分段锁，而采用了CAS+synchronized来保证并发安全性。</p><h4 id="2-put方法逻辑"><a href="#2-put方法逻辑" class="headerlink" title="2.put方法逻辑"></a>2.put方法逻辑</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无条件循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.如果正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前为红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//7.插入完之后看是否需要转换为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上述代码可以看出，对当前table进行无条件自循环直到put成功可以分为以下几步：</p><p>1、判断Node[]数组是否初始化，没有则<strong>进行初始化操作</strong><br>2、通过<strong>hash定位数组的索引坐标</strong>，是否有Node节点，如果没有则使用CAS进行添加（链表的头节点），添加失败则进入下次循环。<br>3、检查到内部正在扩容，就帮助它一块扩容。<br>4、如果f！=null，则<strong>使用synchronized锁住</strong>f元素（链表/红黑树的头元素）。如果是Node（链表结构）则执行链表的添加操作；如果是TreeNode（树型结构）则执行树添加操作。<br>5、判断链表长度已经达到临界值8（默认值），当节点超过这个值就需要<strong>把链表转换为树结构</strong>。<br>6、如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容</p><h4 id="3-spread-key-hashCode"><a href="#3-spread-key-hashCode" class="headerlink" title="3.spread(key,hashCode())"></a>3.spread(key,hashCode())</h4><p>在put的第一步要计算hash。这方法作用<strong>重哈希</strong>，以减小Hash冲突</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>该方法主要是<strong>将key的hashCode的低16位于高16位进行异或运算</strong>，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾。</p><h4 id="4-initTable方法"><a href="#4-initTable方法" class="headerlink" title="4.initTable方法"></a>4.initTable方法</h4><p>主要作用将tab进行初始化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></span><br><span class="line">            <span class="comment">//让步由运行变为就绪</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>为了保证只有一个线程初始化：</p><p>1.第1步中会先通过if进行判断，<strong>若当前已经有一个线程正在初始化即sizeCtl值变为-1</strong>，这个时候其他线程在If判断为true从而调用Thread.yield()让出CPU时间片。</p><p>2.正在进行初始化的线程会调用compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。</p><p>3.只有一个线程会进来进行初始化数组。</p><p>4.第四步中会进一步计算数组中可用的大小即为数组实际大小n乘以加载因子0.75.可以看看这里乘以0.75是怎么算的，0.75为四分之三，<strong>这里n - (n &gt;&gt;&gt; 2)是不是刚好是n-(1/4)n=(3/4)n</strong>。如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为DEFAULT_CAPACITY（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。</p><h4 id="5-CAS关键操作"><a href="#5-CAS关键操作" class="headerlink" title="5.CAS关键操作"></a>5.CAS关键操作</h4><p>tabAt()该方法用来<strong>获取table数组中索引为i的Node元素</strong>。<br>casTabAt()利用<strong>CAS操作设置table数组中索引为i的元素</strong><br>setTabAt()该方法用来设置table数组中索引为i的元素</p><h4 id="6-扩容"><a href="#6-扩容" class="headerlink" title="6.扩容"></a>6.扩容</h4><p>通过判断该节点的hash值是不是等于-1（MOVED）,<strong>代码为(fh = f.hash) == MOVED，说明 Map 正在扩容</strong>。那么就帮助 Map 进行扩容。以加快速度。</p><p>在扩容时需要重新计算所有结点在Node数组中的位置，即索引位置。JDK1.7使用的是把当前桶下的元素一个一个遍历重新根据hash值与扩展后的newCap进行与操作算出新的索引位置，并分别按照链表和红黑树的插入方式进行插入。JDK1.8中使用了比较巧的方法，由于每次扩容都扩展为原来的两倍，故每个元素要么停留在原地，要么往后移动oldCap个位置。</p><p>JDK1.7中的方法会使扩容后同一个同下的结点顺序倒置，而1.8中的并不会。</p><p>在JDK1.8中还会使用红黑树，红黑树的冲哈希比较麻烦。首先需要用split对当前红黑树进行剪枝。减为两部分，一部分留在当前桶内，一部分往后移动oldCap位。</p><h4 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7.get方法"></a>7.get方法</h4><p>concurrentHashMap的/get操作的流程很简单，可以分为三个步骤来描述:</p><p>1.计算hash值，定位到该table索引位置，如果是首节点符合就返回。<br> 2.如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回。<br> 3.以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>继承自HashMap，因此具有与HashMap一样的快速查找特性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">//accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</span></span><br><span class="line"><span class="comment">//为true时保持的时LRU顺序，也就时把最近访问过的结点放在尾部</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></div><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用，都是hashmap中操作的后置操作:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></div><h4 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h4><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，即get()之后，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h4><p>用于删除第一个结点，即若位LRU时，删除最少被访问的结点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><p>下边写一个继承自LinkedHashMap的缓存类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//缓存空间位3</span></span><br><span class="line">    SimpleCache&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> SimpleCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cache.save(i, i * i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"插入10个键值对后，缓存内容："</span>);</span><br><span class="line">    System.out.println(cache + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"访问键值为7的节点后，缓存内容："</span>);</span><br><span class="line">    cache.getOne(<span class="number">7</span>);</span><br><span class="line">    System.out.println(cache + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"插入键值为1的键值对后，缓存内容："</span>);</span><br><span class="line">    cache.save(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(cache);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>继承实现关系，<code>NavigableMap</code>继承了<code>SortedMap</code>接口，可以实现存储元素的自动排序，键值对之间按键有序，实现的基础是平衡二叉树。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></div><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//自定义比较器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span></span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Map源码分析&quot;&gt;&lt;a href=&quot;#Map源码分析&quot; class=&quot;headerlink&quot; title=&quot;Map源码分析&quot;&gt;&lt;/a&gt;Map源码分析&lt;/h2&gt;&lt;p&gt;JDK1.8&lt;/p&gt;
&lt;h3 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
      <category term="基础知识" scheme="https://jwkang99.github.io/categories/java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="容器" scheme="https://jwkang99.github.io/categories/java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="容器" scheme="https://jwkang99.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
