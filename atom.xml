<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>解忧杂货铺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jwkang99.github.io/"/>
  <updated>2021-08-31T13:15:21.088Z</updated>
  <id>https://jwkang99.github.io/</id>
  
  <author>
    <name>康宁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchronied和lock的异同</title>
    <link href="https://jwkang99.github.io/posts/533501b0.html"/>
    <id>https://jwkang99.github.io/posts/533501b0.html</id>
    <published>2021-08-31T03:20:15.000Z</published>
    <updated>2021-08-31T13:15:21.088Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-存在层面"><a href="#1-存在层面" class="headerlink" title="1 存在层面"></a>1 存在层面</h4><p>synchronied是Java的关键字，在JVM层面的</p><p>Lock是Java的一个类，底层有一个volatile的state，通过cas活设置变量，设置成功则获取锁成功</p><h4 id="2-锁的获取"><a href="#2-锁的获取" class="headerlink" title="2 锁的获取"></a>2 锁的获取</h4><p>synchronied</p><ul><li>调用同步方法，如果A线程获得锁，B线程会一直等待。</li></ul><p>Lock</p><ul><li>有多种获取锁的方式<ul><li><code>void lock()</code>   获取锁，如果锁被暂用则一直等待</li><li><code>boolean tryLock()</code>   尝试获取锁，如果获取锁的时候，锁被占用就返回false，否则返回true</li><li><code>boolean tryLock(long time, TimeUnit unit)</code>    给tryLock加一个时间限制，如果时间内等到了锁就返回true</li><li><code>void lockInterruptibly()</code>    获取锁，如果锁被占用，一直等待，等待过程可以被打断</li></ul></li></ul><h4 id="3-锁的释放"><a href="#3-锁的释放" class="headerlink" title="3 锁的释放"></a>3 锁的释放</h4><p>synchronied</p><ul><li>已获取锁的线程执行完同步代码，释放锁</li><li>线程执行异常，JVM会让先线程释放锁</li></ul><p>Lock</p><ul><li>在finally中必须手动释放锁，不然容易造成线程死锁</li></ul><h4 id="4-锁的状态"><a href="#4-锁的状态" class="headerlink" title="4 锁的状态"></a>4 锁的状态</h4><p>synchronied无法判断锁的状态</p><p>Lock可以判断锁的状态</p><h4 id="5-锁的类型"><a href="#5-锁的类型" class="headerlink" title="5 锁的类型"></a>5 锁的类型</h4><p>synchronied</p><ul><li>可重入 不可中断 非公平</li></ul><p>Lock</p><ul><li>可重入 可判断 可公平/可不公平</li></ul><h4 id="6-锁的条件"><a href="#6-锁的条件" class="headerlink" title="6 锁的条件"></a>6 锁的条件</h4><p>synchronied</p><ul><li>无条件，唤醒所有线程</li></ul><p>Lock</p><ul><li>可设置条件唤醒满足条件的线程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-存在层面&quot;&gt;&lt;a href=&quot;#1-存在层面&quot; class=&quot;headerlink&quot; title=&quot;1 存在层面&quot;&gt;&lt;/a&gt;1 存在层面&lt;/h4&gt;&lt;p&gt;synchronied是Java的关键字，在JVM层面的&lt;/p&gt;
&lt;p&gt;Lock是Java的一个类，底层有一
      
    
    </summary>
    
    
      <category term="重要" scheme="https://jwkang99.github.io/categories/%E9%87%8D%E8%A6%81/"/>
    
    
      <category term="重要" scheme="https://jwkang99.github.io/tags/%E9%87%8D%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>面试点</title>
    <link href="https://jwkang99.github.io/posts/8176f783.html"/>
    <id>https://jwkang99.github.io/posts/8176f783.html</id>
    <published>2021-08-28T03:20:15.000Z</published>
    <updated>2021-08-31T04:46:36.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="1-equals-amp-hashcode"><a href="#1-equals-amp-hashcode" class="headerlink" title="1. equals &amp; hashcode"></a>1. equals &amp; hashcode</h4><p>equals方法：继承自Object类，在Object中，equals的返回值为==结果</p><p>hashCode方法：继承自Object类，作用为取地址，native方法，<strong>通过将该对象的内部地址转换成一个整数来实现的</strong>。</p><p><strong>默认情况下，即在不重写equals的前提下</strong>：</p><ol><li>==为true的两个对象，hashCode一定相等，反之不成立。</li><li>equals为true的两个对象，hashCode一定相等，反之不成立。</li></ol><p><strong>如果equals方法和hashCode方法被重写</strong>，为了保证散列得正常结果，需满足：</p><ol><li>同一对象多次hashCode结果必须一致，前提是equals 比较时所用的信息没有被修改</li><li>如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</li></ol><p><strong>总结</strong>：</p><p>两个对象equals相等，则它们的hashcode必须相等，反之则不一定。</p><p>两个对象\==相等，则它们的hashcode必须相等，反之则不一定。【==相等，则equals必然相等】</p><h4 id="2-CAS操作如何保证线程安全，ABA问题又是什么？"><a href="#2-CAS操作如何保证线程安全，ABA问题又是什么？" class="headerlink" title="2. CAS操作如何保证线程安全，ABA问题又是什么？"></a>2. CAS操作如何保证线程安全，ABA问题又是什么？</h4><p>线程1比较当前变量A的值和预期X是否一致，一致的话则进行修改。</p><p><strong>ABA问题</strong>：若线程1读了变量A的值为X，此时线程2对X进行了修改，然后又改回X，线程并不会发现变量A的值被修改过，仍会重新进行。</p><p>X很有可能是一个指向某个地址的引用，由于内存重用机制，X仍然指向的时那块内存，但是当前地址的内容已经完全不一样了，可能会出现问题。</p><h4 id="3-java中异常的分类"><a href="#3-java中异常的分类" class="headerlink" title="3. java中异常的分类"></a>3. java中异常的分类</h4><p>Error Exception</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="1-HashMap中equals和hashCode的使用"><a href="#1-HashMap中equals和hashCode的使用" class="headerlink" title="1. HashMap中equals和hashCode的使用"></a>1. HashMap中equals和hashCode的使用</h5><ul><li>如果<strong>不会创建该类的散列表容器</strong>，则该类hashCode() 和 equals()毫无关系，hashCode()方法基本无用。</li><li>如果<strong>会创建</strong>，hashCode() 和 equals()有关系<ul><li>如果equals为true，hashCode一定相等，反之不一定</li><li>在HashMap中，判断key是否相等时，首先会比较hashCode，如果hashCode相等，再进行equals或者==比较，若二者中的一个为true则为相等。如果<strong>重写</strong>了equals方法，则必须要重写hashCode方法，否则put之后再get时就会达不到预期效果，返回null。</li></ul></li></ul><h5 id="2-HashMap线程不安全的表现"><a href="#2-HashMap线程不安全的表现" class="headerlink" title="2. HashMap线程不安全的表现"></a>2. HashMap线程不安全的表现</h5><p>jdk1.7中，map新插入节点使用的头插法，在resize扩容是也使用头插法，会使得扩容前后的链表顺序颠倒，故在两个线程同resize会出现循环链表的情况，会出现死循环。</p><p>jdk1.8中，不再使用头插法一个一个判断节点的位置，而是判断当前节点在扩容后留在当前位置还是换新位置，之前迁移子链表，没有死循环。</p><p>同时存在：两个put值被覆盖</p><h5 id="3-ConcurrentHashMap如何保证线程安全"><a href="#3-ConcurrentHashMap如何保证线程安全" class="headerlink" title="3. ConcurrentHashMap如何保证线程安全"></a>3. ConcurrentHashMap如何保证线程安全</h5><p>分几个方面</p><p>initTable：有个volatile的标志位表示正在初始化，如果当前线程想要initTable发现已经有线程在初始化了，就Thread.yield()让出cpu并且自旋，知道table初始化完毕，线程退出初始化</p><p>put：计算出hash值，遍历表结构，进入下面四种情况</p><ul><li>是否需要初始化表，空则初始化initTable，然后再进行put</li><li>获取table[i]的头节点，空则用<code>CAS</code>（乐观锁的一种方式）插入<code>(key,value)</code></li><li>看是否当前有线程正在扩容，有则帮忙扩容<code>helpTransfer</code></li><li><code>synchronized</code>获锁资源，判断是链表节点还是红黑树节</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;java&lt;/h2&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h
      
    
    </summary>
    
    
      <category term="重要" scheme="https://jwkang99.github.io/categories/%E9%87%8D%E8%A6%81/"/>
    
    
      <category term="重要" scheme="https://jwkang99.github.io/tags/%E9%87%8D%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://jwkang99.github.io/posts/91e798bc.html"/>
    <id>https://jwkang99.github.io/posts/91e798bc.html</id>
    <published>2021-07-20T03:20:15.000Z</published>
    <updated>2021-08-22T09:11:40.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>java内存模型（如下图，12-1为处理器、高速缓存、主内存间的交互关系图，此处没贴，基本和下图一致）。</p><p><a href="/posts/91e798bc/jvm_memory.png" data-fancybox="group" data-caption="jvm内存模型" class="fancybox"><img alt="jvm内存模型" data-src="/posts/91e798bc/jvm_memory.png" class="lazyload" title="jvm内存模型"></a></p><p>线程的工作内存中保存了被该线程使用的变量的主存中的<strong>副本</strong>，线程对所有变量的读写等操作必须在其工作内存中进行，而不能直接在主内存中读写。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><strong>值得注意的是</strong>，这些变量不包括线程中的局部变量和方法参数，因为是线程私有的，所以不共享，不存在竞争关系。</p><p>另外，上边提到的工作内存的副本，有这样一个问题：假设线程中访问一个10MB大小的对象，也会把 这10MB的内存复制一份出来吗？事实上并不会如此，这个对象的引用、<strong>对象中某个在线程访问到的字段</strong>是有可能被复制的，但不会有虚拟机把整个对象复制一次。</p><h3 id="2-内存交互"><a href="#2-内存交互" class="headerlink" title="2. 内存交互"></a>2. 内存交互</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成，这8种操作都是原子的、不可再分的（对于double和long类型的变量来说在某些平台上允许有例外）。</p><ul><li><strong>lock</strong>（锁定）：作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态。</li><li><strong>unlock</strong>（解锁）：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定。</li><li><strong>read</strong>（读取）：作用于<strong>主内存</strong>的变量，它把一个变量的值从主内存传输到线程的工作内存中，以 便随后的load动作使用。</li><li><strong>load</strong>（载入）：作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use</strong>（使用）：作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign</strong>（赋值）：作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>store</strong>（存储）：作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传送到主内存中，以便随 后的write操作使用。</li><li><strong>write</strong>（写入）：作用于<strong>主内存</strong>的变量，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。</li></ul><p>注：一个变量在同一个时刻只允许一条线程对其进行<strong>lock</strong>操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行<strong>相同次数</strong>的unlock操作，变量才会被解锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h2&gt;&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://jwkang99.github.io/posts/2b9621c6.html"/>
    <id>https://jwkang99.github.io/posts/2b9621c6.html</id>
    <published>2021-06-29T03:20:15.000Z</published>
    <updated>2021-08-15T12:38:33.326Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，线程的创建和销毁都需要<strong>映射到操作系统</strong>，因此其代价是比较<strong>高昂</strong>的。出于避免频繁创建、销毁线程以及方便线程管理的需要，线程池应运而生。</p><h2 id="1、线程池优势"><a href="#1、线程池优势" class="headerlink" title="1、线程池优势"></a>1、线程池优势</h2><ul><li><strong>降低资源消耗</strong>：线程池通常会维护一些线程（数量为 corePoolSize），这些线程被重复使用来执行不同的任务，任务完成后不会销毁。在待处理任务量很大的时候，通过对线程资源的复用，避免了线程的频繁创建与销毁，从而降低了系统资源消耗。</li><li><strong>提高响应速度</strong>：由于线程池维护了一批 alive 状态的线程，当任务到达时，<em>不需要再创建线程</em>，而是直接由这些线程去执行任务，从而减少了任务的等待时间。</li><li><strong>提高线程的可管理性</strong>：使用线程池可以对线程进行统一的分配，调优和监控。</li></ul><h2 id="2、线程池实现类"><a href="#2、线程池实现类" class="headerlink" title="2、线程池实现类"></a>2、线程池实现类</h2><p>下图为Java线程池<code>Executor</code>框架体系，线程池的真正实现类是<code>ThreadPoolExecutor</code>。<br><a href="/posts/2b9621c6/1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/2b9621c6/1.png" class="lazyload"></a></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>ThreadPoolExecutor</code>共有四个带参构造方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><strong>corePoolSize</strong>：必需，核心线程数。即池中保持存活的线程数，即使这些线程处于空闲也<strong>不会回收</strong>。但是将<code>allowCoreThreadTimeOut</code>参数设置为<code>true</code>后，核心线程处于空闲一段时间以上，也会被回收。</li><li><strong>maximumPoolSize</strong>：必需，最大线程数。当核心线程全部繁忙，并且任务队列满，线程池会临时添加线程，总数上限为<code>maximumPoolSize</code>。</li><li><strong>keepAliveTime</strong>：必需，线程空闲超时时间。非核心线程处于空闲状态的时间超过这个时间后，该线程将被回收。将<code>allowCoreThreadTimeOut</code>参数设置为<code>true</code>后，核心线程也会被回收。</li><li><strong>unit</strong>：必需，<code>keepAliveTime</code>参数的时间单位。选项为枚举类TimeUnit的各项。</li><li><strong>workQueue</strong>：必需，任务队列，采用阻塞队列实现。当核心线程全部繁忙时，后续由<code>execute</code>方法提交的<code>Runnable</code>将存放在任务队列中，等待被线程处理。</li><li><strong>threadFactory</strong>（可选）：线程工厂。指定线程池<strong>创建线程的方式</strong>。</li><li><strong>handler</strong>（可选）：拒绝策略。当线程池中线程数达到<code>maximumPoolSize</code>且<code>workQueue</code>打满时，后续提交的任务将被拒绝，<code>handler</code>可以指定用什么方式拒绝任务。</li></ul><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>使用<code>ThreadPoolExecutor</code>需要指定一个实现了<code>BlockingQueue</code>接口的任务等待队列。在<code>ThreadPoolExecutor</code>线程池的API文档中，一共推荐了三种等待队列，它们是：<code>SynchronousQueue</code>、<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>；</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>线程池有一个重要的机制：拒绝策略。当线程池<code>workQueue</code>已满且无法再创建新线程池时，就要拒绝后续任务了。拒绝策略需要实现<code>RejectedExecutionHandler</code>接口，不过<code>Executors</code>框架已经为我们实现了4种拒绝策略：</p><ol><li><strong>AbortPolicy</strong>（默认）：丢弃任务并抛出RejectedExecutionException异常。</li><li><strong>CallerRunsPolicy</strong>：直接运行这个任务的run方法，但并非是由线程池的线程处理，而是交由任务的调用线程处理。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务，不抛出任何异常。</li><li><strong>DiscardOldestPolicy</strong>：将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。</li></ol><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>线程工厂指定<strong>创建线程</strong>的方式，这个参数不是必选项，<code>Executors</code>类已经为我们非常贴心地提供了一个默认的线程工厂。</p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池有五种状态。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></div><p><code>runState</code>表示当前线程池的状态，它是一个 volatile 变量用来保证线程之间的可见性。</p><p>下面的几个<code>static final</code>变量表示<code>runState</code>可能的几个<strong>取值</strong>，有以下几个状态：</p><p><strong>RUNNING</strong>：当创建线程池后，初始时，线程池处于<code>RUNNING</code>状态；<br><strong>SHUTDOWN</strong>：如果调用了<code>shutdown()</code>方法，则线程池处于<code>SHUTDOWN</code>状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br><strong>STOP</strong>：如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br><strong>TERMINATED</strong>：当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p><h3 id="初始化-amp-容量调整-amp-关闭"><a href="#初始化-amp-容量调整-amp-关闭" class="headerlink" title="初始化&amp;容量调整&amp;关闭"></a>初始化&amp;容量调整&amp;关闭</h3><p><strong>1、线程初始化</strong></p><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要<strong>提交任务之后</strong>才会创建线程。</p><p>在实际中如果需要线程池创建之后<strong>立即创建线程</strong>，可以通过以下两个方法办到：</p><ul><li><strong>boolean prestartCoreThread()</strong>：初始化<strong>一个</strong>核心线程</li><li><strong>int prestartAllCoreThreads()</strong>：初始化<strong>所有</strong>核心线程，并返回初始化的线程数</li></ul><p><strong>2、线程池关闭</strong></p><p><code>ThreadPoolExecutor</code>提供了两个方法，用于线程池的关闭：</p><ul><li><strong>shutdown()</strong>：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li><strong>shutdownNow()</strong>：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li></ul><p><strong>3、线程池容量调整</strong></p><p><code>ThreadPoolExecutor</code>提供了动态调整线程池容量大小的方法：</p><ul><li><strong>setCorePoolSize</strong>：设置核心池大小</li><li><strong>setMaximumPoolSize</strong>：设置线程池最大能创建的线程数目大小</li></ul><p>当上述参数从小变大时，<code>ThreadPoolExecutor</code>进行线程赋值，还可能立即创建新的线程来执行任务。</p><h2 id="3、使用线程池"><a href="#3、使用线程池" class="headerlink" title="3、使用线程池"></a>3、使用线程池</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>通过构造方法，构造一个<code>ThreadPoolExecutor</code>对象是线程池最直接的使用方式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS,<span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></div><h3 id="Executors封装线程池"><a href="#Executors封装线程池" class="headerlink" title="Executors封装线程池"></a>Executors封装线程池</h3><p>另外，<code>Executors</code>封装好了4种常见的功能线程池：</p><p><a href="/posts/2b9621c6/2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/2b9621c6/2.png" class="lazyload"></a></p><h4 id="1、FixedThreadPool"><a href="#1、FixedThreadPool" class="headerlink" title="1、FixedThreadPool"></a>1、FixedThreadPool</h4><p>固定容量线程池。其特点是最大线程数就是核心线程数，意味着线程池只能创建核心线程，<code>keepAliveTime</code>为0，即线程执行完任务立即回收。任务队列未指定容量，代表使用默认值<code>Integer.MAX_VALUE</code>。适用于需要控制并发线程的场景。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2、-SingleThreadExecutor"><a href="#2、-SingleThreadExecutor" class="headerlink" title="2、 SingleThreadExecutor"></a>2、 SingleThreadExecutor</h4><p>单线程线程池。特点是线程池中只有一个线程（核心线程），线程执行完任务立即回收?，使用有界阻塞队列（容量未指定，使用默认值<code>Integer.MAX_VALUE</code>）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="3、-ScheduledThreadPool"><a href="#3、-ScheduledThreadPool" class="headerlink" title="3、 ScheduledThreadPool"></a>3、 ScheduledThreadPool</h4><p>定时线程池。指定核心线程数量，普通线程数量无限，线程执行完任务立即回收，任务队列为延时阻塞队列。这是一个比较特别的线程池，适用于<strong>执行定时或周期性的任务</strong>。</p><h4 id="4、CachedThreadPool"><a href="#4、CachedThreadPool" class="headerlink" title="4、CachedThreadPool"></a>4、CachedThreadPool</h4><p>缓存线程池。没有核心线程，普通线程数量为<code>Integer.MAX_VALUE</code>（可以理解为无限），线程闲置60s后回收，任务队列使用<code>SynchronousQueue</code>这种无容量的同步队列。适用于<strong>任务量大但耗时低</strong>的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，线程的创建和销毁都需要&lt;strong&gt;映射到操作系统&lt;/strong&gt;，因此其代价是比较&lt;strong&gt;高昂&lt;/strong&gt;的。出于避免频繁创建、销毁线程以及方便线程管理的需要，线程池应运而生。&lt;/p&gt;
&lt;h2 id=&quot;1、线程池优势&quot;&gt;&lt;a href=&quot;#1、
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>String.intern()方法</title>
    <link href="https://jwkang99.github.io/posts/5e74123b.html"/>
    <id>https://jwkang99.github.io/posts/5e74123b.html</id>
    <published>2021-06-28T03:20:15.000Z</published>
    <updated>2021-06-29T07:37:28.449Z</updated>
    
    <content type="html"><![CDATA[<p>之前了解过String.intern()，有点忘记了，在《深入理解JAVA虚拟机》中再次看到，记录一下。</p><p>JDK1.6主要有以下几条规则。</p><h4 id="1、new-String-是在堆上创建对象"><a href="#1、new-String-是在堆上创建对象" class="headerlink" title="1、new String()是在堆上创建对象"></a>1、new String()是在堆上创建对象</h4><p><a href="/posts/5e74123b/1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/5e74123b/1.png" class="lazyload"></a></p><p><a href="/posts/5e74123b/2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/5e74123b/2.png" class="lazyload"></a></p><h4 id="2、通过字面量创建字符串"><a href="#2、通过字面量创建字符串" class="headerlink" title="2、通过字面量创建字符串"></a>2、通过字面量创建字符串</h4><p>例如String str = “twm”， 首先查找常量池中是否存在相同的字符串，若存在，返回该字符串的引用；若不存在，将该字符串添加到常量池，在返回其引用。</p><p><a href="/posts/5e74123b/3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/5e74123b/3.png" class="lazyload"></a></p><h4 id="3、字符串常量拼接"><a href="#3、字符串常量拼接" class="headerlink" title="3、字符串常量拼接"></a>3、字符串常量拼接</h4><p>字符串常量+操作，在编译阶段就会直接被合为同一个字符串。例如，String str = “JA”+”VA”，编译阶段会合并成String str = “JAVA”。从而和第2种创建方式一致。</p><h4 id="4、final字段"><a href="#4、final字段" class="headerlink" title="4、final字段"></a>4、final字段</h4><p>对于final字段，编译期直接进行了常量替换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String str1 = <span class="string">"JA"</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">"VA"</span>;</span><br><span class="line">String str3 = str1 + str2;</span><br></pre></td></tr></table></figure></div><p>在编译时，直接替换成了String str3=”JA”+”VA”，根据第三条规则，再次替换成String str3=”JAVA”。</p><h4 id="5、常量和变量拼接"><a href="#5、常量和变量拼接" class="headerlink" title="5、常量和变量拼接"></a>5、常量和变量拼接</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String baseStr = <span class="keyword">new</span> String(<span class="string">"JAVA"</span>);</span><br><span class="line">String str3 = baseStr + <span class="string">"01"</span>;</span><br></pre></td></tr></table></figure></div><p>会调用stringBuilder.append()在堆上创建新的对象。</p><h4 id="6、JDK7的不同之处"><a href="#6、JDK7的不同之处" class="headerlink" title="6、JDK7的不同之处"></a>6、JDK7的不同之处</h4><p>JDK7的String.intern()方法还是会先在常量池中寻找是否已经存在，若存在    则返回常量池中的引用。不同的是，若常量池中不存在，则再将字符串复制常量池中，而是将其在堆中的地址复制到常量池中。</p><p><a href="/posts/5e74123b/4.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/5e74123b/4.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">str2.intern();</span><br><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">System.out.println(str2==str1);</span><br></pre></td></tr></table></figure></div><p>上述代码在JDK1.7上运行时打印出<strong>true</strong>，str1和str2指向同一个在堆中的String对象。<br>JDK1.6上运行时也打印出<strong>true</strong>，str1和str2指向常量池中的同一个字符串。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">str2.intern();</span><br><span class="line">System.out.println(str2==str1);</span><br></pre></td></tr></table></figure></div><p>上述代码在JDK1.7上运行时打印出<strong>false</strong>，str1指向常量池中的字符串，str2指向堆中的String对象。<br>JDK1.6上运行时打印出<strong>false</strong>，str1指向常量池中的字符串，str2指向堆中的String对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前了解过String.intern()，有点忘记了，在《深入理解JAVA虚拟机》中再次看到，记录一下。&lt;/p&gt;
&lt;p&gt;JDK1.6主要有以下几条规则。&lt;/p&gt;
&lt;h4 id=&quot;1、new-String-是在堆上创建对象&quot;&gt;&lt;a href=&quot;#1、new-String-是在
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>字节笔试0613</title>
    <link href="https://jwkang99.github.io/posts/c3e2d5b.html"/>
    <id>https://jwkang99.github.io/posts/c3e2d5b.html</id>
    <published>2021-06-13T11:02:48.000Z</published>
    <updated>2021-08-15T12:55:17.199Z</updated>
    
    <content type="html"><![CDATA[<h5 id="3道编程题"><a href="#3道编程题" class="headerlink" title="3道编程题"></a>3道编程题</h5><ol><li>二叉树最大权值和</li></ol><p>给定一颗具有n节点的完全二叉树， 需要从这棵树中选择一部分节点，求其 最大权值和。</p><p>规则：如果选择了一个节点的任意子节点，则不可以选择这个节点。求这部分节点的数字和最大值。</p><ol><li>感染人群</li></ol><p>求给定N个人被感染和人与人之间的接触关系下，可以覆盖所有被感染人群，且人数最少的最优 路径。</p><ol><li>座位安排</li></ol><p>给定人数情况下，求座位数；</p><p>规则：不能有两个人挨着坐，每个人都按照观察最长连续空座位，然后选中间那个位子坐（如果有多个满足需求则取左边个）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;3道编程题&quot;&gt;&lt;a href=&quot;#3道编程题&quot; class=&quot;headerlink&quot; title=&quot;3道编程题&quot;&gt;&lt;/a&gt;3道编程题&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;二叉树最大权值和&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定一颗具有n节点的完全二叉树， 需要从这棵树中选择一部分
      
    
    </summary>
    
    
      <category term="找工作" scheme="https://jwkang99.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="笔试" scheme="https://jwkang99.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="字节跳动" scheme="https://jwkang99.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>java内存泄露</title>
    <link href="https://jwkang99.github.io/posts/622d09b0.html"/>
    <id>https://jwkang99.github.io/posts/622d09b0.html</id>
    <published>2021-06-13T11:02:48.000Z</published>
    <updated>2021-08-15T12:53:08.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h3><p>在 <a href="./e70d4d38.html">OOM异常</a>中，介绍了JVM中出现OOM异常的几种情况和区域。要解决java堆抛出的OOM异常时（Java heap space），首先应该确认内存中导致OOM的对象，也就是先要分清楚时发生了内存溢出还是内存泄漏。</p><p>在此之前要清楚内存溢出和内存泄漏的区别：</p><p><strong>内存溢出</strong>：程序在运行过程中，所申请的内存空间大于提供的内存空间，导致无法申请到足够的内存，强行分配就会发生内存溢出。</p><p><strong>内存泄漏</strong>：申请的内存空间没有被正确释放，导致后续程序里这块内存被永远占用（不可达），而且指向这块内存空间的指针不再存在时，这块内存也就永远不可达。</p><p>Java的内存垃圾回收机制是从程序的主要运行对象开始检查<strong>引用链</strong>，当遍历一遍后发现没有<strong>被引用的孤立对象</strong>就作为垃圾回收。这些<strong>无用的对象</strong>都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p><h3 id="Java内存泄漏分析与解决方案"><a href="#Java内存泄漏分析与解决方案" class="headerlink" title="Java内存泄漏分析与解决方案"></a>Java内存泄漏分析与解决方案</h3><h4 id="Java中的内存泄露是什么"><a href="#Java中的内存泄露是什么" class="headerlink" title="Java中的内存泄露是什么"></a>Java中的内存泄露是什么</h4><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点</p><ol><li>首先，这些对象是有被引用的，即在有向树形图中，存在树枝通路可以与其相连</li><li>其次，这些对象是无用的，即程序以后不会再使用这些对象。</li></ol><p>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><p>看下边这段代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)&#123;　</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();　</span><br><span class="line">    v.add(o);　o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>循环申请Object对象，并将所申请的对象放入一个Vector中，如果仅仅释放对象本身，但因为Vector仍然引用该对象，所以这个对象对GC来说是不可回收的。因此，如果对象加入到Vector后，还必须从Vector中删除，最简单的方法就是将Vector对象设置为null。</p><p>实际上这些对象已经是无用的，但还被引用，GC就无能为力了(事实上GC认为它还有用)，这一点是<strong>导致内存泄漏最重要的原因</strong>。</p><p>在<strong>实际工程</strong>中发生内存泄漏的案例：</p><p>假设有一个日志类Logger，其提供一个静态的log(String msg)，任何其它类都可以调用Logger.Log(message)来将message的内容记录到系统的日志文件中。Logger类有一个类型为HashMap的静态变量map，每次在执行log(message)的时候，都首先将message的值写入map中(以当前线程+当前时间为键)，在退出之前再从map中将以当前线程和当前时间为键的条目删除（实际这个操作试是导致内存泄漏的错误操作）。这就会导致map中引用的所有对象都已经无用，且没有没正确释放内存。</p><h4 id="几种典型的内存泄漏"><a href="#几种典型的内存泄漏" class="headerlink" title="几种典型的内存泄漏"></a>几种典型的内存泄漏</h4><p>我们知道了在Java中确实会存在内存泄漏，那么就让我们看一看几种典型的泄漏，并找出他们发生的原因和解决方法。</p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>缓存一种用来快速查找已经执行过的操作结果的数据结构。因此，如果一个操作执行需要比较多的资源并会多次被使用，通常做法是把常用的输入数据的操作结果进行缓存，以便在下次调用该操作时使用缓存的数据。缓存通常都是以动态方式实现的，如果<strong>缓存设置不正确而大量使用缓存</strong>的话则会出现内存溢出的后果，因此需要将所使用的内存容量与检索数据的速度加以平衡。</p><p>常用的解决途径是使用<strong>java.lang.ref.SoftReference</strong>类坚持将对象放入缓存。这个方法可以保证当<strong>虚拟机用完内存或者需要更多堆</strong>的时候，可以释放这些对象的引用。</p><h4 id="如何检测和处理内存泄漏"><a href="#如何检测和处理内存泄漏" class="headerlink" title="如何检测和处理内存泄漏"></a><strong>如何检测和处理内存泄漏</strong></h4><p>工具。</p><ol><li>一般说来，一个正常的系统在其运行稳定后其内存的占用量是基本稳定的，不应该是无限制的增长的。同样，对任何一个类的对象的使用个数也有一个相对稳定的上限，不应该是持续增长的。根据这样的基本假设，我们持续地观察系统运行时使用的内存的大小和各实例的个数，如果内存的大小持续地增长，则说明系统存在内存泄漏，如果特定类的实例对象个数随时间而增长(就是所谓的“增长率”)，则说明这个类的实例可能存在泄漏情况。</li><li>另一方面通常发生内存泄漏的第一个迹象是：在应用程序中出现了OutOfMemoryError。在这种情况下，需要使用一些开销较低的工具来监控和查找内存泄漏。虽然OutOfMemoryError也有可能应用程序确实正在使用这么多的内存;对于这种情况则可以增加JVM可用的堆的数量，或者对应用程序进行某种更改，使它使用较少的内存。</li></ol><p><a href="https://www.huaweicloud.com/articles/7ebfa27fe9d6b819ca7d872012afab4f.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内存泄漏和内存溢出&quot;&gt;&lt;a href=&quot;#内存泄漏和内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏和内存溢出&quot;&gt;&lt;/a&gt;内存泄漏和内存溢出&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;./e70d4d38.html&quot;&gt;OOM异常&lt;/a&gt;中，介绍了
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>面经</title>
    <link href="https://jwkang99.github.io/posts/98e6f621.html"/>
    <id>https://jwkang99.github.io/posts/98e6f621.html</id>
    <published>2021-06-13T11:02:48.000Z</published>
    <updated>2021-08-15T12:54:40.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="百度AI技术生态部面试-2020-3"><a href="#百度AI技术生态部面试-2020-3" class="headerlink" title="百度AI技术生态部面试 2020.3"></a>百度AI技术生态部面试 2020.3</h4><p>一面</p><p>首先自我介绍。</p><p>根据项目面试官问关于项目的东西。</p><p>比较基础记得不太清楚了。</p><p>二面：</p><p>忘了</p><p>三面（凉了）</p><p>说一下二叉树的高度算法？算法收敛吗？</p><p>青蛙跳台阶，如果必须经过第m阶？</p><p>判断两个矩阵重合否</p><p>生活问题</p><p>生活学习中有什么困难，怎么解决的？</p><p>总结一下自己的优势和缺点？</p><p>优势的体现是什么，缺点你是怎么努力改变的？</p><h4 id="头条广告部门-2020-3"><a href="#头条广告部门-2020-3" class="headerlink" title="头条广告部门 2020.3"></a>头条广告部门 2020.3</h4><p>一面</p><p>首先自我介绍，然后根据自己选的一个项目问问题</p><p>tcp三次握手，四次挥手</p><p>content-type字段在http协议的哪部分，响应还是请求头？</p><p>http协议有哪几种状态码，分别表示什么，其中302的重定向是怎么实现的。</p><p>http是个无状态协议，无状态什么意思，怎么解决？</p><p>能详细描述一下cookie和seesion工作机制吗，还有他俩有什么区别？</p><p>数据库索引了解吗？</p><p>B+数是什么？详细说一下？</p><p>两道算法</p><p>第一道：两个链表4-&gt;6-&gt;1和3-&gt;5-&gt;2，合并之后得7-&gt;1-&gt;4进位相加</p><p>第二道：把一个树存储到二维数组中</p><p>二面（凉了）</p><p>自我介绍</p><p>java中有哪些集合类，哪些是线程安全的哪些是线程不安全的，如果是安全的怎么实现的。</p><p>http和https有什么区别？</p><p>他们建立连接的机制具体有哪些不同？</p><p>https加密传输是靠ssl，ssl是什么？ssl是对称加密还是非对称加密？对称加密和非对称加密又是什么？</p><p>http怎么实现断点重连，比如下载一半断网了，重新连接后怎么实现继续下载？</p><p>tcp控制拥塞都有哪些协议或者机制？</p><p>服务器短怎么防止爬虫这种小程序爬虫？</p><p>用java写一个读写锁？你这个程序用了一个lock，可以用两个lock吗，能或者不能，为什么？你写这个是阻塞的，写一个非阻塞的？</p><p>人人车：</p><p>数据库了解吗？隔离级别哪四个？默认是哪个？存储引擎有哪几种？默认是哪种？</p><h4 id="头条-2020-4"><a href="#头条-2020-4" class="headerlink" title="头条 2020.4"></a>头条 2020.4</h4><p>一面：</p><p>C++里的malloc和free了解嘛，底层是怎么实现的？</p><p>java里的GC了解吗，大概说一下。</p><p>jvm大概说一下</p><p>tcp和udp区别</p><p>java中的hashmap了解嘛，具体是怎么实现的？</p><p>hashmap的大小为什么一定是2的幂？</p><p>http当中的请求方式，什么区别，什么情况下使用get/post</p><p>http头部可不可以存二进制信息？答应该不可以吧，都是键值对</p><p>数据库了解吗，怎么查看哪些字段用了索引？Explain</p><p><strong>数据库中的悲观锁乐观锁了解吗，说一下。</strong></p><p>数据库选课系统设计表</p><p>算法：矩阵搜索、第n位字符，给一个日志文件有有userid、登入登出时间，求用户峰值的时间点和峰值的持续时间。</p><p>反问：不足，代码能力和风格不错，但是对底层的了解不够深入。</p><h4 id="抖音客户端：2020-8"><a href="#抖音客户端：2020-8" class="headerlink" title="抖音客户端：2020.8"></a>抖音客户端：2020.8</h4><p>从输入网址到看到网页信息经历了什么</p><p>后台是怎么处理请求的</p><p>http报文头部有哪些字段信息</p><p>设计题：怎么实现断点续传，有其他方法吗</p><p>设计题：怎么实现图片库，云相册的客户端，用到哪些缓存。</p><p>tcp和udp区别，拥塞控制具体说一下，流量控制</p><p>问一些java里的：</p><p>类加载机制</p><p>java里的GC了解吗，大概说一下。</p><p>gcroot知道吗，哪些对象可以当作gcroot</p><p>算法题：每隔k反转链表，不够k个的不反转</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;百度AI技术生态部面试-2020-3&quot;&gt;&lt;a href=&quot;#百度AI技术生态部面试-2020-3&quot; class=&quot;headerlink&quot; title=&quot;百度AI技术生态部面试 2020.3&quot;&gt;&lt;/a&gt;百度AI技术生态部面试 2020.3&lt;/h4&gt;&lt;p&gt;一面&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="找工作" scheme="https://jwkang99.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="面试" scheme="https://jwkang99.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面经" scheme="https://jwkang99.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://jwkang99.github.io/posts/43a71ae4.html"/>
    <id>https://jwkang99.github.io/posts/43a71ae4.html</id>
    <published>2021-05-23T03:06:18.000Z</published>
    <updated>2021-08-15T12:46:42.515Z</updated>
    
    <content type="html"><![CDATA[<p>索引分类：</p><h4 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h4><p>B-Tree索引和Hash索引</p><h4 id="2-高性能索引策略"><a href="#2-高性能索引策略" class="headerlink" title="2.高性能索引策略"></a>2.高性能索引策略</h4><ol><li><p>独立的列（列不参与运算）</p></li><li><p>前缀索引、索引的选择性（基数）</p></li><li><p>多列索引（Explain分析extra字段是否有索引合并）</p></li><li>选择合适的索引列顺序（选择性强的放前边）</li><li>聚簇索引</li><li>覆盖索引：索引列覆盖了要查询的列，不必二次索引</li><li>使用索引扫描来做排序</li><li>压缩（前缀压缩）索引</li><li>冗余和重复索引</li></ol><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="MySQL中的索引了解吗，都有哪些类型？"><a href="#MySQL中的索引了解吗，都有哪些类型？" class="headerlink" title="MySQL中的索引了解吗，都有哪些类型？"></a>MySQL中的索引了解吗，都有哪些类型？</h4><p>MySQL中的索引的作用是提高数据库查询的性能。减少需要扫描的数据量，避免临时排序，顺序IO。</p><p>通常来说好的索引和不好的索引，在查询性能上能提供几个数量级。</p><p>从存储或者查询数据的结构上来说，MySQL中主要有两种类型的索引，B-Tree索引和哈希索引。当然还有其他索引，比如全文索引和空间数据索引，但是应用比较少。</p><p>首先<strong>B-Tree索引</strong>，实际上实现使用的是B+TREE，MySQL的存储引擎innoDB和MyISAM有使用，基本思想是一样的。B-Tree可以看多是一个多叉树，非叶子节点中存储的是数据所在行号或者是根据索引列的值，并且同一层的节点都是从左到右是递增的，某个节点定义了子节点的数据范围。然后叶子节点存储的可能是真正的数据也可能是主键的值，叶节点中的数据存储同样也是从左到右顺序存储，并且相邻的叶子节点之间会有一个指针，针对B-Tree他非常适合连续的范围查找，比如查找成绩在60和70之间的，如果在成绩列有索引的话，因为数据是按成绩顺序排列的，所以就能很快找出来。并且加上索引的话是不需要扫描全表的，搜索索引树即可。</p><p>其次是<strong>哈希索引</strong>，（目前<strong>只有</strong>Memory引擎显式支持hash索引Key using hash）是基于key-value的哈希表实现的，存储引擎会对所有的索引列计算一个hash值，并且针对每个hash值保存了指向对应数据行的指针。hash索引在精确匹配所有列的查询中才有效，不支持模糊查找。此外hash索引并不是按顺序存储的，所以不支持范围查找。有hash冲突的话可能维护的代价比较高。</p><p>另外B-Tree索引和哈希索引并不是不能同时存在的，比如innoDB中，如果某些数据使用的非常频繁，会在B-Tree之上再创建一个hash索引，叫做自适应hash。</p><h4 id="有了索引就一定会快吗？除了索引还有什么其他方法加快查询速度？"><a href="#有了索引就一定会快吗？除了索引还有什么其他方法加快查询速度？" class="headerlink" title="有了索引就一定会快吗？除了索引还有什么其他方法加快查询速度？"></a>有了索引就一定会快吗？除了索引还有什么其他方法加快查询速度？</h4><p>对于非常小的表，可能全表扫描会更快，中大型表适合建立索引，合适的索引会加快速度，当使用索引不当是就会使查询性能大打折扣，比如不符合索引的使用要求，最左匹配，或者索引列参与运算等都不会用到索引。</p><p>对于索引列数据长度较大时，也可以采用前缀索引，只索引开始的字符，可以节约索引空间，但是要注意选择前缀的长度是否会导致重复数据较多，索引性能下降。</p><p>也可以分析查询语句使用索引的情况，是否存在索引合并的情况，如果有的话，当前的索引可能不是最优的。</p><h4 id="覆盖索引了解吗？"><a href="#覆盖索引了解吗？" class="headerlink" title="覆盖索引了解吗？"></a>覆盖索引了解吗？</h4><p>索引包含的列覆盖了查询的列称为覆盖索引，只需扫描索引表。</p><h4 id="了解MySQL的存储引擎吗，有什么区别？"><a href="#了解MySQL的存储引擎吗，有什么区别？" class="headerlink" title="了解MySQL的存储引擎吗，有什么区别？"></a>了解MySQL的存储引擎吗，有什么区别？</h4><p>主要有两类InnoDB和MyISAM，当然也有其他的或者第三方的，比如Memory是唯一支持显式hash索引的。</p><p>在<strong>针对事务</strong>上，</p><ul><li>InnoDB支持事务默认隔离级别为可重复读，可以通过MVCC版本控制和间隙锁（Next-key lock）防止幻读。所以InnoDB的操作失败时或者遇到错误时会回滚，</li><li>MyISAM不支持事务，和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的</li></ul><p>从<strong>索引角度</strong>来说，他们使用的都是B-Tree索引。但是InnDB支持<strong>聚簇索引</strong>，而MySAM<strong>不支持聚簇索引</strong>。</p><ul><li>对于innoDB而言，聚簇索引的叶子节点存储的是每个数据行的所有数据，<strong>聚簇索引实际上就是表</strong>，非聚簇索引存的是主键值作为数据行的指针。<strong>使用二级索引时需要两次查询</strong>。<strong>好处</strong>是减少了数据行移动时或者数据也分裂时，二级索引的维护成本。由于聚簇索引叶节点数据本身是有序的，所以按照主键顺序递增添加数据时只需要往后顺序添加数据即可。</li><li>MyISAM的主键索引和二级索引的叶子节点存储的是行号，使用二级索引时一次查询。主键索引和二级索引的叶子节点存储的是行号，不管按何种顺序添加数据，主键索引和二级索引都需要更新进行维护，可能会造成数据页分裂。</li></ul><p><strong>并发和锁级别</strong>，MyISAM只支持表级锁，InnoDB支持行级锁。</p><h4 id="InnoDB中的并发控制是怎样的？"><a href="#InnoDB中的并发控制是怎样的？" class="headerlink" title="InnoDB中的并发控制是怎样的？"></a>InnoDB中的并发控制是怎样的？</h4><p>InnoDB支持事务默认隔离级别为可重复读。MVCC用于<strong>实现提交读</strong>和<strong>可重复读</strong>，</p><p>而<strong>未提交读</strong>总是读取最新的数据行，要求很低，无需使用多版本并发控制。<strong>可串行化</strong>隔离级别需要对所有读取的行都加锁，单纯使用多版本并发控制无法实现，通过<strong>间隙锁（Next-key lock）实现可串行化</strong>。</p><p><strong>InnoDB的简化版行为中</strong>MVCC解释：</p><p>MVCC在每行后保存两个隐藏的列，分别保存行的<strong>创建时间</strong>和<strong>删除时间</strong>。这里的时间是<strong>系统版本号</strong>。每开始一个新的事务，版本号加一，开始时刻的版本号作为当前事务的版本号。</p><p>在<strong>可重复读</strong>隔离级别下</p><ul><li><strong>select</strong>：①InnoDB只查找版本早于当前事务版本的数据行，确保读取的行是事务开始前就存在的行，或者是当前事务修改的。②行的删除时间要么未定义，要么大于当前版本号，确保行在事务开始前未被删除。</li><li><strong>insert</strong>：为新插入的行保存当前版本号为<strong>行版本号</strong></li><li><strong>delete</strong>：为删除的行保存当前版本号为<strong>行删除时间</strong></li><li><strong>update</strong>：<strong>插入</strong>一条新记录，新记录的创建时间为当前版本号。旧记录的<strong>删除时间</strong>为当前版本号。</li></ul><p>MVCC使得<strong>大多数</strong>读操作<strong>不用加锁</strong>。但是会<strong>占用额外的空间</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;索引分类：&lt;/p&gt;
&lt;h4 id=&quot;1-结构&quot;&gt;&lt;a href=&quot;#1-结构&quot; class=&quot;headerlink&quot; title=&quot;1.结构&quot;&gt;&lt;/a&gt;1.结构&lt;/h4&gt;&lt;p&gt;B-Tree索引和Hash索引&lt;/p&gt;
&lt;h4 id=&quot;2-高性能索引策略&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://jwkang99.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://jwkang99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="https://jwkang99.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="面经" scheme="https://jwkang99.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="https://jwkang99.github.io/posts/b38f68fb.html"/>
    <id>https://jwkang99.github.io/posts/b38f68fb.html</id>
    <published>2021-05-17T02:02:48.000Z</published>
    <updated>2021-07-08T15:16:37.359Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/posts/b38f68fb/gc.png" data-fancybox="group" data-caption="hotspot虚拟机的垃圾收集器" class="fancybox"><img alt="hotspot虚拟机的垃圾收集器" style="zoom:70%;" data-src="/posts/b38f68fb/gc.png" class="lazyload" title="hotspot虚拟机的垃圾收集器"></a></p><p>上图展示了垃圾收集器中可以可以进行的组合。</p><p>以上垃圾收集器的所有关注点包括两个：<strong>吞吐量</strong>（CPU运行用户代码的时间比例）和<strong>停顿时间</strong>。</p><p><strong>短停顿时间</strong>：适合与用户交互的程序，良好的响应速度提升用户体验。</p><p><strong>高吞吐量适合</strong>：可以高效率利用CPU时间，尽快完成运算任务，适合在后台运算而不需要太多交互的任务。</p><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h3><p>单线程收集器，<strong>特点</strong></p><ol><li>只会使用一个CPU或者一个线程去收集垃圾，</li><li><strong>串行</strong>，在它进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>（Stop The World），直到它收集结束。</li><li>但是用户对这个暂停时间不可见。</li><li>Serial和Serial Old分别用在新生代（复制算法）和老年代（标记整理算法）。</li><li>Serial收集器仍是虚拟机运行在<strong>Client模式下</strong>的默认新生代收集器。</li></ol><p><a href="/posts/b38f68fb/serial.png" data-fancybox="group" data-caption="Serial/Serial Old收集过程" class="fancybox"><img alt="Serial/Serial Old收集过程" data-src="/posts/b38f68fb/serial.png" class="lazyload" title="Serial/Serial Old收集过程"></a></p><p><strong>优点</strong>：</p><ol><li>简单高效（和其他收集器的单线程相比）。</li><li>用户桌面应用场景中，可用内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li><li>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</li></ol><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h3><p>ParNew收集器是Serial的多线程版本，<strong>特点</strong>：</p><ol><li>除了使用<strong>多条线程收集垃圾</strong>，其余的和Serial收集器完全一致，同样暂停其他所有线程（Stop The World）</li><li>因为目前只有ParNew能与CMS配合工作，故ParNew是许多运行在<strong>Server模式</strong>虚拟机的首选</li><li>ParNew在单CPU<strong>绝对不会</strong>有比Serial更好的效果，因为有线程交替执行</li><li>当然多CPU下，可以有效利用资源，效果更好</li><li>-XX:+UseConcMarkSweepGC默认新生代使用ParNew收集器，或者用+/-UseParNewGC强制指定或禁止它。</li></ol><p><a href="/posts/b38f68fb/parnew.png" data-fancybox="group" data-caption="ParNew/Serial Old收集过程" class="fancybox"><img alt="ParNew/Serial Old收集过程" data-src="/posts/b38f68fb/parnew.png" class="lazyload" title="ParNew/Serial Old收集过程"></a></p><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个<strong>新生代收集器</strong>（复制算法），并行的多线程收集器。</p><p>Parallel Scavenge收集器的关注点在于<strong>达到一个指定的吞吐量（CPU运行用户代码占比）</strong>。</p><p>提供两个参数：</p><ol><li>-XX：MaxGCPauseMillis：最大垃圾收集停顿时间，尽可能保证垃圾回收不超过该时间</li><li>-XX：GCTimeRatio：大于0小于100的整数，直接设置吞吐量大小，垃圾收集时间永远为单位1，例如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5% （即1/(1+19)）</li><li>-XX：+UseAdaptiveSizePolicy：开关参数，当这个参数被激活之后，不需要人工指定新生代的大小等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，称为自适应的调节策略。</li></ol><h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h3><p>Serial Old是Serial的老年代版本</p><ol><li>单线程，适用于在Client模式的虚拟机</li><li>在Server模式下可与Parallel Scavenge收集器搭配使用，或者作为CMS的后备方案</li></ol><h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用<strong>标记整理</strong>算法。</p><p>在注重吞吐量以及CPU资源敏感的场合中，可以优先考虑Parallel Scavenge+Parallel Old的组合。</p><p><a href="/posts/b38f68fb/parallel.png" data-fancybox="group" data-caption="parallel收集过程" class="fancybox"><img alt="parallel收集过程" data-src="/posts/b38f68fb/parallel.png" class="lazyload" title="parallel收集过程"></a></p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是老年代收集器，关注点：<strong>获取最短回收停顿时间</strong>，采用<strong>标记清除</strong>算法，<strong>特点</strong>：并发收集，低停顿。分为四个步骤</p><ol><li>初始标记：标记GC Roots能直接关联的对象，<strong>暂停用户线程</strong>，速度很快</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，且用户线程可以与垃圾收集线程一起并发运行</li><li>重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，采用用<strong>增量更新算法</strong>，<strong>停顿时间较短</strong></li><li>并发清除：回收标记对象，与用户进程并发运行</li></ol><p><a href="/posts/b38f68fb/CMS.png" data-fancybox="group" data-caption="cms收集过程" class="fancybox"><img alt="cms收集过程" data-src="/posts/b38f68fb/CMS.png" class="lazyload" title="cms收集过程"></a></p><p>缺点：</p><ol><li>对CPU资源<strong>非常敏感</strong>（并发程序共同点），虽然不会导致用户线程停顿，但是占用了CPU资源，会是应用程序变慢。</li><li>无法处理<strong>浮动垃圾</strong>，并发清除阶段用户还在运行，会产生新的垃圾（称为浮动垃圾），这些垃圾出现在标记之后，只能等下一次GC。</li><li>需要<strong>预留空间</strong>，要为运行的用户线程预留可用空间，故不能等老年底被填满了再GC。可通过参数-XX：CMSInitiatingOccupancyFraction设置CMS触发百分比。若在CMS的GC过程中，预留空间不足以用户运行，则会出现Concurrent Mode Failure失败， 执行启动后备<strong>预案</strong>：冻结用户线程的，启动Serial Old收集器重新收集老年代。</li><li>采用标记清除算法， 会有<strong>碎片产生</strong>，若无连续足够空间，不得不提前触发GC。CMS提供参数个-XX：+UseCMS-CompactAtFullCollection，打开之后用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，但是<strong>必须停顿用户线程</strong>。还有另外一个参数-XX：CMSFullGCsBeforeCompaction，用于指定执行多少次无整理压缩的GC之后，整理一次空间。</li></ol><h3 id="7-Garbage-First收集器"><a href="#7-Garbage-First收集器" class="headerlink" title="7. Garbage First收集器"></a>7. Garbage First收集器</h3><p>G1收集器主要面向服务端应用。</p><p>之前的几个垃圾收集器只关注新生代（Minor GC）或老年代（Major GC）中之一的垃圾收集。</p><p>G1收集器跳出限制，面向java堆内任何区域组成<strong>回收集</strong>（Collection Set），衡量标准不再是它属于哪个分代，而是<strong>哪块内存中存放的垃圾数量最多</strong>，<strong>回收收益最大</strong>，这就是G1收集器的Mixed GC模式。</p><p>G1收集器基于Region实现上述目标：把java堆分为连续大小相等的<strong>多个Region区域</strong>，每个Region根据需要都可以是Survivor、Eden、或者老年代，针对扮演角色不同的Region区域采取<strong>不同的策略</strong>。</p><p>分为四个步骤：</p><ol><li>初始标记：标记GC Roots能直接关联的对象，并且指定每个Region中可以用于给并发执行的用户线程分配对象的空间区域，需要暂停用户线程，但是速度很快。</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，且用户线程可以与垃圾收集线程一起并发运行。</li><li>最终标记：采用<strong>原始快照方法</strong>更新并发过程中被修改的标记</li><li>筛选回收：找出回收价值最大的Region，将其数据复制到空的Region上，必须暂停用户线程，清空Region区域</li></ol><p><a href="/posts/b38f68fb/g1.png" data-fancybox="group" data-caption="g1收集过程" class="fancybox"><img alt="g1收集过程" data-src="/posts/b38f68fb/g1.png" class="lazyload" title="g1收集过程"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/posts/b38f68fb/gc.png&quot; data-fancybox=&quot;group&quot; data-caption=&quot;hotspot虚拟机的垃圾收集器&quot; class=&quot;fancybox&quot;&gt;&lt;img alt=&quot;hotspot虚拟机的垃圾收集器&quot; style
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时区域与OOM异常</title>
    <link href="https://jwkang99.github.io/posts/e70d4d38.html"/>
    <id>https://jwkang99.github.io/posts/e70d4d38.html</id>
    <published>2021-05-17T02:02:48.000Z</published>
    <updated>2021-08-15T12:47:40.221Z</updated>
    
    <content type="html"><![CDATA[<p>JVM将所管理的内存包括以下几个运行时数据区域。</p><p><a href="/posts/e70d4d38/java_area.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="/posts/e70d4d38/java_area.png" class="lazyload"></a></p><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>线程私有，用于指定当前线程正在执行的<strong>字节码指令地址</strong>，若执行的是本地方法，则计数器为空（Undefined），唯一一个没规定任何OutOfMemoryError（OOM）异常的区域。</p><h3 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h3><p>线程私有，与线程的生命周期相同，描述Java方法的执行。</p><p>每个方法的执行都会创建一个栈帧，存储<strong>局部变量表</strong>，操作数栈，方法出口等信息，一个方法从调用到执行完成，对应于一个栈帧入栈出栈的过程。</p><p><strong>局部变量表</strong>存放编译期可知的各种基本数据类型，对象的引用。局部变量表所需内存在编译期确定，运行时不变。</p><p> Java虚拟机栈存在StackOverflowError异常和OOM异常。如果线程请求的栈深度大于所允许的深度，抛出StackOverflowError异常；如果虚拟机栈可扩展，在扩展时没有足够内存，抛出OOM异常。</p><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>与虚拟机栈作用类似，不过执行的是本地方法，同样会抛出StackOverflowError异常和OOM异常。</p><h3 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h3><p>线程共享，几乎所有的实例对象在这里分配内存，但是JIT编译器的发展使得可能间接的分配在栈上。堆也是垃圾收集的主要区域，分为新生代和老年代。</p><p><strong>注</strong>：堆上仍有可能划分出线程私有的分配缓冲区（TLAB），在TLAB分配的对象仍在堆中。</p><p>-Xms：Java堆初始分配大小     -Xmx：Java堆最大可分配大小</p><p>Java堆可以物理不连续，但要逻辑连续。</p><p>没有足够内存分配对象会抛出OOM异常。</p><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><p>线程共享，存储虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。</p><p>方法区是堆了一个逻辑分区，但是应该与堆区分开来，JDK1.8之前使用永久代实现方法区，故被称为永久代（但是并不等价）。JDK1.8之后原本放在永久代的常量池、静态变量和类型信息被移除到元空间中。方法区用本地内存实现（Native Memory）。</p><p>方法区会抛出OOM异常。</p><p><strong>运行时常量池</strong>是方法区的一部分，Class文件中有常量池，用于存放编译期生成的各种字面量和符号引用，在类加载后着些内容会<strong>进入方法区的常量池</strong>。</p><p>注：String.intern()的应用很重要。</p><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><p>直接内存<strong>不是</strong>虚拟机运行时数据区的一部分，也不是虚拟机定义的区域。</p><p>NIO中，将本地函数库分配在堆外，java堆中的DirectByteBuffer对象引用该内存进行操作，避免Java堆和Native堆来回复制。</p><p>因为是逻辑内存，可能存在设置参数信息不当，导致超出物理内存总和，抛出OOM异常。</p><h3 id="7-抛出OOM异常情景"><a href="#7-抛出OOM异常情景" class="headerlink" title="7. 抛出OOM异常情景"></a>7. 抛出OOM异常情景</h3><h4 id="①-java堆溢出"><a href="#①-java堆溢出" class="headerlink" title="① java堆溢出"></a>① java堆溢出</h4><p>不断创建对象，并且保证GC Roots到对象之间有引用（避免回收），达到最大限制就会抛出OOM异常。例如创建List，不断往List中添加对象。</p><p>内存溢出：实际就是报OOM异常并且进一步提示Java heap space</p><p>内存泄漏：指程序在申请内存后，无法释放已申请的内存空间。就是你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而<strong>系统也不能再次将它分配给需要的程序</strong>。</p><h4 id="②-虚拟机栈和本地方法栈溢出"><a href="#②-虚拟机栈和本地方法栈溢出" class="headerlink" title="② 虚拟机栈和本地方法栈溢出"></a>② 虚拟机栈和本地方法栈溢出</h4><p>参数-Xss调整栈内存大小</p><p>StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的最大深度。 OutOfMemoryError异常：如果虚拟机的栈内存允许动态扩展，扩展栈容量无法申请到足够的内存 。</p><p><strong>注</strong>：HotSpot虚拟机不支持扩展动态扩展栈大小，故栈区域运行时不会因为栈扩展你失败抛出OOM异常，只会因为栈无法容纳新的栈帧而抛出StackOverflowError异常。</p><p>触发StackOverflowError异常：</p><ul><li>方法不断调用自身，递归调用不结束，栈深度增加，栈帧过多</li><li>本地变量过多，导致栈帧过大</li></ul><p>触发OOM异常：</p><ul><li>操作系统给每个进程分配的内存是一定的，不断创建不停止的线程，内存不够新建线程时，抛出OOM异常</li></ul><h4 id="③-方法区和运行时常量池溢出"><a href="#③-方法区和运行时常量池溢出" class="headerlink" title="③ 方法区和运行时常量池溢出"></a>③ 方法区和运行时常量池溢出</h4><p>场景：</p><p><code>String.intern()</code>：（JDK6）将首次遇到的字符串复制到常量池中，（JDK7）不再复制到常量池，将在常量池中存储首次出现实例的引用，若常量池已经有该字符串的引用返回常量池中的引用。intern()方法<a href="./5e74123b.html">详解</a>。</p><ul><li><p>JDK7之前不断添加常量到常量池，限制方法区大小<code>String.valueOf(i++).intern()</code>就会导致运行时常量池OOM异常，并提示PermGen space。<br>JDK7及之后，字符串常量池被移至Java堆，限制方法区大小不会抛出上述异常，这时需要限制堆的大小。</p></li><li><p>运行时不断生成大量动态类（反射）</p></li></ul><h4 id="④-本机直接内存溢出"><a href="#④-本机直接内存溢出" class="headerlink" title="④  本机直接内存溢出"></a>④  本机直接内存溢出</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM将所管理的内存包括以下几个运行时数据区域。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/posts/e70d4d38/java_area.png&quot; data-fancybox=&quot;group&quot; data-caption=&quot;undefined&quot; class=&quot;fancybox&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>类加载器</title>
    <link href="https://jwkang99.github.io/posts/70c5b892.html"/>
    <id>https://jwkang99.github.io/posts/70c5b892.html</id>
    <published>2021-05-16T12:51:53.000Z</published>
    <updated>2021-06-22T14:39:44.516Z</updated>
    
    <content type="html"><![CDATA[<p>类加载器的作用：通过全限定类名获取描述此类的二进制字节流</p><p><strong>类加载器的层次</strong></p><p><a href="/posts/70c5b892/class_loader.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:40%" data-src="/posts/70c5b892/class_loader.png" class="lazyload"></a></p><blockquote><p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p><strong>Java虚拟机角度</strong>，只有两种不同的加载器：<strong>启动类加载器</strong>（Bootstrap ClassLoader），由C++实现，是虚拟机的一部分；<strong>其他类加载器</strong>，由Java实现，独立于虚拟机之外，并且全部继承抽象类<code>java.lang.ClassLoader</code>。</p><p><strong>Java开发人员角度</strong>，有三种：</p><ol><li><p><strong>启动类加载器</strong>：Bootstrap ClassLoader</p><p>负责加载存放在<code>jre/lib</code>目录下，或者被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)到虚拟机内存。注：启动类加载器无法被Java程序直接引用。</p></li><li><p><strong>扩展类加载器</strong>：Extension ClassLoader</p><p>加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器，开发者可以直接使用扩展类加载器。</p></li><li><p><strong>应用程序类加载器</strong>：Application ClassLoader</p><p>该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载<strong>用户类路径</strong>(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。该类加载器是<code>getClassLoader()</code>方法的返回值，所以也称系统类加载器。 </p></li></ol><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。</p><p>编写了自己的ClassLoader，便可以做到如下几点:</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul><h4 id="类加载有三种方式"><a href="#类加载有三种方式" class="headerlink" title="类加载有三种方式"></a>类加载有三种方式</h4><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过Class.forName()方法动态加载</p><p>3、通过ClassLoader.loadClass()方法动态加载</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完成</strong>，每一个层次的类加载器都是如此，因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p><strong>代码流程</strong>：先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败， 抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p><p><strong>双亲委派优势</strong></p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>双亲委派机制就是让越基础的类由越顶层的加载器加载，但是也存在基础类调用回用户代码的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类加载器的作用：通过全限定类名获取描述此类的二进制字节流&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类加载器的层次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/posts/70c5b892/class_loader.png&quot; data-fancybox=&quot;group&quot; data
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Minor/Major/Full GC</title>
    <link href="https://jwkang99.github.io/posts/13c7dd67.html"/>
    <id>https://jwkang99.github.io/posts/13c7dd67.html</id>
    <published>2021-05-16T02:02:48.000Z</published>
    <updated>2021-08-14T06:17:55.757Z</updated>
    
    <content type="html"><![CDATA[<p>对象的内存分配是在java堆上分配（也可能经过JIT编译后被拆散为标量间接分配在栈上），主要分配子新生代的Eden区，如果启动了本地线程分配缓冲，将按线程优先再TLAB上分配，少数情况直接分配在老年代。</p><p><a href="/posts/13c7dd67/generation.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/13c7dd67/generation.png" class="lazyload"></a></p><p>下边主要阐述Serial/Serial Old组合下的内存分配和回收策略。</p><p><strong>对象在新生代Eden区分配</strong>，若Eden没有足够空间，触发Minor GC</p><p><strong>Minor GC</strong>（因为有对象复制移动，stop-the-world）</p><p>发生在新生代，将From和Eden区存活的对象<strong>复制到To区域</strong>，当To区域不足以存放所有存活的对象时，通过老年代的<strong>内存担保</strong>，To区域放不下的存活对象<strong>提前</strong>进入老年代。</p><p><strong>大对象直接进入老年代</strong></p><p>通过参数了-XX：PretenureSizeThreshold设置大于指定大小的对象直接分配到老年代，避免在新生代产生大量复制大对象的操作。注：该参数只对Serial和ParNew两种新生代收集器有效。</p><p><strong>大龄对象进入老年代</strong></p><p>通过参数-XX： MaxTenuringThreshold（默认15）设置进入老年代年龄。对象在Eden区分配后，经历一次Minor GC年龄加1。</p><p><strong>动态判定对象年龄</strong></p><p>当Survivor区（From/To）中相同年龄的对象大小总和达到了Survivor的一半，<strong>大于等于</strong>该年龄的对象<strong>提前</strong>进入老年代。</p><p><strong>空间分配担保</strong></p><p>老年代会给新生代的回收座内存担保。<br>在Minor GC之前，</p><p>若老年代可用连续内存<strong>大于</strong>新生代所有对象总和，则<strong>Minor GC安全</strong>。<br>若老年代可用连续内存不能容纳所有新生代所有对象，则可能担保失败（即新生代放不下的存活对象在老年代也放不下，可能要丢弃）。</p><p>此时若虚拟机<strong>不允许担保失败</strong>，则进行一次Full GC。<br>若虚拟机<strong>允许担保失败</strong>，则检查每次从新生代转移到老年代对象的平均大小，若能放下，尝试Minor GC（失败后仍触发Full GC），若放不下触发Full GC。</p><p><strong>JDK6之后不再使用是否允许担保失败的参数</strong>。若老年代连续可用空间大于新生代对象总和或历次晋升的平均值，则触发Minor GC，否则Full GC。</p><p><strong>Full GC</strong></p><p>回收整个java堆，通常由Minor GC担保失败后触发，Full GC通常会包含一次Minor GC。</p><p><strong>Major GC</strong></p><p>CMS收集器中，当老年代满时会触发 Major GC。目前，只有CMS收集器会有单独收集老年代的行为。其他收集器均无此行为。针对新生代（主要指Eden区）的Minor GC 比较常见，各个收集器均支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象的内存分配是在java堆上分配（也可能经过JIT编译后被拆散为标量间接分配在栈上），主要分配子新生代的Eden区，如果启动了本地线程分配缓冲，将按线程优先再TLAB上分配，少数情况直接分配在老年代。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/posts/13c7dd67/gen
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM判断对象是否可回收</title>
    <link href="https://jwkang99.github.io/posts/d51b6e9c.html"/>
    <id>https://jwkang99.github.io/posts/d51b6e9c.html</id>
    <published>2021-05-16T02:02:48.000Z</published>
    <updated>2021-06-11T14:11:36.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h2><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1 引用计数法"></a>1 引用计数法</h3><p>给每个对象添加一个<strong>引用计数器</strong>，每当一个地方引用它，计数器加1，失效就减1。任何时刻计数器为0的对象就是不可能在被使用的对象，说明该对象已死。</p><p>引用计数法实现简单，效率高。但是很难解决对象互相循环引用的问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object A = <span class="keyword">new</span> Object();</span><br><span class="line">Object B = <span class="keyword">new</span> Object();</span><br><span class="line">A.prop1 = B;</span><br><span class="line">B.prop1 = A;</span><br><span class="line">A=<span class="keyword">null</span>;</span><br><span class="line">B=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></div><p>上述例子若采用引用计数法，即使A,B对象占用的内存区域用不到了，A,B对象永远无法回收，因为计数器为1。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2 可达性分析算法"></a>2 可达性分析算法</h3><p>主流的商用程序语言主要使用的是<strong>可达性分析算法</strong>。</p><p>可达性分析算法是从一系列称为<strong>GC Roots</strong>的对象做为起点，开始搜索，走过的路径称为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链时，则该对象不可用，可以回收。</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>GC Roots主要在全局性的引用（常量和静态变量）和执行上下文（栈帧的本变量表）中。分为两类，一类是<strong>生命周期很长</strong>的对象比如说类的静态变量，另一类是<strong>一定是有用的对象</strong>比如说栈帧的局部变量，这里代表了程序正在执行的地方，这里应用的对象一定是不能被回收的。Java可以作为GC Roots的对象包括下边几种：</p><p>① 虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。<br>② 方法区中<strong>类静态属性</strong>引用的对象，譬如Java类的<strong>引用类型</strong>静态变量。<br>③ 方法区中<strong>常量</strong>引用的对象，譬如<strong>字符串常量池</strong>（String Table）里的引用<br>④ 本地方法栈中JNI（即一般说的Native方法）引用的对象。<br>⑤ Java虚拟机内部的引用，如基本类型数据对应的Class对象，一些常驻的异常对象，类加载器等。<br>⑥ 所有被同步锁（synchronized关键字）持有的对象。</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“<strong>临时性</strong>”地加入，共同构成完整GC Roots集合。举例：。。。</p><h3 id="3-引用类型"><a href="#3-引用类型" class="headerlink" title="3 引用类型"></a>3 引用类型</h3><p>上述两种方法都和引用有关，在JDK 1.2版之前，Java里面的引用是很传统的定义，只有“被引用”或者“未被引用”两种状态。</p><p>我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象，在很多系统的<strong>缓存功能</strong>都符合这样的应用场景。</p><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>（Strongly Reference）、<strong>软引用</strong>（Soft Reference）、<strong>弱引用</strong>（Weak Reference）和<strong>虚引用</strong>（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li><strong>强引用</strong>：最传统的引用的定义，是指直接引用赋值，类似<code>Object obj = new Object()</code>，只要强引用存在，GC就<strong>永远不会回收</strong>被引用的对象。</li><li><strong>软引用</strong>：描述一些还<strong>有用但非必需</strong>的对象。对于软引用关联的对象，<strong>在内存足够的时候，软引用对象不会被回收</strong>，在系统要发生内存溢出异常之前，将会把这些对象放入回收范围内进行第二次回收。如果这次回收hi没有足够内存，抛出OOM异常。</li><li><strong>弱引用</strong>：也用来描述<strong>非必需</strong>的对象，但强度比软引用更弱，弱引用的对象只能<strong>存活到下一次GC发生之前</strong>，垃圾收集器工作时，无论内存是否足够，只被弱引用的对象都要被回收。</li><li><strong>虚引用</strong>：<strong>最弱</strong>的引用关系，一个对象是否有虚引用，完全不会影响其生存时间，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用的目的就是<strong>能在这个对象被回收时收到一个系统通知</strong>。</li></ul><h3 id="4-对象是否真的死亡"><a href="#4-对象是否真的死亡" class="headerlink" title="4 对象是否真的死亡"></a>4 对象是否真的死亡</h3><p>即使在可达性分析算法中不可达的对象，也<strong>不是非死不可</strong>，要真正宣告一个对象死亡，<strong>至少经过两次标记</strong>。</p><p>标记过程：如果没有从GC Roots到对象的引用链，就进行<strong>第一次标记</strong>，如果该对象<strong>覆盖</strong>了finalize()方法并且finalize()<strong>没被虚拟机执行</strong>过（满足这俩条件则有必要执行该对象的finalize方法），将该对象放在F-Queue队列中。稍后虚拟机<strong>启动一个线程</strong>触发队列中对象的finalize方法，随后GC将对F-Queue中的对象进行<strong>第二次标记</strong>，如果某对象在finalize方法里拯救了自己（即重新添加了引用），则不会标记该对象，并将其移除即将回收集合；否则，就要真的被回收了。</p><p><strong>注</strong>：finalize方法只能自动调用一次，也就是只能自救一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;判断对象是否可回收&quot;&gt;&lt;a href=&quot;#判断对象是否可回收&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否可回收&quot;&gt;&lt;/a&gt;判断对象是否可回收&lt;/h2&gt;&lt;h3 id=&quot;1-引用计数法&quot;&gt;&lt;a href=&quot;#1-引用计数法&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收和内存分配策略</title>
    <link href="https://jwkang99.github.io/posts/566ec62f.html"/>
    <id>https://jwkang99.github.io/posts/566ec62f.html</id>
    <published>2021-05-16T02:02:48.000Z</published>
    <updated>2021-06-21T13:27:28.370Z</updated>
    
    <content type="html"><![CDATA[<p>java运行时内存包括程序计数器、本地方法栈、虚拟机栈、java堆和方法区。</p><p><strong>程序计数器、本地方法栈、虚拟机栈</strong>是<strong>线程</strong>私有的，这三个区域随线程生灭，栈中的栈帧随方法进入退出而进行着出栈入栈的操作，每一个栈帧分配多少内存基本上是再类结构确定下来时就已知，因此这几个区域的内存分配和回收具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就回收了。</p><p><strong>Java堆和方法区</strong>不一样，是所有线程共享的区域，一个接口的多个实现类所需内存可能不一样，一个方法的多个分支需要的内存可能不一样只有程序在运行时才能知道会创建哪些对象，这部分内存分配和回收都是动态的，垃圾回收关注的也是这部分内存。</p><p>① <a href="./d51b6e9c.html">判断对象是否可回收</a></p><p>② <a href="82902146.html">垃圾回收算法</a></p><p>③ <a href="./b38f68fb.html">垃圾收集器</a></p><p>④ <a href="./13c7dd67.html">内存分配和回收策略</a></p><p><strong>方法区垃圾回收</strong>单独拿出来说：</p><p>方法区（HotSpot虚拟机中的永久代）的垃圾回收在JVM没做要求，因为在永久代中回收效率太低。</p><p>永久代主要回收两部分：废弃<strong>常量</strong>和无用的<strong>类</strong>。</p><p><strong>废弃常量回收</strong>和java堆中的回收类似，如果没有任何String类型对象引用常量池中的字符串<code>abc</code>，有必要的话会清理这个字符串常量。</p><p><strong>无用类</strong>回收需满足三个条件，但并不一定会被回收，有参数进行控制</p><p>① 该类所有实例都被回收<br>② 加载该类的ClassLoader已经被回收<br>③ 该类的Class对象没被引用，没有地方通过反射访问该类的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java运行时内存包括程序计数器、本地方法栈、虚拟机栈、java堆和方法区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序计数器、本地方法栈、虚拟机栈&lt;/strong&gt;是&lt;strong&gt;线程&lt;/strong&gt;私有的，这三个区域随线程生灭，栈中的栈帧随方法进入退出而进行着出栈入栈的操作
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收算法</title>
    <link href="https://jwkang99.github.io/posts/82902146.html"/>
    <id>https://jwkang99.github.io/posts/82902146.html</id>
    <published>2021-05-16T02:02:48.000Z</published>
    <updated>2021-06-21T08:35:59.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1 标记-清除算法"></a>1 标记-清除算法</h3><p>标记出需要回收的对象，完成标记后统一回收。效率不高，容易出产生碎片，会导致触发多次GC。</p><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2 复制算法"></a>2 复制算法</h3><p>把内存容量分为相同的两部分，每次只使用其中的一半，触发GC时将存活的对象放在另外一半上，再把另一半完全清理了，<strong>不会产生碎片</strong>，代价是<strong>缩小了可用内存</strong>。</p><p>因为<strong>新生代</strong>98%的对象朝生夕死，所以不需要1:1划分，而是分成一块较大的Eden区和两块大小相等的Survivor区，比例为8:1:1，只使用Eden和一块Survivor区采用复制算法，这样只有10%的内存被浪费了。当然也不能保证每次GC中存活的对象都不超过10%，所以就需要老年代的内存做<strong>分配担保</strong>，也就是老年代给新生代擦屁股。</p><p>复制算法在对象存活率较高时就需要进行<strong>较多复制操作</strong>，<strong>效率就会变低</strong>。而且复制算法需要额外内存进行担保，所以老年代不用复制算法。</p><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3 标记-整理算法"></a>3 标记-整理算法</h3><p>标记之后将存活的对象移到一端，然后直接清除掉边界之外的内存。</p><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4 分代收集算法"></a>4 分代收集算法</h3><p>根据存活周期不同，分代收集。<strong>新生代</strong>复制算法，<strong>老年代</strong>没有额外空间担保标记-清除或者标记-整理算法。</p><h3 id="5-HotSpot的上述算法实现"><a href="#5-HotSpot的上述算法实现" class="headerlink" title="5 HotSpot的上述算法实现"></a>5 HotSpot的上述算法实现</h3><h4 id="GC-Roots枚举"><a href="#GC-Roots枚举" class="headerlink" title="GC Roots枚举"></a>GC Roots枚举</h4><p>GC Roots主要在全局性的引用（常量和静态变量）和执行上下文（栈帧的本变量表）中，<strong>逐个检查必然会消耗很多时间</strong>。</p><p>可达性分析时必须在一个<strong>确保一致性的快照</strong>中进行，获取快照将导致<strong>用户线程暂停</strong>（Stop The World）。</p><p>HotSpot使用<strong>准确式GC</strong>，系统停顿之后不需要一个不漏的检查所有全局性引用和执行上下文，通过<strong>OopMap（还不太理解？）</strong>的数据结构直接得知哪些地方存着对象引用。在类加载完之后，就把对象内什么偏移量上是什么类型的数据计算出来。在JIT编译过程中，也会在特定位置记录栈和寄存器中哪些位置是引用。</p><p>因此GC在扫描时就可以快速准确的完成GC Roots枚举。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>再看看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-标记-清除算法&quot;&gt;&lt;a href=&quot;#1-标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;1 标记-清除算法&quot;&gt;&lt;/a&gt;1 标记-清除算法&lt;/h3&gt;&lt;p&gt;标记出需要回收的对象，完成标记后统一回收。效率不高，容易出产生碎片，会导致触发多次G
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="GC" scheme="https://jwkang99.github.io/tags/GC/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="https://jwkang99.github.io/posts/6d27f500.html"/>
    <id>https://jwkang99.github.io/posts/6d27f500.html</id>
    <published>2021-05-13T07:02:48.000Z</published>
    <updated>2021-06-22T14:39:19.125Z</updated>
    
    <content type="html"><![CDATA[<p>类加载机制：虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机可以直接使用的java类型。</p><p>类从被加载都虚拟机内存中开始，到写在出内存为止，整个生命周期包括：<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>、<strong>使用</strong>和<strong>卸载</strong>7个阶段。其中验证、准备、解析3个部分统称为<strong>连接</strong>。</p><p><a href="/posts/6d27f500/life.jpg" data-fancybox="group" data-caption="类的生命周期" class="fancybox"><img alt="类的生命周期" zoom="70%" data-src="/posts/6d27f500/life.jpg" class="lazyload" title="类的生命周期"></a></p><p>其中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的（开始的顺序确定，但是进行和完成可能是交叉进行的）。由于java的运行时绑定（动态绑定），<strong>解析</strong>可能会在某种情况下在<strong>初始化之后</strong>才开始。</p><p><strong>类加载的时机</strong></p><p><strong>有且仅有</strong>5种情况，必须立即对类进行<strong>初始化</strong>（加载、验证、准备当然也必须在这之前完成）</p><p>① 遇到new、getstatic、putstatic、或者invokestatic这4调字节码指令时，如果类没有进行初始化，则需要先触发初始化。这4条指令要么新建一个该类的<strong>实例</strong>，或者与<strong>静态操作</strong>相关，不难理解必需先初始化该类。不过被<strong>final修饰的静态字段</strong>除外，因为其已经自编译时被放入<strong>常量池</strong>。</p><p>② 在使用<code>java.lang.reflect</code>对类进行<strong>反射调用</strong>时，须先初始化。</p><p>③ 初始化一个类时，其父类还未初始化，须先初始化<strong>父类</strong>。（<strong>注</strong>：接口在此处不同真正用到时才会初始化父接口）</p><p>④ 虚拟机启动时，先初始化用户指定的执行<strong>主类</strong>。</p><p>⑤ 一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果中，<strong>方法句柄</strong>对应的类，须先初始化。（似乎是JDK1.7之后才有的）</p><p>以上5种统称为对类的<strong>主动引用</strong>，被动引用不会触发初始化。<br>被动例子：</p><ol><li><strong>子类使用父类的静态字段</strong>，跟子类没关系，故子类不会初始化。</li><li><strong>定义一个该类的数组</strong>Object[] arr，不会初始化该类，因为没有用到类，可以使用的只有a.length和a.clone()。</li><li><strong>final修饰的静态字段</strong>在编译阶段会存入<strong>调用类</strong>（注：不是该字段的所属类）的常量池，不会触发初始化。</li></ol><h3 id="一、加载：查找并加载类的二进制数据"><a href="#一、加载：查找并加载类的二进制数据" class="headerlink" title="一、加载：查找并加载类的二进制数据"></a>一、加载：查找并加载类的二进制数据</h3><p><strong>加载</strong>是<strong>类加载过程</strong>的一个阶段，该阶段虚拟机完成3件事：<br>① 通过类的全限定名<strong>获取类的二进制字节流</strong>。（<strong>where</strong>：从ZIP、JAR、网络、运行时计算中等等获取，<strong>how</strong>：系统提供的加载器或自定义加载器，<a href="./70c5b892.html">这里</a>介绍类加载器）<br>② 将字节流所代表的静态存储结构<strong>转化</strong>为方法区的运行时数据结构。<br>③ 在内存中生成一个代表该类的java.lang.Class对象（虽是对象，但是存在方法区中），作为方法区该类的访问入口。<br>注：数组类由jvm直接创建，但数组类中的元素仍要靠加载器。</p><p><a href="/posts/6d27f500/java_jvm_classload_1.png" data-fancybox="group" data-caption="类的生命周期" class="fancybox"><img alt="类的生命周期" zoom="70%" data-src="/posts/6d27f500/java_jvm_classload_1.png" class="lazyload" title="类的生命周期"></a></p><p>相对于类加载的其他阶段而言，<strong>加载阶段</strong>(准确地说，是加载阶段获取类的二进制字节流的动作)<strong>是可控性最强的阶段</strong>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载</p><h3 id="二、验证：确保被加载的类的正确性"><a href="#二、验证：确保被加载的类的正确性" class="headerlink" title="二、验证：确保被加载的类的正确性"></a>二、验证：确保被加载的类的正确性</h3><p>连接阶段第一步，目的是确保class文件的字节流中所包含的信息符合虚拟机要求，并且不会危害虚拟机安全。</p><p>纯粹的java代码无法做到访问越界的数组元素、将一个对象转型为未实现类型、跳转到不存在的代码行等不安群行为，因为如果这些行为存在，编译器将拒绝将源码编译成class文件。<strong>但是</strong>，class文件不一定从源码编译过来，也可以直接编写class文件，所以验证还是很有<strong>必要</strong>的。（会抛出java.lang.VerifyError及其子类异常），可以通过<strong>-Xverify:none</strong>来<strong>关闭大部分类验证</strong>措施。</p><p>验证阶段完成<strong>4个阶段</strong>的检查动作：<strong>文件格式验证</strong>(魔数版号等)、<strong>元数据验证</strong>(语义分析：是否覆盖了不能覆盖的方法等)、<strong>字节码验证</strong>(程序语义：指令跳转不到非法区域或出栈数据和要求类型不一致)、<strong>符号引用验证</strong>(确保符号引用能找到对应的类)。</p><h4 id="1-文件格式验证"><a href="#1-文件格式验证" class="headerlink" title="1.文件格式验证"></a>1.文件格式验证</h4><p>验证字节流是否符合Class文件<strong>格式</strong>的规范，主要目的是<strong>保证输入的字节流能正确的解析</strong>，并存储于<strong>方法区</strong>，<strong>格式上符合</strong>描述一个java类型的<strong>要求</strong>。</p><p>该阶段验证点包括但<strong>不限于</strong>以下几点：<br>①是否以<strong>魔数</strong>0xCAFEBABE开头。<br>②主、次<strong>版本号</strong>是否在当前虚拟机处理范围内。<br>③<strong>常量池</strong>中是否有不被支持的类型（检查常量tag标志）。<br>④ 指向<strong>常量的索引</strong>是否指向不存在的常量或者不符合类型常量。</p><h4 id="2-元数据验证"><a href="#2-元数据验证" class="headerlink" title="2.元数据验证"></a>2.元数据验证</h4><p>对类的元数据信息进行<strong>语义校验</strong>，保证描述的<strong>信息符合</strong>java类型的<strong>要求</strong>。</p><p>该阶段验证包括但<strong>不限于</strong>：<br>① 是否有<strong>父类</strong>（除Object都有父类）<br>② 其父类是否<strong>继承</strong>了不允许继承的类（final类）<br>③ 若该类不是抽象类，是否<strong>实现了父类或者接口中要求的所有方法</strong><br>④ 类中的字段、方法是否<strong>与父类冲突</strong>（final字段、或错误重载）</p><h4 id="3-字节码分析"><a href="#3-字节码分析" class="headerlink" title="3. 字节码分析"></a>3. 字节码分析</h4><p>通过数据流和控制流分析，确定<strong>程序语义</strong>合法、符合逻辑。在元数据信息验证完成后，该阶段会对<strong>类的方法体</strong>进行验证，保证类的方法在运行时不会危害虚拟机。</p><h4 id="4-符号引用验证"><a href="#4-符号引用验证" class="headerlink" title="4. 符号引用验证"></a>4. 符号引用验证</h4><p>这步验证发生在虚拟机<strong>将符号引用转化为直接引用</strong>的时候（该转化发生在<strong>解析阶段</strong>）。</p><p>符号引用验证可以看作是对<strong>类自身以外的信息</strong>进行匹配性校验（常量池中的各种符号引用），目的为确保解析动作的正常执行。</p><p>符号引用就是用一组符号里描述所引用的目标，只要能准确的定位到所引用的目标，任何形式字面量都可以。<br>理解：在编译的时候每个java类都被编译成了class文件，在编译的时候虚拟机并不知道所引用类的地址，就用符号表示，而这个发生在解析阶段的这个转化过程就是将这个<strong>符号表示转化成真正的地址</strong>。</p><p>通常需要校验下列内容<strong>但不限于</strong>：<br>① 符号引用中通过字符串描述的<strong>全限定名</strong>是否能找到对应的类<br>② 在指定类中是否存在符合方法的<strong>字段描述</strong>，以及简单名称所描述的方法和字段<br>③ 符号引用中的类、字段、方法的<strong>访问性</strong>（pirvate、protected、public、default）是否可以被当前类访问</p><h3 id="三、准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#三、准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="三、准备：为类的静态变量分配内存，并将其初始化为默认值"></a>三、准备：为类的静态变量分配内存，并将其初始化为默认值</h3><p>为<strong>类变量</strong>在<strong>方法区</strong>中<strong>正式分配内存</strong>并设置<strong>类变量</strong>的初始值（通常为数据类型的0值，而不是程序员指定的值），<strong>注</strong>：这里进行内存分配的变量仅包括类变量（static），而不是实例变量（实例变量随实例分配在java堆中）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span></span><br></pre></td></tr></table></figure></div><p><strong>通常情况下</strong>在准备阶段后value的初始值为0，不是123。给value赋值的putstatic指令编译后存放于<clinit()>中，在初始化阶段才会执行。</clinit()></p><p>也有<strong>例外</strong>，如果类字段的字段属性表中存在<strong>ConstantValue</strong>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为<strong>ConstantValue</strong>属性所指定的值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span></span><br></pre></td></tr></table></figure></div><p>假设上面的类变量value定义，<strong>编译</strong>时Javac将会为value生成ConstantValue属性，在<strong>准备</strong>阶段虚拟机就会根据ConstantValue的设置将value<strong>赋值</strong>为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中。</p><h3 id="四、解析：符号引用替换为直接引用"><a href="#四、解析：符号引用替换为直接引用" class="headerlink" title="四、解析：符号引用替换为直接引用"></a>四、解析：符号引用替换为直接引用</h3><p>解析阶段是将常量池内的<strong>符号引用替换为直接引用</strong>的过程。</p><p>符号引用：正如在验证阶段所说的那样，符号引用可以是<strong>任何形式的字面量</strong>，且引用的目标<strong>不一定已经加载到内存</strong>。字面量形式有明确定义，所以在各种虚拟机中符号引用必须<strong>一致</strong>。</p><p>直接引用：直接指向目标的指针、相对偏移量、或者能间接定位目标的句柄，且目标已经<strong>存在于内存</strong>中。同一符号引用在不同虚拟机中转化得到的直接引用<strong>一般不同</strong>。</p><p>为避免解析动作重复执行，虚拟机会对第一次解析的结果进行缓存（invokedynamic指令除外），第一次成功或异常，后续的都会收到同样的结果。</p><p><strong>重点</strong>：解析阶段中，主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>7类符号引用进行解析。后3种需要动态语言支持，这里先概述前4种。</p><h4 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1.类或接口的解析"></a>1.类或接口的解析</h4><p>当前类D对类或接口C的符号引用为N，需要转换成直接引用，需要三个步骤：</p><p>① 若C<strong>不是数组类型</strong>，虚拟机会把代表N的<strong>全限定名</strong>传递给D的类加载器去加载类C。在加载过程中，元数据和字节码验证的要求，有可能会触发其他<strong>相关类的加载</strong>动作，例如加载这个类的父类或者实现接口。</p><p>② 若C是一个<strong>数组类型</strong>，并且数组元素类型为<strong>对象</strong>，也就是N的描述符为[java/lang/Integer]的形式，那将会按照①加载数组元素的类型，即去加载类java.lang.Integer，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</p><p>③ 若前两步没有异常，那么C在虚拟机中已经成为了一个有效的类或者接口了，但在解析完成之前需要进行符号引用验证，确认D是否具备对C的访问权限。若没权限，则抛出java.lang.IllegalAccessError异常。</p><h4 id="2-字段解析"><a href="#2-字段解析" class="headerlink" title="2.字段解析"></a>2.字段解析</h4><p>对于一个字段符号引用，首先会对字段所属的类或者接口的符号引用进行解析，解析成功后将这个字段所属的类或者接口用C表示。</p><h4 id="3-类方法解析"><a href="#3-类方法解析" class="headerlink" title="3. 类方法解析"></a>3. 类方法解析</h4><h4 id="4-接口方法解析"><a href="#4-接口方法解析" class="headerlink" title="4.接口方法解析"></a>4.接口方法解析</h4><h3 id="五、初始化：类的静态变量赋予正确的初始值"><a href="#五、初始化：类的静态变量赋予正确的初始值" class="headerlink" title="五、初始化：类的静态变量赋予正确的初始值"></a>五、初始化：类的静态变量赋予正确的初始值</h3><p>在Java中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>JVM初始化步骤</strong></p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则<strong>先初始化其直接父类</strong></li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>下边的大概看看就行：</p><p>在初始化阶段才真正开始执行类中定义的java程序代码（或字节码）。</p><p>初始化阶段执行类构造器<strong><clinit()></clinit()></strong>方法的过程，<strong><clinit()></clinit()></strong>执行过程中的行为特点和细节如下：</p><p>① <strong><clinit()></clinit()></strong>是由编译器自动收集类中的所有变量的<strong>赋值动作</strong>和<strong>静态语句</strong>块中的语句合并而成。<strong>注</strong>：静态语句块只能访问在之前定义的变量，定在之后的变量只能赋值不能访问。</p><p>② <strong><clinit()></clinit()></strong>方法与类的构造函数不同，不需要显式的调用父类构造器，虚拟机会保证在子类的<strong><clinit()></clinit()></strong>之前，父类的<strong><clinit()></clinit()></strong>已经执行完成，因此虚拟机中第一个被执行的<strong><clinit()></clinit()></strong>方法是Object类。</p><p>③ 由于父类的<strong><clinit()></clinit()></strong>先执行，所以<strong>父类的静态语句优先级高于子类的变量赋值操作</strong>。</p><p>④ <strong><clinit()></clinit()></strong>不必须，若没有变量的<strong>赋值动作</strong>和<strong>静态语句</strong>块，则不会生成<strong><clinit()></clinit()></strong>方法。</p><p>⑤ 接口中没有静态语句块，但仍然你可以有变量初始化的赋值操作，但不同的是执行接口的<strong><clinit()></clinit()></strong>方法前不需要限制性父接口的<strong><clinit()></clinit()></strong>方法，只有用到父接口中的变量是才会执行。</p><p>⑥ <strong><clinit()></clinit()></strong>会加锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类加载机制：虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机可以直接使用的java类型。&lt;/p&gt;
&lt;p&gt;类从被加载都虚拟机内存中开始，到写在出内存为止，整个生命周期包括：&lt;strong&gt;加载&lt;/strong&gt;、&lt;str
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://jwkang99.github.io/tags/jvm/"/>
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>前缀和</title>
    <link href="https://jwkang99.github.io/posts/8628805.html"/>
    <id>https://jwkang99.github.io/posts/8628805.html</id>
    <published>2020-07-22T12:51:53.000Z</published>
    <updated>2020-07-22T13:55:42.153Z</updated>
    
    <content type="html"><![CDATA[<p>​        在计算某数据结构的中间部分的连续和的问题中，可以使用前缀和进行求解，例如<code>1-i</code>的前缀和与<code>1-j</code>的前缀和可以找出连续部分<code>i-j</code>的和，该方法同样使用与在树或者图结构中解决相应问题。</p><h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h4><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><p>示例 1 :</p><p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于此处让计算的子数组个数，所以在此存储每种前缀和的个数</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; prefixSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    prefixSum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        res += prefixSum.getOrDefault(sum-k,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(sum,prefixSum.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437.路径总和 III"></a>437.路径总和 III</h4><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></p><p><strong>分析</strong>：本题样可以使用前缀和进行计算。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储本路径上前缀和信息</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; prefixSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        prefixSum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        pathSumHelper(root,sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSumHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> curSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curSum += root.val;</span><br><span class="line">        count += prefixSum.getOrDefault(curSum-sum,<span class="number">0</span>);</span><br><span class="line">        prefixSum.put(curSum,prefixSum.getOrDefault(curSum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        pathSumHelper(root.left,sum,curSum);</span><br><span class="line">        pathSumHelper(root.right,sum,curSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curCount = prefixSum.getOrDefault(curSum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(curCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            prefixSum.put(curSum,curCount-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        curSum -= root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        在计算某数据结构的中间部分的连续和的问题中，可以使用前缀和进行求解，例如&lt;code&gt;1-i&lt;/code&gt;的前缀和与&lt;code&gt;1-j&lt;/code&gt;的前缀和可以找出连续部分&lt;code&gt;i-j&lt;/code&gt;的和，该方法同样使用与在树或者图结构中解决相应问题。&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://jwkang99.github.io/categories/leetcode/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
      <category term="算法" scheme="https://jwkang99.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://jwkang99.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://jwkang99.github.io/posts/111e02e0.html"/>
    <id>https://jwkang99.github.io/posts/111e02e0.html</id>
    <published>2020-07-22T03:20:15.000Z</published>
    <updated>2021-08-22T10:09:40.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="写在前边，概要总结"><a href="#写在前边，概要总结" class="headerlink" title="写在前边，概要总结"></a>写在前边，概要总结</h3><h4 id="volatile关键字是什么？"><a href="#volatile关键字是什么？" class="headerlink" title="volatile关键字是什么？"></a>volatile关键字是什么？</h4><p>关键字volatile可以说是Java虚拟机提供的<strong>最轻量级</strong>的同步机制。volatile变量具有两个特点：可见性和禁止指令重排。</p><h4 id="volatile如何保证可见性？"><a href="#volatile如何保证可见性？" class="headerlink" title="volatile如何保证可见性？"></a>volatile如何保证可见性？</h4><p>Java内存模型是通过在变量修改后<strong>将新值同步回主内 存</strong>，在变量读取前<strong>从主内存刷新变量值</strong>这种<strong>依赖主内存作为传递媒介</strong>的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能<strong>立即</strong>同步到主内存，以及每次使用前<strong>立即从主内存</strong>刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p><p>synchronized和final也能保证可见性。</p><h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1. 可见性"></a>1. 可见性</h3><p>​    指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的，普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。即：<strong>volatile变量在各个线程的工作内存中是不存在一致性问题的</strong>。</p><h3 id="2-禁止指令重排"><a href="#2-禁止指令重排" class="headerlink" title="2. 禁止指令重排"></a>2. 禁止指令重排</h3><p>在执行程序时为了提高性能，编译器和处理器可能会对操作做<strong>重排序</strong>。普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。如以下例子，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">loadConfig();</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure></div><p>如果定义 initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一条 代码“initialized=true”被提前执行。这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。</p><p>关键变化在于有volatile修饰的变量，将java代码转换为汇编代码之后，发现<strong>赋值后</strong>多执行了一个<code>lock addl$0x0，(%esp)</code>（把ESP寄存器的值加0）操作，这个操作的作用相当于一个<strong>内存屏障</strong>（重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p><p>这里的关键在于<strong>lock前缀</strong>，查询IA32手册可知，它的作用是将<strong>本处理器的缓存</strong>写入了内存，该写入动作也会引起别的处理器<strong>无效化其缓存</strong>，这种操作相当于对缓存中的变量做了一次前面介绍Java内存模式中所说的store和write操作。所以通过这样一个空操作，可让前面volatile变量的修改对其他处理器<strong>立即可见</strong>。</p><p>这条lock指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。</p><p>要理解volatile关键字首先要了解java内存模型，Java内存模型为volatile专门定义了一些特殊的访问规则，例如：</p><ol><li>线程t1对变量V执行的前一个动作是load的时候，t1才能对变量V执行use动作；并且，只有当t1对变量V执行的后一个动作是use的时候，t1才能对变量V执行load动作。t1对变量V的use动作可以认为是和t1对变量V的load、read动作相关联的，必须连续且一起出现。</li></ol><p>这条规则说明了，每次使用变量V前都必须<strong>先从主内存刷新最新的值</strong>，用于保证能看见其 他线程对变量V所做的修改。</p><ol><li>只有当t1对变量V执行的前一个动作是assign的时候，t1才能对变量V执行store动作；并且，只有当t1对变量V执行的后一个动作是store的时候，t1才能对变量V执行assign动作。t1对变量V的assign动作可以认为是和t1对变量V的store、write动作相关联的，必须连续且一起出现。</li></ol><p>保证每次修改V后都必须<strong>立刻同步回主内存</strong>中，用于保证其他线程可以看到自己对变量V所做的修改。</p><ol><li><p>有以下两组动作：</p><ol><li>动作A：t1对变量V实施的use或assign动作<br>动作F：和动作A相关联的load或store动作<br>动作P：和动作F相应的对变量V的read或write动作；</li><li>动作B：t1对变量W 施的use或assign动作<br>动作G：和动作B相关联的load或store动作<br>动作Q：和动作G相应的对变量W的read或write动作</li></ol><p>如果A先于B，那么P先于Q。</p></li></ol><p>保证要求volatile修饰的变量<strong>不会被指令重排序优化</strong>，从而保证代码的执行顺序与程序的顺序相同。</p><p>以上参考深入理解Java虚拟机写的，以下为之前参考<a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html" target="_blank" rel="noopener">pdai博客</a>写的。</p><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><h4 id="防止指令重排"><a href="#防止指令重排" class="headerlink" title="防止指令重排"></a>防止指令重排</h4><p>在并发环境下，单例模式的实现方式最多的是使用Double Check的方式，代码如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile保证instance可见性，禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton_6 instance;</span><br><span class="line">    <span class="comment">//私有构造函数，禁止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//doube check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton_6<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton_6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在上述代码中，new Singleton_6()实例的构造对象可以分为三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ul><p>但是由于操作系统为了提高性能可以对指令进行重排序，所以这三个步骤的顺序可能会被打乱。</p><ul><li>分配内存空间</li><li>将内存空间的地址赋值给对应的引用</li><li>初始化对象</li></ul><p>如果是上述的流程，在多线程环境下，就有可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p><h4 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h4><p>可见性问题主要是指一个线程修改了共享变量值，但还没有写回到内存中，其他线程却看不到这个变化。如下图所示：</p><p><a href="/posts/111e02e0/volitale.png" data-fancybox="group" data-caption="image-20200301213039998" class="fancybox"><img alt="image-20200301213039998" data-src="/posts/111e02e0/volitale.png" class="lazyload" title="image-20200301213039998"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 0;  &#x2F;&#x2F;初始状态a &#x3D; b &#x3D; 0，结果允许x &#x3D; y &#x3D; 0出现</span><br><span class="line">b &#x3D; 0;</span><br><span class="line">a &#x3D; 1;  &#x2F;&#x2F;线程A</span><br><span class="line">x &#x3D; b;  &#x2F;&#x2F;线程A</span><br><span class="line">b &#x3D; 2;  &#x2F;&#x2F;线程B</span><br><span class="line">y &#x3D; a;  &#x2F;&#x2F;线程B</span><br></pre></td></tr></table></figure></div><p>这里线程 A 和线程 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，<code>volatile</code>变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取<code>volatile</code>类型的变量时总会返回最新写入的值。</p><h4 id="保证原子性"><a href="#保证原子性" class="headerlink" title="保证原子性"></a>保证原子性</h4><p>volatile关键字所保证的原子性是单次读写的原子性。<code>i++</code>是可以分为读写读三个步骤，<code>volatile</code>不能保证<code>i++</code>是原子操作，要保证<code>i++</code>是原子操作，可以使用原子类或者<code>Synchronized</code>。</p><p>同时，因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</p><h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h3><h4 id="可见性实现"><a href="#可见性实现" class="headerlink" title="可见性实现"></a>可见性实现</h4><blockquote><p>volatile变量的内存可见性是基于内存屏障（Memory Barrier）实现的</p></blockquote><p>内存屏障是一个CPU指令。<br>在程序运行时，为了提高性能，编译器和处理器会对指令进行重排序，JMM为了保证在不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。</p><p>如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sh</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  0x0000000002951563: and    <span class="variable">$0xffffffffffffff87</span>,%rdi</span><br><span class="line">  0x0000000002951567: je     0x00000000029515f8</span><br><span class="line">  0x000000000295156d: <span class="built_in">test</span>   <span class="variable">$0x7</span>,%rdi</span><br><span class="line">  0x0000000002951574: jne    0x00000000029515bd</span><br><span class="line">  0x0000000002951576: <span class="built_in">test</span>   <span class="variable">$0x300</span>,%rdi</span><br><span class="line">  0x000000000295157d: jne    0x000000000295159c</span><br><span class="line">  0x000000000295157f: and    <span class="variable">$0x37f</span>,%rax</span><br><span class="line">  0x0000000002951586: mov    %rax,%rdi</span><br><span class="line">  0x0000000002951589: or     %r15,%rdi</span><br><span class="line">  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br><span class="line">  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  </span><br><span class="line">  0x0000000002951591: jne    0x0000000002951a15</span><br><span class="line">  0x0000000002951597: jmpq   0x00000000029515f8</span><br><span class="line">  0x000000000295159c: mov    0x8(%rdx),%edi</span><br><span class="line">  0x000000000295159f: shl    <span class="variable">$0x3</span>,%rdi</span><br><span class="line">  0x00000000029515a3: mov    0xa8(%rdi),%rdi</span><br><span class="line">  0x00000000029515aa: or     %r15,%rdi</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p><p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>volatile 的 happens-before 关系</strong></p><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><p><strong>volatile 禁止重排序</strong></p><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM 会针对编译器制定 volatile 重排序规则表。</p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/111e02e0/java-thread-x-key-volatile-2.png" class="lazyload"></a></p><p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><p><a href="/posts/111e02e0/mb.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/111e02e0/mb.png" class="lazyload"></a></p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-3.png" data-fancybox="group" data-caption="volitale" class="fancybox"><img alt="volitale" style="zoom:67%;" data-src="/posts/111e02e0/java-thread-x-key-volatile-3.png" class="lazyload" title="volitale"></a></p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-4.png" data-fancybox="group" data-caption="volitale" class="fancybox"><img alt="volitale" style="zoom:67%;" data-src="/posts/111e02e0/java-thread-x-key-volatile-4.png" class="lazyload" title="volitale"></a></p><h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h3><ul><li>对变量的写操作不依赖于当前值。<ul><li>例如i++操作依赖于i本身</li></ul></li><li>该变量没有包含在具有其他变量的不变式中。<ul><li>由于不能保证原子性，vilatile变量不能保证不变式的成立。</li></ul></li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;h3 id=&quot;写在前边，概要总结&quot;&gt;&lt;a href=&quot;#写在前边，概要总结&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://jwkang99.github.io/posts/111e02e0.html"/>
    <id>https://jwkang99.github.io/posts/111e02e0.html</id>
    <published>2020-07-22T03:20:15.000Z</published>
    <updated>2020-07-22T13:41:40.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><h4 id="防止指令重排"><a href="#防止指令重排" class="headerlink" title="防止指令重排"></a>防止指令重排</h4><p>在并发环境下，单例模式的实现方式最多的是使用Double Check的方式，代码如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile保证instance可见性，禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton_6 instance;</span><br><span class="line">    <span class="comment">//私有构造函数，禁止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//doube check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton_6<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton_6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在上述代码中，new Singleton_6()实例的构造对象可以分为三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ul><p>但是由于操作系统为了提高性能可以对指令进行重排序，所以这三个步骤的顺序可能会被打乱。</p><ul><li>分配内存空间</li><li>将内存空间的地址赋值给对应的引用</li><li>初始化对象</li></ul><p>如果是上述的流程，在多线程环境下，就有可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p><h4 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h4><p>可见性问题主要是指一个线程修改了共享变量值，但还没有写回到内存中，其他线程却看不到这个变化。如下图所示：</p><p><a href="/posts/111e02e0/volitale.png" data-fancybox="group" data-caption="image-20200301213039998" class="fancybox"><img alt="image-20200301213039998" data-src="/posts/111e02e0/volitale.png" class="lazyload" title="image-20200301213039998"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 0;  &#x2F;&#x2F;初始状态a &#x3D; b &#x3D; 0，结果允许x &#x3D; y &#x3D; 0出现</span><br><span class="line">b &#x3D; 0;</span><br><span class="line">a &#x3D; 1;  &#x2F;&#x2F;线程A</span><br><span class="line">x &#x3D; b;  &#x2F;&#x2F;线程A</span><br><span class="line">b &#x3D; 2;  &#x2F;&#x2F;线程B</span><br><span class="line">y &#x3D; a;  &#x2F;&#x2F;线程B</span><br></pre></td></tr></table></figure></div><p>这里线程 A 和线程 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，<code>volatile</code>变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取<code>volatile</code>类型的变量时总会返回最新写入的值。</p><h4 id="保证原子性"><a href="#保证原子性" class="headerlink" title="保证原子性"></a>保证原子性</h4><p>volatile关键字所保证的原子性是单次读写的原子性。<code>i++</code>是可以分为读写读三个步骤，<code>volatile</code>不能保证<code>i++</code>是原子操作，要保证<code>i++</code>是原子操作，可以使用原子类或者<code>Synchronized</code>。</p><p>同时，因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</p><h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h3><h4 id="可见性实现"><a href="#可见性实现" class="headerlink" title="可见性实现"></a>可见性实现</h4><blockquote><p>volatile变量的内存可见性是基于内存屏障（Memory Barrier）实现的</p></blockquote><p>内存屏障是一个CPU指令。<br>在程序运行时，为了提高性能，编译器和处理器会对指令进行重排序，JMM为了保证在不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和CPU：不管什么指令都不能和这题奥Memory Barrier指令重排序。</p><p>如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sh</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  0x0000000002951563: and    <span class="variable">$0xffffffffffffff87</span>,%rdi</span><br><span class="line">  0x0000000002951567: je     0x00000000029515f8</span><br><span class="line">  0x000000000295156d: <span class="built_in">test</span>   <span class="variable">$0x7</span>,%rdi</span><br><span class="line">  0x0000000002951574: jne    0x00000000029515bd</span><br><span class="line">  0x0000000002951576: <span class="built_in">test</span>   <span class="variable">$0x300</span>,%rdi</span><br><span class="line">  0x000000000295157d: jne    0x000000000295159c</span><br><span class="line">  0x000000000295157f: and    <span class="variable">$0x37f</span>,%rax</span><br><span class="line">  0x0000000002951586: mov    %rax,%rdi</span><br><span class="line">  0x0000000002951589: or     %r15,%rdi</span><br><span class="line">  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br><span class="line">  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  </span><br><span class="line">  0x0000000002951591: jne    0x0000000002951a15</span><br><span class="line">  0x0000000002951597: jmpq   0x00000000029515f8</span><br><span class="line">  0x000000000295159c: mov    0x8(%rdx),%edi</span><br><span class="line">  0x000000000295159f: shl    <span class="variable">$0x3</span>,%rdi</span><br><span class="line">  0x00000000029515a3: mov    0xa8(%rdi),%rdi</span><br><span class="line">  0x00000000029515aa: or     %r15,%rdi</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p><p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>volatile 的 happens-before 关系</strong></p><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><p><strong>volatile 禁止重排序</strong></p><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM 会针对编译器制定 volatile 重排序规则表。</p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="/posts/111e02e0/java-thread-x-key-volatile-2.png" class="lazyload"></a></p><p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><p><a href="/posts/111e02e0/mb.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:50%;" data-src="/posts/111e02e0/mb.png" class="lazyload"></a></p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-3.png" data-fancybox="group" data-caption="volitale" class="fancybox"><img alt="volitale" style="zoom:67%;" data-src="/posts/111e02e0/java-thread-x-key-volatile-3.png" class="lazyload" title="volitale"></a></p><p><a href="/posts/111e02e0/java-thread-x-key-volatile-4.png" data-fancybox="group" data-caption="volitale" class="fancybox"><img alt="volitale" style="zoom:67%;" data-src="/posts/111e02e0/java-thread-x-key-volatile-4.png" class="lazyload" title="volitale"></a></p><h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h3><ul><li>对变量的写操作不依赖于当前值。<ul><li>例如i++操作依赖于i本身</li></ul></li><li>该变量没有包含在具有其他变量的不变式中。<ul><li>由于不能保证原子性，vilatile变量不能保证不变式的成立。</li></ul></li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><p>参考<a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html" target="_blank" rel="noopener">pdai博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;h3 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="java" scheme="https://jwkang99.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jwkang99.github.io/tags/java/"/>
    
  </entry>
  
</feed>
