<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>剑指offer算法答案(java) | 解忧杂货铺</title><meta name="description" content="剑指offer算法答案(java)"><meta name="keywords" content="算法,leetcode,剑指offer"><meta name="author" content="康宁"><meta name="copyright" content="康宁"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/008-typing.png"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="剑指offer算法答案(java)"><meta name="twitter:description" content="剑指offer算法答案(java)"><meta name="twitter:image" content="https://jwkang99.github.io/img/剑指offer.jpg"><meta property="og:type" content="article"><meta property="og:title" content="剑指offer算法答案(java)"><meta property="og:url" content="https://jwkang99.github.io/posts/30d88c90"><meta property="og:site_name" content="解忧杂货铺"><meta property="og:description" content="剑指offer算法答案(java)"><meta property="og:image" content="https://jwkang99.github.io/img/剑指offer.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://jwkang99.github.io/posts/30d88c90"><link rel="prev" title="java实现读写锁" href="https://jwkang99.github.io/posts/12c3d10b.html"><link rel="next" title="设计模式简单实现(结构型)" href="https://jwkang99.github.io/posts/41c70678.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="解忧杂货铺" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">解忧杂货铺</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4二维数组的查找"><span class="toc_mobile_items-text">4二维数组的查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-字符串：替换空格"><span class="toc_mobile_items-text">5.字符串：替换空格</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-链表：从尾到头打印链表"><span class="toc_mobile_items-text">6.链表：从尾到头打印链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-二叉树：重建二叉树"><span class="toc_mobile_items-text">7.二叉树：重建二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-二叉树：二叉树的下一节点"><span class="toc_mobile_items-text">8.二叉树：二叉树的下一节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-栈与队列：用两个栈实现队列"><span class="toc_mobile_items-text">9.栈与队列：用两个栈实现队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#10-斐波那契数列-青蛙跳台阶问题"><span class="toc_mobile_items-text">10.斐波那契数列(青蛙跳台阶问题)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#10-1-变态青蛙跳台阶问题"><span class="toc_mobile_items-text">10.1 变态青蛙跳台阶问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#10-2-矩阵覆盖"><span class="toc_mobile_items-text">10.2 矩阵覆盖</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#11-递归与循环：旋转数组的最小数字"><span class="toc_mobile_items-text">11.递归与循环：旋转数组的最小数字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#12-矩阵中的路径"><span class="toc_mobile_items-text">12.矩阵中的路径</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-机器人的运动范围"><span class="toc_mobile_items-text">13.机器人的运动范围</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#14-剪绳子"><span class="toc_mobile_items-text">14.剪绳子</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#15-二进制中1的个数"><span class="toc_mobile_items-text">15. 二进制中1的个数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-数值的整数次方"><span class="toc_mobile_items-text">16.数值的整数次方</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#17-打印从1到最大的n位数"><span class="toc_mobile_items-text">17.打印从1到最大的n位数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#27-二叉树的镜像"><span class="toc_mobile_items-text">27.二叉树的镜像</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#28-对称的二叉树"><span class="toc_mobile_items-text">28.对称的二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#29-顺时针打印矩阵"><span class="toc_mobile_items-text">29.顺时针打印矩阵</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#30-包含min函数的栈"><span class="toc_mobile_items-text">30.包含min函数的栈</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#31-栈的压入、弹出序列"><span class="toc_mobile_items-text">31.栈的压入、弹出序列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#32-打印二叉树"><span class="toc_mobile_items-text">32 打印二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#32-I-从上到下打印二叉树"><span class="toc_mobile_items-text">32-I 从上到下打印二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#32-II-从上到下打印二叉树II"><span class="toc_mobile_items-text">32-II 从上到下打印二叉树II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#32-III-从上到下打印二叉树III"><span class="toc_mobile_items-text">32-III 从上到下打印二叉树III</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#33-二叉搜索树的后序遍历序列"><span class="toc_mobile_items-text">33.二叉搜索树的后序遍历序列</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#34-二叉树中和为某一值的路径"><span class="toc_mobile_items-text">34.二叉树中和为某一值的路径</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#35-复杂链表的复制"><span class="toc_mobile_items-text">35.复杂链表的复制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#36-二叉搜索树与双向链表"><span class="toc_mobile_items-text">36.二叉搜索树与双向链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#37-序列化二叉树"><span class="toc_mobile_items-text">37.序列化二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#38-字符串的排列"><span class="toc_mobile_items-text">38.字符串的排列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#39-数组中出现次数超过一半的数字"><span class="toc_mobile_items-text">39.数组中出现次数超过一半的数字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#40-最小的k个数"><span class="toc_mobile_items-text">40.最小的k个数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#41-数据流中的中位数"><span class="toc_mobile_items-text">41.数据流中的中位数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#42-连续子数组的最大和"><span class="toc_mobile_items-text">42.连续子数组的最大和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#43-1～n整数中1出现的次数"><span class="toc_mobile_items-text">43.1～n整数中1出现的次数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#44-数字序列中某一位的数字"><span class="toc_mobile_items-text">44.数字序列中某一位的数字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#45-把数组排成最小的数"><span class="toc_mobile_items-text">45.把数组排成最小的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#46-把数字翻译成字符串"><span class="toc_mobile_items-text">46.把数字翻译成字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#47-礼物的最大价值"><span class="toc_mobile_items-text">47.礼物的最大价值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#48-最长不含重复字符的子字符串"><span class="toc_mobile_items-text">48.最长不含重复字符的子字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#49-丑数"><span class="toc_mobile_items-text">49.丑数</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#4二维数组的查找"><span class="toc-text">4二维数组的查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-字符串：替换空格"><span class="toc-text">5.字符串：替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-链表：从尾到头打印链表"><span class="toc-text">6.链表：从尾到头打印链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-二叉树：重建二叉树"><span class="toc-text">7.二叉树：重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-二叉树：二叉树的下一节点"><span class="toc-text">8.二叉树：二叉树的下一节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-栈与队列：用两个栈实现队列"><span class="toc-text">9.栈与队列：用两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-斐波那契数列-青蛙跳台阶问题"><span class="toc-text">10.斐波那契数列(青蛙跳台阶问题)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-变态青蛙跳台阶问题"><span class="toc-text">10.1 变态青蛙跳台阶问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-矩阵覆盖"><span class="toc-text">10.2 矩阵覆盖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-递归与循环：旋转数组的最小数字"><span class="toc-text">11.递归与循环：旋转数组的最小数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-矩阵中的路径"><span class="toc-text">12.矩阵中的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-机器人的运动范围"><span class="toc-text">13.机器人的运动范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-剪绳子"><span class="toc-text">14.剪绳子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-二进制中1的个数"><span class="toc-text">15. 二进制中1的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-数值的整数次方"><span class="toc-text">16.数值的整数次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-打印从1到最大的n位数"><span class="toc-text">17.打印从1到最大的n位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-二叉树的镜像"><span class="toc-text">27.二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-对称的二叉树"><span class="toc-text">28.对称的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-顺时针打印矩阵"><span class="toc-text">29.顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-包含min函数的栈"><span class="toc-text">30.包含min函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-栈的压入、弹出序列"><span class="toc-text">31.栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-打印二叉树"><span class="toc-text">32 打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-I-从上到下打印二叉树"><span class="toc-text">32-I 从上到下打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-II-从上到下打印二叉树II"><span class="toc-text">32-II 从上到下打印二叉树II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-III-从上到下打印二叉树III"><span class="toc-text">32-III 从上到下打印二叉树III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-二叉搜索树的后序遍历序列"><span class="toc-text">33.二叉搜索树的后序遍历序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-二叉树中和为某一值的路径"><span class="toc-text">34.二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-复杂链表的复制"><span class="toc-text">35.复杂链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-二叉搜索树与双向链表"><span class="toc-text">36.二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-序列化二叉树"><span class="toc-text">37.序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-字符串的排列"><span class="toc-text">38.字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-数组中出现次数超过一半的数字"><span class="toc-text">39.数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-最小的k个数"><span class="toc-text">40.最小的k个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-数据流中的中位数"><span class="toc-text">41.数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-连续子数组的最大和"><span class="toc-text">42.连续子数组的最大和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-1～n整数中1出现的次数"><span class="toc-text">43.1～n整数中1出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-数字序列中某一位的数字"><span class="toc-text">44.数字序列中某一位的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-把数组排成最小的数"><span class="toc-text">45.把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-把数字翻译成字符串"><span class="toc-text">46.把数字翻译成字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-礼物的最大价值"><span class="toc-text">47.礼物的最大价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-最长不含重复字符的子字符串"><span class="toc-text">48.最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-丑数"><span class="toc-text">49.丑数</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(../img/剑指offer.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">剑指offer算法答案(java)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-11-28<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-28</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/%E7%AE%97%E6%B3%95/">算法</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>leetcode全部Accept的</p>
<h2 id="4二维数组的查找"><a href="#4二维数组的查找" class="headerlink" title="4二维数组的查找"></a>4二维数组的查找</h2><p>题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">二维数组中的查找</a></p>
<blockquote>
<p>示例：<br>1  2   8  9<br>2  4   9  12<br>4  7 10 13<br>6  8  11  15<br>查找整数7返回true，查找数字5返回false</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	暴力解时间复杂度O(mn)</span></span><br><span class="line"><span class="comment"> *	由于该数组从左上角到右下角递增</span></span><br><span class="line"><span class="comment"> *	从左上角或者右下角开始查询，每次都可以排除一列或这一行</span></span><br><span class="line"><span class="comment"> *	时间复杂度为O(m+n)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;matrix.length &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="5-字符串：替换空格"><a href="#5-字符串：替换空格" class="headerlink" title="5.字符串：替换空格"></a>5.字符串：替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></p>
<blockquote>
<p>示例：</p>
<p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在原字符串上操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">while</span>((index = str.indexOf(<span class="string">" "</span>))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        str.deleteCharAt(index);</span><br><span class="line">        str.insert(index,<span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *另开一个辅助的StringBuilder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                res.append(<span class="string">"%20"</span>);</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在原数组上操作，遇到空格后逐一插入%20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace1</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">            spaceNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lengthOld = str.length();</span><br><span class="line">    <span class="keyword">int</span> lengthNew = lengthOld + spaceNum*<span class="number">2</span>;</span><br><span class="line">    str.setLength(lengthNew);</span><br><span class="line">    <span class="keyword">int</span> indexOld = lengthOld-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexNew = lengthNew-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(indexNew!=indexOld&amp;&amp;indexNew&gt;=<span class="number">0</span>&amp;&amp;indexOld&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(indexOld)==<span class="string">' '</span>)&#123;</span><br><span class="line">            str.setCharAt(indexNew--,<span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(indexNew--,<span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(indexNew--,<span class="string">'%'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str.setCharAt(indexNew--, str.charAt(indexOld));</span><br><span class="line">        &#125;</span><br><span class="line">        indexOld--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="6-链表：从尾到头打印链表"><a href="#6-链表：从尾到头打印链表" class="headerlink" title="6.链表：从尾到头打印链表"></a>6.链表：从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></p>
<blockquote>
<p>示例：</p>
<p>输入：head = [1,3,2]<br>输出：[2,3,1]</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先想到用栈来实现，时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)</span><br><span class="line">        res[i] = stack.removeLast();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其次，也可以用递归，和栈的时间复杂都一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//中间辅助数组res，将链表的逆序值暂存</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    printListFromTailToHead(head, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 res中的值转到题目要求的int[]</span></span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">int</span>[] resArray = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        resArray[i] = res.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode node, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有后继结点，就一直递归下去</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        printListFromTailToHead(node.next, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把当前结点的值添加到结果列表中</span></span><br><span class="line">    res.add(node.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  以上两种都在不改变原链表的情况下使用辅助空间完成</span></span><br><span class="line"><span class="comment"> *  若可以更改原链表，直接反转原链表则不需要额外的空间</span></span><br><span class="line"><span class="comment"> *  即空间复杂度为O(1)，时间复杂度为O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="comment">//反转之后的头节点</span></span><br><span class="line">    ListNode headRev;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        headRev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    headRev = pre;</span><br><span class="line"> 	<span class="comment">//遍历反转之后的链表</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[count-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count&amp;&amp;headRev!=<span class="keyword">null</span>;i++)&#123;</span><br><span class="line">        res[i] = headRev.val;</span><br><span class="line">        headRev = headRev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="7-二叉树：重建二叉树"><a href="#7-二叉树：重建二叉树" class="headerlink" title="7.二叉树：重建二叉树"></a>7.二叉树：重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都<strong>不含重复</strong>的数字。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></p>
<blockquote>
<p>示例：</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p>
<p>返回根节点。</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前序遍历和中序遍历结果构建二叉树，返回根节点</span></span><br><span class="line"><span class="comment"> * 递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length==<span class="number">0</span> || inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildHelper(preorder,inorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildHelper</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre, <span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span></span>&#123;</span><br><span class="line">    <span class="comment">//以前序遍历集合的第一个节点为当前子树的根节点</span></span><br><span class="line">    TreeNode cur = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">    <span class="comment">//初始化当前子树的根节点</span></span><br><span class="line">    cur.left = <span class="keyword">null</span>;</span><br><span class="line">    cur.right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果某一子树的中序遍历和前序遍历数组中只剩一个节点</span></span><br><span class="line">    <span class="comment">//那么这个唯一的节点就是该子树的根节点，并返回当前子树</span></span><br><span class="line">    <span class="keyword">if</span>(endIn==startIn &amp;&amp; endPre==startPre)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> si = startIn;</span><br><span class="line">    <span class="comment">//找出cur在当前子树中序遍历数组中的位置</span></span><br><span class="line">    <span class="keyword">while</span>(si &lt;= endIn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[si] == pre[startPre])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算出以cur为根节点的左子树的节点个数</span></span><br><span class="line">    <span class="comment">//分别截出该子树的中序遍历和前序遍历数组</span></span><br><span class="line">    <span class="keyword">int</span> leftLen = si - startIn;</span><br><span class="line">    <span class="keyword">if</span>(leftLen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cur.left = buildHelper(pre,in,startPre+<span class="number">1</span>,startPre+leftLen,startIn,si-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子树节点个数</span></span><br><span class="line">    <span class="keyword">int</span> rightLen = endIn - si;</span><br><span class="line">    <span class="keyword">if</span>(rightLen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cur.right = buildHelper(pre,in,startPre+<span class="number">1</span>+leftLen,endPre,si+<span class="number">1</span>,endIn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="8-二叉树：二叉树的下一节点"><a href="#8-二叉树：二叉树的下一节点" class="headerlink" title="8.二叉树：二叉树的下一节点"></a>8.二叉树：二叉树的下一节点</h2><p>找出二叉树中序遍历的后续结点，有父指针</p>
<p>根据中序遍历的特点，某一结点中序遍历的后续节点只有以下几种可能<br>(1)当该节点为有右孩子时<br>中序遍历后续节点为 该节点右孩子的最左子孙节点<br>(2)当该节点没有右孩子且又是其父节点的左孩子时<br>中序遍历后续节点为 该节点的父节点<br>(3)当该节点没有右孩子且又是其父节点的右孩子时<br>找到该节点的最近祖宗节点（该祖宗节点是某一几点的左孩子），若向上遍历到的根节点，则该节点没有中序遍历后续节点。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">getNext</span><span class="params">(TreeNode pNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode pNext = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode pRight = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(pRight.left != <span class="keyword">null</span>)&#123;  <span class="comment">//寻找右孩子最左下的子孙节点</span></span><br><span class="line">            pRight = pRight.left;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode.parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode pParent = pNode.parent;</span><br><span class="line">        TreeNode pCurrent = pNode;</span><br><span class="line">        <span class="comment">//跳出循环的条件，要么找到一个最近的为左孩子的祖宗节点</span></span><br><span class="line">        <span class="comment">//或者遍历到根节点，把根节点的父节点即null赋值给pNext</span></span><br><span class="line">        <span class="keyword">while</span>(pParent != <span class="keyword">null</span> &amp;&amp; pCurrent == pParent.right)&#123;<span class="comment">//当该节点是其父节点的右孩子时进入循环</span></span><br><span class="line">            pCurrent = pParent;             </span><br><span class="line">            pParent = pParent.parent;         </span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="9-栈与队列：用两个栈实现队列"><a href="#9-栈与队列：用两个栈实现队列" class="headerlink" title="9.栈与队列：用两个栈实现队列"></a>9.栈与队列：用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1）</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="10-斐波那契数列-青蛙跳台阶问题"><a href="#10-斐波那契数列-青蛙跳台阶问题" class="headerlink" title="10.斐波那契数列(青蛙跳台阶问题)"></a>10.斐波那契数列(青蛙跳台阶问题)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *递归计算数列,有很多冗余计算,导致效率很低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *通过循环计算数列,可以减少冗余计算</span></span><br><span class="line"><span class="comment"> *将之前计算过的存储下来，从而提高计算效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        temp = first + second;</span><br><span class="line">        first = second;</span><br><span class="line">        second = temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="10-1-变态青蛙跳台阶问题"><a href="#10-1-变态青蛙跳台阶问题" class="headerlink" title="10.1 变态青蛙跳台阶问题"></a>10.1 变态青蛙跳台阶问题</h3><p>青蛙一次可以跳1级，2级·····n级，跳上n级台阶有多少种跳法？</p>
<blockquote>
<p>分析：f(1) = 1，f(2) = 2<br>n=3时，可以每次都跳1级，或者一次2级一次1级，或者直接跳3级，f(3) = 4<br>f(3) = f(1)+f(2)+1，后边的+1为直接跳到3级。<br>故可总结f(n) = f(n-1)+f(n-2)+···+f(1)+1，由数学归纳法可得f(n) = 2^{n-1}</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=target-<span class="number">1</span>)&#123;</span><br><span class="line">        result *= <span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="10-2-矩阵覆盖"><a href="#10-2-矩阵覆盖" class="headerlink" title="10.2 矩阵覆盖"></a>10.2 矩阵覆盖</h3><p>题目描述：可以用$2×1$的小矩形横着或者竖着去覆盖更大的矩形。请问用8个小矩形无重叠的覆盖一个$2×8$的大矩形共有多少种方法？</p>
<blockquote>
<p>仍为斐波那契数列问题，与上边代码一样。</p>
<p>可以记用小矩形覆盖$2×n$的大矩形共有$f(n)$中方法，则<br>$f(1)=1$，$f(2)=2$，$f(3)=3$，$f(4)=5$<br>$f(n)=f(n-1)+f(n-2)$</p>
<h2 id="11-递归与循环：旋转数组的最小数字"><a href="#11-递归与循环：旋转数组的最小数字" class="headerlink" title="11.递归与循环：旋转数组的最小数字"></a>11.递归与循环：旋转数组的最小数字</h2></blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *递归分治,只有在无重复元素时才可用递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMinNumber(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinNumber</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[start]&lt;array[end] || start==end)&#123;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(findMinNumber(array,start,mid), findMinNumber(array,mid+<span class="number">1</span>,end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *非递归二分法,有重复元素，在left,mid,right三处的值相等时，就需遍历判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> midIndex = leftIndex;</span><br><span class="line">    <span class="keyword">while</span>(array[leftIndex]&gt;=array[rightIndex])&#123;</span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">1</span>)&#123;</span><br><span class="line">            midIndex = rightIndex;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        midIndex = (leftIndex+rightIndex)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[midIndex] == array[leftIndex]</span><br><span class="line">                &amp;&amp; array[midIndex] == array[rightIndex])&#123;</span><br><span class="line">            <span class="keyword">return</span> findMinInArr(array,leftIndex,rightIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(array[midIndex]&gt;=array[leftIndex])&#123;</span><br><span class="line">            leftIndex = midIndex;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[midIndex]&lt;=array[rightIndex])&#123;</span><br><span class="line">            rightIndex = midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[midIndex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinInArr</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = array[leftIndex];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=leftIndex+<span class="number">1</span>;i&lt;rightIndex;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[leftIndex]&lt;min)&#123;</span><br><span class="line">            min = array[leftIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径<strong>不能再次</strong>进入该格子。</p>
<p>该题leecode地址：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></p>
<blockquote>
<p>示例：<br>输入：board = [[“A”,”B”,”C”,”E”],<br>                           [“S”,”F”,”C”,”S”],<br>                           [“A”,”D”,”E”,”E”]] </p>
<p>​            word = “ABCCED”<br>输出：true</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  可用DFS和BFS对矩阵进行搜索。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="comment">//标记当前位置是否访问已经在目标字符串中用过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> [][] visited;</span><br><span class="line">    <span class="comment">//四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x&gt;=<span class="number">0</span>)&amp;&amp;(x&lt;m)&amp;&amp;(y&gt;=<span class="number">0</span>)&amp;&amp;(y&lt;n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length==<span class="number">0</span> || board[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.m = board.length;</span><br><span class="line">        <span class="keyword">this</span>.n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">//如果当前字符未在目标字符串中用过</span></span><br><span class="line">                <span class="comment">//且从当前位置出发可找到对应匹配，则返回true</span></span><br><span class="line">                <span class="keyword">if</span>(!visited[i][j]&amp;&amp;dfsHelper(i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dfs搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y (x,y)表示当前匹配的矩阵中的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start  目标字符串的当前匹配位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果匹配到最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(start == word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> board[x][y] == word.charAt(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果目标字符串的当前位置与字符矩阵中当前字符相同</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == word.charAt(start))&#123;</span><br><span class="line">            visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//则分四个方向匹配目标字符串的下一位置字符</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//找到一个方向存在即返回</span></span><br><span class="line">                <span class="keyword">if</span>(inArea(newX,newY) &amp;&amp; !visited[newX][newY])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfsHelper(newX,newY,start+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前方向不存在，则把未与目标字符串成功匹配的字符重置为false</span></span><br><span class="line">            <span class="comment">//表示未使用</span></span><br><span class="line">            visited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h2><p>题目描述：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>该题的leetcode地址：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">机器人的运动范围</a></p>
<blockquote>
<p>示例：</p>
<p>输入：m = 2, n = 3, k = 1<br>输出：3</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  与上体相似也可以采用dfs或bfs进行搜索</span></span><br><span class="line"><span class="comment"> *  对每个位置进行判断</span></span><br><span class="line"><span class="comment"> *  时间复杂度O(mn)，需要遍历每个位置</span></span><br><span class="line"><span class="comment"> *  空间复杂度O(mn)，标记位置的二位数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> direction[][] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=m || y&lt;<span class="number">0</span> || y&gt;=n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []sumXY = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> [] XY = &#123;x,y&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(XY[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                sumXY[i] += (XY[i]%<span class="number">10</span>);</span><br><span class="line">                XY[i] /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumXY[<span class="number">0</span>]+sumXY[<span class="number">1</span>] &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span> || n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        dfsHelper(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inArea(x,y) &amp;&amp; !visited[x][y])&#123;</span><br><span class="line">            visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">            dfsHelper(x+<span class="number">1</span>,y);</span><br><span class="line">            dfsHelper(x-<span class="number">1</span>,y);</span><br><span class="line">            dfsHelper(x,y+<span class="number">1</span>);</span><br><span class="line">            dfsHelper(x,y-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14.剪绳子"></a>14.剪绳子</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剪绳子</a></p>
<blockquote>
<p>示例：<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *动态规划和贪心两种方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i],dp[i-j]*j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心，优先分出最多的3，次之分2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> reminder = n%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(reminder==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,n/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(reminder==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,n/<span class="number">3</span>-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(reminder==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,n/<span class="number">3</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h2><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></p>
<blockquote>
<p>示例：<br>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.逐位判断，时间复杂度O(logn)，空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * 这种解法可能会在n是负数时造成死循环</span></span><br><span class="line"><span class="comment"> * 因为n是负数最高位是1，右移一位高位补1</span></span><br><span class="line"><span class="comment"> * 可以选择设置flag=1，将flag逐位左移与n进行与操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        res += n &amp; <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2.分析利用n&amp;(n-1)，时间复杂度O(1的个数)，空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * 	     n: 1 1 1 0 1 0</span></span><br><span class="line"><span class="comment"> * 	   n-1: 1 1 1 0 0 1</span></span><br><span class="line"><span class="comment"> * n&amp;(n-1): 1 1 1 0 0 0</span></span><br><span class="line"><span class="comment"> * 每次操作都会删除n中最左端的1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        n =( n &amp; (n-<span class="number">1</span>));</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方，不得使用库函数。</p>
<p>该题的leetcode地址：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></p>
<blockquote>
<p>示例：<br>输入: 2.00000, 10<br>输出: 1024.00000</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：需要考虑底数和指数的所有情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> N = n;</span><br><span class="line">     <span class="keyword">if</span>(N &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="comment">//指数为负数</span></span><br><span class="line">         <span class="keyword">if</span>(x==<span class="number">0.0</span>)&#123;</span><br><span class="line">             <span class="comment">//可自定义底数为0结果为0</span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>/myPowHelper(x,-N);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> myPowHelper(x,N);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPowHelper</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0.0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1.0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果指数为奇数</span></span><br><span class="line">    <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//将结果分为三部分</span></span><br><span class="line">        <span class="keyword">double</span> res = myPowHelper(x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res*res*x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//指数为偶数，将结果分为两部分</span></span><br><span class="line">        <span class="keyword">double</span> res = myPowHelper(x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<blockquote>
<p>示例：<br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个答案可以在leetcode上通过，</span></span><br><span class="line"><span class="comment"> * 但是剑指offer上这道题的本意并不是这种解法</span></span><br><span class="line"><span class="comment"> * 而是考虑大数问题，用字符串进行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        number = number *<span class="number">10</span> +<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[number];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">        res[i] = i+<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。即所有子树的左右孩子节点交换位置。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">二叉树的镜像</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归交换左右子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    mirrorHelper(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mirrorHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span> || (root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    mirrorHelper(root.left);</span><br><span class="line">    mirrorHelper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。对称二叉树：所有子树的左右孩子结点的值都一样</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">对称的二叉树</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树中任意两个对称的节点L和R都满足</span></span><br><span class="line"><span class="comment"> * L.val == R.val</span></span><br><span class="line"><span class="comment"> * L.left.val == R.right.val</span></span><br><span class="line"><span class="comment"> * L.right.val == R.left.val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symmetricHelper(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">symmetricHelper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span> || left.val!=right.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symmetricHelper(left.left,right.right) &amp;&amp; symmetricHelper(left.right,right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>该题的leetcode地址：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></p>
<blockquote>
<p>示例：<br>输入：matrix = [[1,2,3],<br>                             [4,5,6],<br>                             [7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
</blockquote>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置上下左右四个边界，逐渐向内缩小边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length,n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//四个边界值初始值</span></span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bottom=m-<span class="number">1</span>,right=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=bottom &amp;&amp; left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            res[num++] = matrix[top][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++top &gt; bottom)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=bottom;i++)&#123;</span><br><span class="line">            res[num++] = matrix[i][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--right &lt; left)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)&#123;</span><br><span class="line">            res[num++] = matrix[bottom][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--bottom &lt; top)</span><br><span class="line">            bottom--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=top;i--)&#123;</span><br><span class="line">            res[num++] = matrix[i][left];</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关键在于O(1)实现min方法</span></span><br><span class="line"><span class="comment"> * 1.采用辅助栈依次存入当前的最小值</span></span><br><span class="line"><span class="comment"> * 每次pop都判断是不是pop出了当前最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min.isEmpty()||min.peek()&gt;=x)&#123;</span><br><span class="line">            min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop().equals(min.peek()))&#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.第二种方法借助min和当前数的差值判断是不是最小值</span></span><br><span class="line"><span class="comment">//空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">//该方法有一个缺陷，对于大数会出现溢出情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = x-min;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            min -= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.peek()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek()+min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。该题leetcode地址：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a>。</p>
<blockquote>
<p>示例：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.用一个栈去模拟，能成功模拟出即为true</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)，所有元素出栈入栈一次为2n</span></span><br><span class="line"><span class="comment">//空间复杂度O(n)，辅助栈大小为n</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处的栈可以用数组模拟，用下标存取速度更快</span></span><br><span class="line">    <span class="comment">//int[] stack = new int[pushed.length];</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> m = pushed.length;</span><br><span class="line">    <span class="keyword">int</span> n = popped.length;</span><br><span class="line">    <span class="keyword">if</span>(m!=n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//若两个数组都为空，则直接返回空栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        stack.push(pushed[i]);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; j&lt;n &amp;&amp; stack.peek().equals(popped[j]))&#123;</span><br><span class="line">            j++;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若辅助栈为空，即模拟成功</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.上述可用数组替代栈模拟出入栈过程</span></span><br><span class="line"><span class="comment">//考虑到遍历pushed数组是pushed[i]即为栈顶元素</span></span><br><span class="line"><span class="comment">//若pushed数组可修改，则可直接用pushed数组替代栈</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = pushed.length;</span><br><span class="line">    <span class="keyword">int</span> n = popped.length;</span><br><span class="line">    <span class="keyword">if</span>(m!=n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向栈顶元素的下一个位置</span></span><br><span class="line">    <span class="keyword">int</span> stack_top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        pushed[stack_top++] = pushed[i];</span><br><span class="line">        <span class="comment">//出栈匹配</span></span><br><span class="line">        <span class="keyword">while</span>(stack_top!=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; pushed[stack_top-<span class="number">1</span>]==popped[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">            stack_top--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack_top==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="32-打印二叉树"><a href="#32-打印二叉树" class="headerlink" title="32 打印二叉树"></a>32 打印二叉树</h2><h3 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32-I 从上到下打印二叉树"></a>32-I 从上到下打印二叉树</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">从上到下打印二叉树</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很简单的层次遍历</span></span><br><span class="line"><span class="comment">//广度优先遍历，将节点存在队列中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.addLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.addLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[temp.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)&#123;</span><br><span class="line">        res[i] = temp.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="32-II-从上到下打印二叉树II"><a href="#32-II-从上到下打印二叉树II" class="headerlink" title="32-II 从上到下打印二叉树II"></a>32-II 从上到下打印二叉树II</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">从上到下打印二叉树 II</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关键在于分层</span></span><br><span class="line"><span class="comment"> * 两种办法：</span></span><br><span class="line"><span class="comment"> * 1.用两个队列进行辅助，一个队列存当前层节点，另外一个队列存下一层</span></span><br><span class="line"><span class="comment"> * （1.2 后边发现用一个辅助队列就能实现分层，且不用标记节点）</span></span><br><span class="line"><span class="comment"> * 2.标记每一层的最后一个节点，用于区分是否进入了下一层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.两个辅助队列，时间O(n),空间O(n):2n</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存当前层</span></span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">//存下一层节点</span></span><br><span class="line">    Deque&lt;TreeNode&gt; qNext = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qNext.addLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qNext.addLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前层队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) &#123;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//下一层变为当前层</span></span><br><span class="line">            q.addAll(qNext);</span><br><span class="line">            qNext.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.2.一个辅助队列是实现分层,时间O(n),空间O(n):n</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            TreeNode cur = q.removeFirst();</span><br><span class="line">            temp.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.标记节点，时间O(n),空间O(n)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="comment">//标记当前层最后一个节点</span></span><br><span class="line">    TreeNode curLast = root;</span><br><span class="line">    TreeNode nextLast = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextLast = cur.left;</span><br><span class="line">            q.addLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextLast = cur.right;</span><br><span class="line">            q.addLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == curLast)&#123;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            curLast = nextLast;</span><br><span class="line">            nextLast = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="32-III-从上到下打印二叉树III"><a href="#32-III-从上到下打印二叉树III" class="headerlink" title="32-III 从上到下打印二叉树III"></a>32-III 从上到下打印二叉树III</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>该题leetcode地址：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">从上到下打印二叉树 III</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.记录当前行是偶数行还是奇数行的方法，</span></span><br><span class="line"><span class="comment">//如果需要逆序则在31II的基础上翻转本层数组</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="comment">//判断当前层数组是否需要反转</span></span><br><span class="line">    <span class="keyword">boolean</span> isReverse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            TreeNode cur = q.removeFirst();</span><br><span class="line">            temp.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.addLast(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转当前层数据，需要额外时间</span></span><br><span class="line">        <span class="keyword">if</span>(isReverse)&#123;</span><br><span class="line">            Collections.reverse(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        isReverse = !isReverse;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用双端队列，节点的存入取出做判断</span></span><br><span class="line"><span class="comment">//时间O(n),空间O(n):n一个双端队列</span></span><br><span class="line"><span class="comment">//剑指offer原书上用的是两个栈，思想基本一样</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">boolean</span> isReverse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时的size是当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isReverse)&#123;</span><br><span class="line">                TreeNode cur = q.removeFirst();</span><br><span class="line">                temp.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addLast(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addLast(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode cur = q.removeLast();</span><br><span class="line">                temp.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addFirst(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.addFirst(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isReverse = !isReverse;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路与利用中序和前序遍历构建二叉树的递归基本一样</span></span><br><span class="line"><span class="comment">//划分+递归</span></span><br><span class="line"><span class="comment">//搜索二叉树的后序遍历结果中，最后一个节点为根节点</span></span><br><span class="line"><span class="comment">//前边的节点一定可以在某一位置分为两部分，左边为左子树都比根节点小</span></span><br><span class="line"><span class="comment">//右边为右子树，都比根节点大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postorder==<span class="keyword">null</span> || postorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verifyHelper(postorder,<span class="number">0</span>, postorder.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifyHelper</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=start,j=end-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=end &amp;&amp; postorder[i]&lt;postorder[end])&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=start &amp;&amp; postorder[j]&gt;postorder[end])&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">    <span class="keyword">if</span>(j!=i+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> left = <span class="keyword">true</span>,right = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=start)&#123;</span><br><span class="line">        left = verifyHelper(postorder,start,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;end)&#123;</span><br><span class="line">        right = verifyHelper(postorder,j,end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.二叉树中和为某一值的路径</h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。该题的leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先遍历</span></span><br><span class="line"><span class="comment"> * 最开始我写的stack里存的是TreeNode</span></span><br><span class="line"><span class="comment"> * 后边看了剑指offer书上的代码后发现，存TreeNode多余了</span></span><br><span class="line"><span class="comment"> * 递归栈已经帮我们保存了上一层的父节点，只需将遍历节点的值进行入栈出栈操作即可</span></span><br><span class="line"><span class="comment"> * 自己考虑不当</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        pathSumHelper(root,sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSumHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        stack.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(stack));</span><br><span class="line">        &#125;</span><br><span class="line">        pathSumHelper(root.left,sum);</span><br><span class="line">        pathSumHelper(root.right,sum);</span><br><span class="line">        stack.remove(stack.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。该题的leetcode：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分三步解决</span></span><br><span class="line"><span class="comment"> * 1.复制生成新的节点</span></span><br><span class="line"><span class="comment"> * 2.复制next指针</span></span><br><span class="line"><span class="comment"> * 3.复制random指针</span></span><br><span class="line"><span class="comment"> * 前两步就是与常规的链表复制一致，遍历一遍即可完成</span></span><br><span class="line"><span class="comment"> * 难点在第三步，新链表的random指针指向新复制出来的结点，</span></span><br><span class="line"><span class="comment"> * 而旧链表中random指向的旧节点，故需要将旧节点与新节点对应起来，</span></span><br><span class="line"><span class="comment"> * 原链表中的A.random指向B,则让新链表中的A'.random指向新的B'</span></span><br><span class="line"><span class="comment"> * 所以需要一个能存映射关系的数据结构map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Node cHead = <span class="keyword">new</span> Node(head.val);</span><br><span class="line">    Node cp = cHead;</span><br><span class="line">    map.put(head,cHead);</span><br><span class="line">    Node p = head;</span><br><span class="line">    <span class="keyword">while</span>(p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        Node temp = <span class="keyword">new</span> Node(p.val);</span><br><span class="line">        cp.next = temp;</span><br><span class="line">        cp = cp.next;</span><br><span class="line">        map.put(p,cp);</span><br><span class="line">    &#125;</span><br><span class="line">    cp = cHead;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span>(cp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        cp.random = map.get(p.random);</span><br><span class="line">        cp = cp.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。该题leetcode地址：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历顺序逐一修改指针</span></span><br><span class="line"><span class="comment">//空间O(n),时间O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储中序遍历结果</span></span><br><span class="line">    List&lt;Node&gt; inOrderList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderHelper(root);</span><br><span class="line">        <span class="keyword">int</span> len = inOrderList.size();</span><br><span class="line">        <span class="comment">//按照中序遍历结果逐一修改左右指针</span></span><br><span class="line">        inOrderList.get(<span class="number">0</span>).left = inOrderList.get(len-<span class="number">1</span>);</span><br><span class="line">        inOrderList.get(<span class="number">0</span>).right = inOrderList.get(<span class="number">1</span>%len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = i%len,index_pre=(i-<span class="number">1</span>)%len,index_next=(i+<span class="number">1</span>)%len;</span><br><span class="line">            inOrderList.get(index).right = inOrderList.get(index_next);</span><br><span class="line">            inOrderList.get(index).left = inOrderList.get(index_pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inOrderList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderHelper</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderHelper(root.left);</span><br><span class="line">            inOrderList.add(root);</span><br><span class="line">            inOrderHelper(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改中序遍历，采用递归分治，把过程分解为</span></span><br><span class="line"><span class="comment">//左子树的双向链表+root+右子树的双向链表，其中，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lastNode表示当前链表的最后一个节点</span></span><br><span class="line">    Node lastNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderHelper(root);</span><br><span class="line">        Node head = lastNode;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>&amp;&amp;head.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125;</span><br><span class="line">        head.left = lastNode;</span><br><span class="line">        lastNode.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderHelper</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderHelper(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把root节点的left指针指向已构成链表的最后一个节点</span></span><br><span class="line">        root.left = lastNode;</span><br><span class="line">        <span class="comment">//如果lastNode不为空，修改lastNode的right指针</span></span><br><span class="line">        <span class="keyword">if</span>(lastNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastNode.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="comment">//root和左子树构成链表后，root变成当前链表的最后一个节点</span></span><br><span class="line">        lastNode = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderHelper(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37.序列化二叉树"></a>37.序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。该题leetcode地址：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">序列化二叉树</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 示例：</span><br><span class="line"> 	1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line">序列化形式不唯一，如下为层次序列化</span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="comment">//按层次遍历字符串拼接</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"null,"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(cur.val).append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        q.addLast(cur.left);</span><br><span class="line">        q.addLast(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最后一个逗号 </span></span><br><span class="line">    res.deleteCharAt(res.length()-<span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] tree = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">//仍然依靠队列还原二叉树</span></span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = tree.length;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[<span class="number">0</span>]));</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(tree[i].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode left = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[i]));</span><br><span class="line">            cur.left = left;</span><br><span class="line">            q.addLast(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i+<span class="number">1</span>].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            cur.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode right = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[i+<span class="number">1</span>]));</span><br><span class="line">            cur.right = right;</span><br><span class="line">            q.addLast(right);</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历，采用递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"["</span>);</span><br><span class="line">    serializeHelper(root,res);</span><br><span class="line">    res.deleteCharAt(res.length()-<span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serializeHelper</span><span class="params">(TreeNode root,StringBuilder res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        res.append(<span class="string">"null,"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.append(root.val).append(<span class="string">","</span>);</span><br><span class="line">        serializeHelper(root.left,res);</span><br><span class="line">        serializeHelper(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] tree = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">//采用数组记录下标是想保持递归函数的全局可见性</span></span><br><span class="line">    <span class="keyword">int</span>[] index=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TreeNode root = deserializeHelper(tree,index);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserializeHelper</span><span class="params">(String[] tree,<span class="keyword">int</span>[] index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index[<span class="number">0</span>]].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">        index[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(tree[index[<span class="number">0</span>]]));</span><br><span class="line">        index[<span class="number">0</span>]++;</span><br><span class="line">        <span class="comment">//以下两个递归index[0]不同</span></span><br><span class="line">        root.left = deserializeHelper(tree,index);</span><br><span class="line">        root.right = deserializeHelper(tree,index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38.字符串的排列"></a>38.字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。该题leetcode地址：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入：s = "abc"</span></span><br><span class="line"><span class="comment"> * 输出：["abc","acb","bac","bca","cab","cba"]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//当前算法时间复杂度较高</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//利用set去重</span></span><br><span class="line">    Set&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        permutationHelper(s,<span class="string">""</span>,visited);</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> String[result.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutationHelper</span><span class="params">(String s,String res,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == res.length())&#123;</span><br><span class="line">            result.add(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//表示当前字符已经用过</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//以第i个字符为开头的排列</span></span><br><span class="line">            permutationHelper(s,res+String.valueOf(c),visited);</span><br><span class="line">            <span class="comment">//重置为未使用，下一轮组合使用</span></span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。该题leetcode地址：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener"> 数组中出现次数超过一半的数字</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            majority = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(majority==n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。leetcode地址：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用最大堆实现，也可自己实现最大堆</span></span><br><span class="line"><span class="comment">//解答中还有用快排解决的，数据量大的话并不适用</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line"> 	<span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;=k)&#123;</span><br><span class="line">         <span class="keyword">return</span> arr;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//最大堆</span></span><br><span class="line">     Queue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue(k,Comparator.reverseOrder());</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">         q.offer(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;arr.length)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[i]&lt;q.peek())&#123;</span><br><span class="line">             q.poll();</span><br><span class="line">             q.offer(arr[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Arrays.stream(q.toArray(<span class="keyword">new</span> Integer[k])).mapToInt(Integer::valueOf).toArray();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41.数据流中的中位数"></a>41.数据流中的中位数</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。leetcode地址：<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a>。</p>
<p>例：[2,3,4] 的中位数是 3，[2,3] 的中位数是 (2 + 3) / 2 = 2.5。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用两个堆，分别为最大堆和最小堆</span></span><br><span class="line"><span class="comment">//空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; leftQ;</span><br><span class="line">    Queue&lt;Integer&gt; rightQ;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最小堆</span></span><br><span class="line">        leftQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//最大堆</span></span><br><span class="line">        rightQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2-o1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调整两个堆使得left要么与right的size相同</span></span><br><span class="line">        <span class="comment">//要了left = right+1</span></span><br><span class="line">        <span class="keyword">if</span>(leftQ.size()==rightQ.size())&#123;</span><br><span class="line">            <span class="comment">//O(logn)</span></span><br><span class="line">            rightQ.offer(num);</span><br><span class="line">            leftQ.offer(rightQ.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            leftQ.offer(num);</span><br><span class="line">            rightQ.offer(leftQ.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//O(1)</span></span><br><span class="line">        <span class="keyword">if</span>(leftQ.size()==rightQ.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)leftQ.peek()+rightQ.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftQ.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h2><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        nums[i] += Math.max(nums[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        max = Math.max(nums[i],max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43.1～n整数中1出现的次数"></a>43.1～n整数中1出现的次数</h2><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>分析：</p>
<ul>
<li>n=1234，可以分为1-999和1000-1234两部分，既为f(999)+234+1+f(234)</li>
<li>n=2134，可以分为1-999、1000-1999和2000-2134三部分，即为f(999)+1000+f(999)+f(134)</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1234</span></span><br><span class="line">    <span class="comment">//3124</span></span><br><span class="line">    <span class="comment">//21234</span></span><br><span class="line">    String s = String.valueOf(n);</span><br><span class="line">    <span class="comment">//存储数字的最高位</span></span><br><span class="line">    <span class="keyword">int</span> first = s.charAt(<span class="number">0</span>)-<span class="string">'0'</span>;</span><br><span class="line">    <span class="comment">//存储最高位的单位，万千百</span></span><br><span class="line">    <span class="keyword">int</span> pow = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//存储除了最高位的部分</span></span><br><span class="line">    <span class="keyword">int</span> last = n-first*pow;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span>(first==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> countDigitOne(pow-<span class="number">1</span>)+last+<span class="number">1</span>+countDigitOne(last);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countDigitOne(pow-<span class="number">1</span>)*first+countDigitOne(last)+pow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44.数字序列中某一位的数字"></a>44.数字序列中某一位的数字</h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用int有溢出，不通过，目前没发现哪里溢出了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> digits = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-<span class="number">9</span>*base*digits&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        n -= <span class="number">9</span>*base*digits;</span><br><span class="line">        digits++;</span><br><span class="line">        base = base*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> num = base + (n-<span class="number">1</span>)/digits;</span><br><span class="line">    <span class="keyword">long</span> remainder = n%digits;</span><br><span class="line">    System.out.println(num+<span class="string">" "</span>+remainder);</span><br><span class="line">    <span class="keyword">if</span>(remainder==<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = digits;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(digits);</span><br><span class="line">    <span class="keyword">if</span>(remainder==digits)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num%<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(num).charAt((<span class="keyword">int</span>) (remainder-<span class="number">1</span>))-<span class="string">'0'</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<blockquote>
<p>示例：<br>输入: [10,2]<br>输出: “102”</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串数组排序，时间O(nlogn)，空间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转为字符串数组</span></span><br><span class="line">    String[] temp = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        temp[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对字符串数组按照特定顺序进行排</span></span><br><span class="line">    Arrays.sort(temp, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            String s1 = o1+o2;</span><br><span class="line">            String s2 = o2+o1;</span><br><span class="line">            <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s : temp)&#123;</span><br><span class="line">        res.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。该题leetcode地址：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">把数字翻译成字符串</a>。</p>
<blockquote>
<p>示例：<br>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，转化成字符串效率比较低</span></span><br><span class="line"><span class="comment">//可以从后往前遍历用除法取余,也可以使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = String.valueOf(num).toCharArray();</span><br><span class="line">    <span class="comment">//表示以第i-1个数字结尾的数量</span></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//表示以第i-2个数字结尾的数量</span></span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> twoDigit = (chars[i-<span class="number">1</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+(chars[i]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = cur;</span><br><span class="line">        <span class="comment">//如果i-1位与i位可以构成26以内</span></span><br><span class="line">        <span class="comment">//其中pre记录的是i-2为结尾的数量</span></span><br><span class="line">        <span class="comment">//(i)=(i-1)+co*(i-2)</span></span><br><span class="line">        <span class="keyword">int</span> co = twoDigit&gt;<span class="number">9</span>&amp;&amp;twoDigit&lt;<span class="number">26</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        cur += pre*co;</span><br><span class="line">        pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从后往前，用数字的除法，100%</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>,pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> twoDigit = num%<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = cur;</span><br><span class="line">        <span class="keyword">int</span> co = twoDigit&gt;<span class="number">9</span>&amp;&amp;twoDigit&lt;<span class="number">26</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//(i)=(i-1)+co*(i-2)</span></span><br><span class="line">        cur += pre*co;</span><br><span class="line">        pre = temp;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">9</span>) &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//xyzcba</span></span><br><span class="line">    <span class="keyword">int</span> ba = num%<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (ba&lt;=<span class="number">9</span>||ba&gt;=<span class="number">26</span>) &#123;<span class="keyword">return</span> translateNum(num/<span class="number">10</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> translateNum(num/<span class="number">10</span>)+translateNum(num/<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>简单说，只能向下或者向右，寻找一条从(0,0)到(m,n)的路径使得经过结点的和最大的。leetcode地址：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，从(0,0)到(i,j)的最大路径和为f(i,j)</span></span><br><span class="line"><span class="comment">//只能从(i-1,j)或(i,j-1)得到</span></span><br><span class="line"><span class="comment">//得递推式：f(i,j) = max&#123;f(i-1,j),f(i,j-1)&#125;+grid(i+j)</span></span><br><span class="line"><span class="comment">//可得下列代码，如果用递归会有很多冗余计算，所以用循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></div>
<p>上边的方法存了所有结点的最大路径，但是$(i,j)$处的最大路径和值依赖于$(i-1,j)$和$(i,j-1)$。故$i-1$行以上的部分没必要存储。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//只用于存储i-1行的数据</span></span><br><span class="line">    <span class="keyword">int</span>[]dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[j+<span class="number">1</span>] = Math.max(dp[j+<span class="number">1</span>],dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串"></a>48.最长不含重复字符的子字符串</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>leetcode地址：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a>。</p>
<blockquote>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p>
</blockquote>
<p><strong>注</strong>： 最开始看这道题的时候想错了，做成了子序列，子序列相对简单一点。</p>
<p>分析：同样用动态规划解决。如果第$i$个字符没在之前的字串中出现过，那么以第$i$个字符即为的字串长度为$f(i)=f(i-1)+1$。但是如果在前边的子串中出现过，情况就比较复杂了。需要考虑第$i$个字符上一次在字符串中出现的位置。两次出现的间隔为$d$，如果$d≤f(i-1)$，那么上一次出现的位置在以第$i-1$字符为结尾的子串中，故能保证两次出现位置之间的字符均无重复，即$f(i)=d$；若$d&gt;f(i-1)$就为第一种情况了，$f(i)=f(i-1)+1$。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个思路是剑指offer书上的，在leetcode上过不了，似乎是因为有空格和大小写的原因</span></span><br><span class="line"><span class="comment">//可以把26的数组换成Map,实际上该方法就是滑动窗口的优化解。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">if</span>(length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character,Integer&gt; position = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">int</span> d = i+<span class="number">1</span>-position.getOrDefault(c,<span class="number">0</span>);</span><br><span class="line">        position.put(c,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(d&gt;curLength)&#123;</span><br><span class="line">            curLength += <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curLength = d;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,curLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>也可以使用滑动窗口和双指针Set集合中存的是下标${i,j}$之间的元素。$j+1$个字母没在集合中时，则加入集合子串长度+1。否则，下标$i$往前移动移动，且依次将指向的字母从set删除，直到把与j+1个字母相同的那个字母不在集合中时，再把j+1个字符加入集合，有生成一个新的子串。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;length&amp;&amp;j&lt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">            set.add(s.charAt(j));</span><br><span class="line">            j++;</span><br><span class="line">            maxLength = Math.max(maxLength,j-i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.remove(s.charAt(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49.丑数"></a>49.丑数</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。leetcode地址：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a>。</p>
<blockquote>
<p>示例<br>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用于存下已经算出来的丑数，后边的丑数都是x(2,3,5)所得</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//只需把算出来的丑数，判断大小排序即可</span></span><br><span class="line">        dp[i] = Math.min(dp[p2]*<span class="number">2</span>,Math.min(dp[p3]*<span class="number">3</span>,dp[p5]*<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == dp[p2]*<span class="number">2</span>)&#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == dp[p3]*<span class="number">3</span>)&#123;</span><br><span class="line">            p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == dp[p5]*<span class="number">2</span>)&#123;</span><br><span class="line">            p5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">康宁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jwkang99.github.io/posts/30d88c90.html">https://jwkang99.github.io/posts/30d88c90.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jwkang99.github.io">解忧杂货铺</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法    </a><a class="post-meta__tags" href="/tags/leetcode/">leetcode    </a><a class="post-meta__tags" href="/tags/%E5%89%91%E6%8C%87offer/">剑指offer    </a></div><div class="post_share"><div class="social-share" data-image="/img/剑指offer.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/12c3d10b.html"><img class="prev_cover lazyload" data-src="/img/基础知识.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>java实现读写锁</span></div></a></div><div class="next-post pull_right"><a href="/posts/41c70678.html"><img class="next_cover lazyload" data-src="/img/设计模式.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>设计模式简单实现(结构型)</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/dc82b054.html" title="785.判断二分图"><img class="relatedPosts_cover lazyload"data-src="/img/leetcode.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-16</div><div class="relatedPosts_title">785.判断二分图</div></div></a></div><div class="relatedPosts_item"><a href="/posts/e43b0cf4.html" title="139.单词拆分"><img class="relatedPosts_cover lazyload"data-src="/img/leetcode.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-09</div><div class="relatedPosts_title">139.单词拆分</div></div></a></div><div class="relatedPosts_item"><a href="/posts/88135758.html" title="312.戳气球"><img class="relatedPosts_cover lazyload"data-src="/img/leetcode.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-19</div><div class="relatedPosts_title">312.戳气球</div></div></a></div><div class="relatedPosts_item"><a href="/posts/cabc759b.html" title="315.计算右侧小于当前元素的个数"><img class="relatedPosts_cover lazyload"data-src="/img/leetcode.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-11</div><div class="relatedPosts_title">315.计算右侧小于当前元素的个数</div></div></a></div><div class="relatedPosts_item"><a href="/posts/bc673c55.html" title="309.股票最大收益"><img class="relatedPosts_cover lazyload"data-src="/img/leetcode.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-12</div><div class="relatedPosts_title">309.股票最大收益</div></div></a></div><div class="relatedPosts_item"><a href="/posts/8628805.html" title="前缀和"><img class="relatedPosts_cover lazyload"data-src="/img/leetcode.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-22</div><div class="relatedPosts_title">前缀和</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 康宁</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>